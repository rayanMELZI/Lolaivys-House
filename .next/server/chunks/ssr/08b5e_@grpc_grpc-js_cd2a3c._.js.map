{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/constants.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexport enum Status {\n  OK = 0,\n  CANCELLED,\n  UNKNOWN,\n  INVALID_ARGUMENT,\n  DEADLINE_EXCEEDED,\n  NOT_FOUND,\n  ALREADY_EXISTS,\n  PERMISSION_DENIED,\n  RESOURCE_EXHAUSTED,\n  FAILED_PRECONDITION,\n  ABORTED,\n  OUT_OF_RANGE,\n  UNIMPLEMENTED,\n  INTERNAL,\n  UNAVAILABLE,\n  DATA_LOSS,\n  UNAUTHENTICATED,\n}\n\nexport enum LogVerbosity {\n  DEBUG = 0,\n  INFO,\n  ERROR,\n  NONE,\n}\n\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */\nexport enum Propagate {\n  DEADLINE = 1,\n  CENSUS_STATS_CONTEXT = 2,\n  CENSUS_TRACING_CONTEXT = 4,\n  CANCELLATION = 8,\n  // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n  DEFAULTS = 0xffff |\n    Propagate.DEADLINE |\n    Propagate.CENSUS_STATS_CONTEXT |\n    Propagate.CENSUS_TRACING_CONTEXT |\n    Propagate.CANCELLATION,\n}\n\n// -1 means unlimited\nexport const DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n\n// 4 MB default\nexport const DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,IAAY;AAAZ,CAAA,SAAY,MAAM;IAChB,MAAA,CAAA,MAAA,CAAA,KAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,YAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,UAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,mBAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,oBAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,YAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,iBAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,oBAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,qBAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,sBAAA,GAAA,EAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,UAAA,GAAA,GAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,eAAA,GAAA,GAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,gBAAA,GAAA,GAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,WAAA,GAAA,GAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,cAAA,GAAA,GAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,YAAA,GAAA,GAAA,GAAA;IACA,MAAA,CAAA,MAAA,CAAA,kBAAA,GAAA,GAAA,GAAA;AACF,CAAC,EAlBW,UAAM,CAAA,QAAA,MAAA,GAAN,SAAM,CAAA,CAAA;AAoBlB,IAAY;AAAZ,CAAA,SAAY,YAAY;IACtB,YAAA,CAAA,YAAA,CAAA,QAAA,GAAA,EAAA,GAAA;IACA,YAAA,CAAA,YAAA,CAAA,OAAA,GAAA,EAAA,GAAA;IACA,YAAA,CAAA,YAAA,CAAA,QAAA,GAAA,EAAA,GAAA;IACA,YAAA,CAAA,YAAA,CAAA,OAAA,GAAA,EAAA,GAAA;AACF,CAAC,EALW,gBAAY,CAAA,QAAA,YAAA,GAAZ,eAAY,CAAA,CAAA;AAOxB;;;IAIA,IAAY;AAAZ,CAAA,SAAY,SAAS;IACnB,SAAA,CAAA,SAAA,CAAA,WAAA,GAAA,EAAA,GAAA;IACA,SAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,EAAA,GAAA;IACA,SAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,EAAA,GAAA;IACA,SAAA,CAAA,SAAA,CAAA,eAAA,GAAA,EAAA,GAAA;IACA,4FAA4F;IAC5F,SAAA,CAAA,SAAA,CAAA,WAAA,GAAA,MAAA,GAAA;AAKF,CAAC,EAXW,aAAS,CAAA,QAAA,SAAA,GAAT,YAAS,CAAA,CAAA;AAarB,qBAAqB;AACR,QAAA,+BAA+B,GAAG,CAAC;AAEhD,eAAe;AACF,QAAA,kCAAkC,GAAG,IAAI,OAAO"}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/logging.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { LogVerbosity } from './constants';\nimport { pid } from 'process';\n\nconst clientVersion = require('../../package.json').version;\n\nconst DEFAULT_LOGGER: Partial<Console> = {\n  error: (message?: any, ...optionalParams: any[]) => {\n    console.error('E ' + message, ...optionalParams);\n  },\n  info: (message?: any, ...optionalParams: any[]) => {\n    console.error('I ' + message, ...optionalParams);\n  },\n  debug: (message?: any, ...optionalParams: any[]) => {\n    console.error('D ' + message, ...optionalParams);\n  },\n};\n\nlet _logger: Partial<Console> = DEFAULT_LOGGER;\nlet _logVerbosity: LogVerbosity = LogVerbosity.ERROR;\n\nconst verbosityString =\n  process.env.GRPC_NODE_VERBOSITY ?? process.env.GRPC_VERBOSITY ?? '';\n\nswitch (verbosityString.toUpperCase()) {\n  case 'DEBUG':\n    _logVerbosity = LogVerbosity.DEBUG;\n    break;\n  case 'INFO':\n    _logVerbosity = LogVerbosity.INFO;\n    break;\n  case 'ERROR':\n    _logVerbosity = LogVerbosity.ERROR;\n    break;\n  case 'NONE':\n    _logVerbosity = LogVerbosity.NONE;\n    break;\n  default:\n  // Ignore any other values\n}\n\nexport const getLogger = (): Partial<Console> => {\n  return _logger;\n};\n\nexport const setLogger = (logger: Partial<Console>): void => {\n  _logger = logger;\n};\n\nexport const setLoggerVerbosity = (verbosity: LogVerbosity): void => {\n  _logVerbosity = verbosity;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const log = (severity: LogVerbosity, ...args: any[]): void => {\n  let logFunction: typeof DEFAULT_LOGGER.error;\n  if (severity >= _logVerbosity) {\n    switch (severity) {\n      case LogVerbosity.DEBUG:\n        logFunction = _logger.debug;\n        break;\n      case LogVerbosity.INFO:\n        logFunction = _logger.info;\n        break;\n      case LogVerbosity.ERROR:\n        logFunction = _logger.error;\n        break;\n    }\n    /* Fall back to _logger.error when other methods are not available for\n     * compatiblity with older behavior that always logged to _logger.error */\n    if (!logFunction) {\n      logFunction = _logger.error;\n    }\n    if (logFunction) {\n      logFunction.bind(_logger)(...args);\n    }\n  }\n};\n\nconst tracersString =\n  process.env.GRPC_NODE_TRACE ?? process.env.GRPC_TRACE ?? '';\nconst enabledTracers = new Set<string>();\nconst disabledTracers = new Set<string>();\nfor (const tracerName of tracersString.split(',')) {\n  if (tracerName.startsWith('-')) {\n    disabledTracers.add(tracerName.substring(1));\n  } else {\n    enabledTracers.add(tracerName);\n  }\n}\nconst allEnabled = enabledTracers.has('all');\n\nexport function trace(\n  severity: LogVerbosity,\n  tracer: string,\n  text: string\n): void {\n  if (isTracerEnabled(tracer)) {\n    log(severity, new Date().toISOString() + ' | v' + clientVersion + ' ' + pid + ' | ' + tracer + ' | ' + text);\n  }\n}\n\nexport function isTracerEnabled(tracer: string): boolean {\n  return (\n    !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer))\n  );\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,MAAA;AACA,MAAA;AAEA,MAAM,gBAAgB,kFAA8B,OAAO;AAE3D,MAAM,iBAAmC;IACvC,OAAO,CAAC,SAAe,GAAG;QACxB,QAAQ,KAAK,CAAC,OAAO,YAAY;IACnC;IACA,MAAM,CAAC,SAAe,GAAG;QACvB,QAAQ,KAAK,CAAC,OAAO,YAAY;IACnC;IACA,OAAO,CAAC,SAAe,GAAG;QACxB,QAAQ,KAAK,CAAC,OAAO,YAAY;IACnC;;AAGF,IAAI,UAA4B;AAChC,IAAI,gBAA8B,YAAA,YAAY,CAAC,KAAK;AAEpD,MAAM,kBACJ,CAAA,KAAA,CAAA,KAAA,QAAQ,GAAG,CAAC,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,QAAQ,GAAG,CAAC,cAAc,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI;AAEnE,OAAQ,gBAAgB,WAAW;IACjC,KAAK;QACH,gBAAgB,YAAA,YAAY,CAAC,KAAK;QAClC;IACF,KAAK;QACH,gBAAgB,YAAA,YAAY,CAAC,IAAI;QACjC;IACF,KAAK;QACH,gBAAgB,YAAA,YAAY,CAAC,KAAK;QAClC;IACF,KAAK;QACH,gBAAgB,YAAA,YAAY,CAAC,IAAI;QACjC;IACF;AAEF;AAEO,MAAM,YAAY;IACvB,OAAO;AACT;AAFa,QAAA,SAAS,GAAA;AAIf,MAAM,YAAY,CAAC;IACxB,UAAU;AACZ;AAFa,QAAA,SAAS,GAAA;AAIf,MAAM,qBAAqB,CAAC;IACjC,gBAAgB;AAClB;AAFa,QAAA,kBAAkB,GAAA;AAI/B,8DAA8D;AACvD,MAAM,MAAM,CAAC,UAAwB,GAAG;IAC7C,IAAI;IACJ,IAAI,YAAY,eAAe;QAC7B,OAAQ;YACN,KAAK,YAAA,YAAY,CAAC,KAAK;gBACrB,cAAc,QAAQ,KAAK;gBAC3B;YACF,KAAK,YAAA,YAAY,CAAC,IAAI;gBACpB,cAAc,QAAQ,IAAI;gBAC1B;YACF,KAAK,YAAA,YAAY,CAAC,KAAK;gBACrB,cAAc,QAAQ,KAAK;gBAC3B;QACJ;QACA;mFAEA,IAAI,CAAC,aAAa;YAChB,cAAc,QAAQ,KAAK;QAC7B;QACA,IAAI,aAAa;YACf,YAAY,IAAI,CAAC,YAAY;QAC/B;IACF;AACF;AAvBa,QAAA,GAAG,GAAA;AAyBhB,MAAM,gBACJ,CAAA,KAAA,CAAA,KAAA,QAAQ,GAAG,CAAC,eAAe,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,QAAQ,GAAG,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI;AAC3D,MAAM,iBAAiB,IAAI;AAC3B,MAAM,kBAAkB,IAAI;AAC5B,KAAK,MAAM,cAAc,cAAc,KAAK,CAAC,KAAM;IACjD,IAAI,WAAW,UAAU,CAAC,MAAM;QAC9B,gBAAgB,GAAG,CAAC,WAAW,SAAS,CAAC;IAC3C,OAAO;QACL,eAAe,GAAG,CAAC;IACrB;AACF;AACA,MAAM,aAAa,eAAe,GAAG,CAAC;AAEtC,SAAgB,MACd,QAAsB,EACtB,MAAc,EACd,IAAY;IAEZ,IAAI,gBAAgB,SAAS;QAC3B,CAAA,GAAA,QAAA,GAAG,EAAC,UAAU,IAAI,OAAO,WAAW,KAAK,SAAS,gBAAgB,MAAM,UAAA,GAAG,GAAG,QAAQ,SAAS,QAAQ;IACzG;AACF;AARA,QAAA,KAAA,GAAA;AAUA,SAAgB,gBAAgB,MAAc;IAC5C,OACE,CAAC,gBAAgB,GAAG,CAAC,WAAW,CAAC,cAAc,eAAe,GAAG,CAAC,OAAO;AAE7E;AAJA,QAAA,eAAA,GAAA"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/error.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexport function getErrorMessage(error: unknown): string {\n  if (error instanceof Error) {\n    return error.message;\n  } else {\n    return String(error);\n  }\n}\n\nexport function getErrorCode(error: unknown): number | null {\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    'code' in error &&\n    typeof (error as Record<string, unknown>).code === 'number'\n  ) {\n    return (error as Record<string, number>).code;\n  } else {\n    return null;\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,SAAgB,gBAAgB,KAAc;IAC5C,IAAI,iBAAiB,OAAO;QAC1B,OAAO,MAAM,OAAO;IACtB,OAAO;QACL,OAAO,OAAO;IAChB;AACF;AANA,QAAA,eAAA,GAAA;AAQA,SAAgB,aAAa,KAAc;IACzC,IACE,OAAO,UAAU,YACjB,UAAU,QACV,UAAU,SACV,OAAQ,MAAkC,IAAI,KAAK,UACnD;QACA,OAAQ,MAAiC,IAAI;IAC/C,OAAO;QACL,OAAO;IACT;AACF;AAXA,QAAA,YAAA,GAAA"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/metadata.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nimport { getErrorMessage } from './error';\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\n\nexport type MetadataValue = string | Buffer;\nexport type MetadataObject = Map<string, MetadataValue[]>;\n\nfunction isLegalKey(key: string): boolean {\n  return LEGAL_KEY_REGEX.test(key);\n}\n\nfunction isLegalNonBinaryValue(value: string): boolean {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\n\nfunction isBinaryKey(key: string): boolean {\n  return key.endsWith('-bin');\n}\n\nfunction isCustomMetadata(key: string): boolean {\n  return !key.startsWith('grpc-');\n}\n\nfunction normalizeKey(key: string): string {\n  return key.toLowerCase();\n}\n\nfunction validate(key: string, value?: MetadataValue): void {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n\n  if (value !== null && value !== undefined) {\n    if (isBinaryKey(key)) {\n      if (!Buffer.isBuffer(value)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (Buffer.isBuffer(value)) {\n        throw new Error(\n          \"keys that don't end with '-bin' must have String values\"\n        );\n      }\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error(\n          'Metadata string value \"' + value + '\" contains illegal characters'\n        );\n      }\n    }\n  }\n}\n\nexport interface MetadataOptions {\n  /* Signal that the request is idempotent. Defaults to false */\n  idempotentRequest?: boolean;\n  /* Signal that the call should not return UNAVAILABLE before it has\n   * started. Defaults to false. */\n  waitForReady?: boolean;\n  /* Signal that the call is cacheable. GRPC is free to use GET verb.\n   * Defaults to false */\n  cacheableRequest?: boolean;\n  /* Signal that the initial metadata should be corked. Defaults to false. */\n  corked?: boolean;\n}\n\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nexport class Metadata {\n  protected internalRepr: MetadataObject = new Map<string, MetadataValue[]>();\n  private options: MetadataOptions;\n\n  constructor(options: MetadataOptions = {}) {\n    this.options = options;\n  }\n\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  set(key: string, value: MetadataValue): void {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  add(key: string, value: MetadataValue): void {\n    key = normalizeKey(key);\n    validate(key, value);\n\n    const existingValue: MetadataValue[] | undefined =\n      this.internalRepr.get(key);\n\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n  remove(key: string): void {\n    key = normalizeKey(key);\n    // validate(key);\n    this.internalRepr.delete(key);\n  }\n\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n  get(key: string): MetadataValue[] {\n    key = normalizeKey(key);\n    // validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n  getMap(): { [key: string]: MetadataValue } {\n    const result: { [key: string]: MetadataValue } = {};\n\n    for (const [key, values] of this.internalRepr) {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n  clone(): Metadata {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n\n    for (const [key, value] of this.internalRepr) {\n      const clonedValue: MetadataValue[] = value.map(v => {\n        if (Buffer.isBuffer(v)) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n\n      newInternalRepr.set(key, clonedValue);\n    }\n\n    return newMetadata;\n  }\n\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n  merge(other: Metadata): void {\n    for (const [key, values] of other.internalRepr) {\n      const mergedValue: MetadataValue[] = (\n        this.internalRepr.get(key) || []\n      ).concat(values);\n\n      this.internalRepr.set(key, mergedValue);\n    }\n  }\n\n  setOptions(options: MetadataOptions) {\n    this.options = options;\n  }\n\n  getOptions(): MetadataOptions {\n    return this.options;\n  }\n\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n  toHttp2Headers(): http2.OutgoingHttpHeaders {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result: http2.OutgoingHttpHeaders = {};\n\n    for (const [key, values] of this.internalRepr) {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(bufToString);\n    }\n\n    return result;\n  }\n\n  /**\n   * This modifies the behavior of JSON.stringify to show an object\n   * representation of the metadata map.\n   */\n  toJSON() {\n    const result: { [key: string]: MetadataValue[] } = {};\n    for (const [key, values] of this.internalRepr) {\n      result[key] = values;\n    }\n    return result;\n  }\n\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n  static fromHttp2Headers(headers: http2.IncomingHttpHeaders): Metadata {\n    const result = new Metadata();\n    for (const key of Object.keys(headers)) {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        continue;\n      }\n\n      const values = headers[key];\n\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach(v => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            result.add(key, values);\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${getErrorMessage(\n          error\n        )}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        log(LogVerbosity.ERROR, message);\n      }\n    }\n\n    return result;\n  }\n}\n\nconst bufToString = (val: string | Buffer): string => {\n  return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 468, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/call-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\n\nexport interface CallMetadataOptions {\n  service_url: string;\n}\n\nexport type CallMetadataGenerator = (\n  options: CallMetadataOptions,\n  cb: (err: Error | null, metadata?: Metadata) => void\n) => void;\n\n// google-auth-library pre-v2.0.0 does not have getRequestHeaders\n// but has getRequestMetadata, which is deprecated in v2.0.0\nexport interface OldOAuth2Client {\n  getRequestMetadata: (\n    url: string,\n    callback: (\n      err: Error | null,\n      headers?: {\n        [index: string]: string;\n      }\n    ) => void\n  ) => void;\n}\n\nexport interface CurrentOAuth2Client {\n  getRequestHeaders: (url?: string) => Promise<{ [index: string]: string }>;\n}\n\nexport type OAuth2Client = OldOAuth2Client | CurrentOAuth2Client;\n\nfunction isCurrentOauth2Client(\n  client: OAuth2Client\n): client is CurrentOAuth2Client {\n  return (\n    'getRequestHeaders' in client &&\n    typeof client.getRequestHeaders === 'function'\n  );\n}\n\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nexport abstract class CallCredentials {\n  /**\n   * Asynchronously generates a new Metadata object.\n   * @param options Options used in generating the Metadata object.\n   */\n  abstract generateMetadata(options: CallMetadataOptions): Promise<Metadata>;\n  /**\n   * Creates a new CallCredentials object from properties of both this and\n   * another CallCredentials object. This object's metadata generator will be\n   * called first.\n   * @param callCredentials The other CallCredentials object.\n   */\n  abstract compose(callCredentials: CallCredentials): CallCredentials;\n\n  /**\n   * Check whether two call credentials objects are equal. Separate\n   * SingleCallCredentials with identical metadata generator functions are\n   * equal.\n   * @param other The other CallCredentials object to compare with.\n   */\n  abstract _equals(other: CallCredentials): boolean;\n\n  /**\n   * Creates a new CallCredentials object from a given function that generates\n   * Metadata objects.\n   * @param metadataGenerator A function that accepts a set of options, and\n   * generates a Metadata object based on these options, which is passed back\n   * to the caller via a supplied (err, metadata) callback.\n   */\n  static createFromMetadataGenerator(\n    metadataGenerator: CallMetadataGenerator\n  ): CallCredentials {\n    return new SingleCallCredentials(metadataGenerator);\n  }\n\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n  static createFromGoogleCredential(\n    googleCredentials: OAuth2Client\n  ): CallCredentials {\n    return CallCredentials.createFromMetadataGenerator((options, callback) => {\n      let getHeaders: Promise<{ [index: string]: string }>;\n      if (isCurrentOauth2Client(googleCredentials)) {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise((resolve, reject) => {\n          googleCredentials.getRequestMetadata(\n            options.service_url,\n            (err, headers) => {\n              if (err) {\n                reject(err);\n                return;\n              }\n              if (!headers) {\n                reject(new Error('Headers not set by metadata plugin'));\n                return;\n              }\n              resolve(headers);\n            }\n          );\n        });\n      }\n      getHeaders.then(\n        headers => {\n          const metadata = new Metadata();\n          for (const key of Object.keys(headers)) {\n            metadata.add(key, headers[key]);\n          }\n          callback(null, metadata);\n        },\n        err => {\n          callback(err);\n        }\n      );\n    });\n  }\n\n  static createEmpty(): CallCredentials {\n    return new EmptyCallCredentials();\n  }\n}\n\nclass ComposedCallCredentials extends CallCredentials {\n  constructor(private creds: CallCredentials[]) {\n    super();\n  }\n\n  async generateMetadata(options: CallMetadataOptions): Promise<Metadata> {\n    const base: Metadata = new Metadata();\n    const generated: Metadata[] = await Promise.all(\n      this.creds.map(cred => cred.generateMetadata(options))\n    );\n    for (const gen of generated) {\n      base.merge(gen);\n    }\n    return base;\n  }\n\n  compose(other: CallCredentials): CallCredentials {\n    return new ComposedCallCredentials(this.creds.concat([other]));\n  }\n\n  _equals(other: CallCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedCallCredentials) {\n      return this.creds.every((value, index) =>\n        value._equals(other.creds[index])\n      );\n    } else {\n      return false;\n    }\n  }\n}\n\nclass SingleCallCredentials extends CallCredentials {\n  constructor(private metadataGenerator: CallMetadataGenerator) {\n    super();\n  }\n\n  generateMetadata(options: CallMetadataOptions): Promise<Metadata> {\n    return new Promise<Metadata>((resolve, reject) => {\n      this.metadataGenerator(options, (err, metadata) => {\n        if (metadata !== undefined) {\n          resolve(metadata);\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  compose(other: CallCredentials): CallCredentials {\n    return new ComposedCallCredentials([this, other]);\n  }\n\n  _equals(other: CallCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SingleCallCredentials) {\n      return this.metadataGenerator === other.metadataGenerator;\n    } else {\n      return false;\n    }\n  }\n}\n\nclass EmptyCallCredentials extends CallCredentials {\n  generateMetadata(options: CallMetadataOptions): Promise<Metadata> {\n    return Promise.resolve(new Metadata());\n  }\n\n  compose(other: CallCredentials): CallCredentials {\n    return other;\n  }\n\n  _equals(other: CallCredentials): boolean {\n    return other instanceof EmptyCallCredentials;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/tls-helpers.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as fs from 'fs';\n\nexport const CIPHER_SUITES: string | undefined =\n  process.env.GRPC_SSL_CIPHER_SUITES;\n\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\n\nlet defaultRootsData: Buffer | null = null;\n\nexport function getDefaultRootsData(): Buffer | null {\n  if (DEFAULT_ROOTS_FILE_PATH) {\n    if (defaultRootsData === null) {\n      defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n    }\n    return defaultRootsData;\n  }\n  return null;\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,MAAA;AAEa,QAAA,aAAa,GACxB,QAAQ,GAAG,CAAC,sBAAsB;AAEpC,MAAM,0BAA0B,QAAQ,GAAG,CAAC,gCAAgC;AAE5E,IAAI,mBAAkC;AAEtC,SAAgB;IACd,IAAI,yBAAyB;QAC3B,IAAI,qBAAqB,MAAM;YAC7B,mBAAmB,GAAG,YAAY,CAAC;QACrC;QACA,OAAO;IACT;IACA,OAAO;AACT;AARA,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 656, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 660, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/channel-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ConnectionOptions,\n  createSecureContext,\n  PeerCertificate,\n  SecureContext,\n} from 'tls';\n\nimport { CallCredentials } from './call-credentials';\nimport { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj: any, friendlyName: string): void {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\n/**\n * A callback that will receive the expected hostname and presented peer\n * certificate as parameters. The callback should return an error to\n * indicate that the presented certificate is considered invalid and\n * otherwise returned undefined.\n */\nexport type CheckServerIdentityCallback = (\n  hostname: string,\n  cert: PeerCertificate\n) => Error | undefined;\n\n/**\n * Additional peer verification options that can be set when creating\n * SSL credentials.\n */\nexport interface VerifyOptions {\n  /**\n   * If set, this callback will be invoked after the usual hostname verification\n   * has been performed on the peer certificate.\n   */\n  checkServerIdentity?: CheckServerIdentityCallback;\n}\n\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nexport abstract class ChannelCredentials {\n  protected callCredentials: CallCredentials;\n\n  protected constructor(callCredentials?: CallCredentials) {\n    this.callCredentials = callCredentials || CallCredentials.createEmpty();\n  }\n  /**\n   * Returns a copy of this object with the included set of per-call credentials\n   * expanded to include callCredentials.\n   * @param callCredentials A CallCredentials object to associate with this\n   * instance.\n   */\n  abstract compose(callCredentials: CallCredentials): ChannelCredentials;\n\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n  _getCallCredentials(): CallCredentials {\n    return this.callCredentials;\n  }\n\n  /**\n   * Gets a SecureContext object generated from input parameters if this\n   * instance was created with createSsl, or null if this instance was created\n   * with createInsecure.\n   */\n  abstract _getConnectionOptions(): ConnectionOptions | null;\n\n  /**\n   * Indicates whether this credentials object creates a secure channel.\n   */\n  abstract _isSecure(): boolean;\n\n  /**\n   * Check whether two channel credentials objects are equal. Two secure\n   * credentials are equal if they were constructed with the same parameters.\n   * @param other The other ChannelCredentials Object\n   */\n  abstract _equals(other: ChannelCredentials): boolean;\n\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(\n    rootCerts?: Buffer | null,\n    privateKey?: Buffer | null,\n    certChain?: Buffer | null,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error(\n        'Private key must be given with accompanying certificate chain'\n      );\n    }\n    if (!privateKey && certChain) {\n      throw new Error(\n        'Certificate chain must be given with accompanying private key'\n      );\n    }\n    const secureContext = createSecureContext({\n      ca: rootCerts ?? getDefaultRootsData() ?? undefined,\n      key: privateKey ?? undefined,\n      cert: certChain ?? undefined,\n      ciphers: CIPHER_SUITES,\n    });\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(\n    secureContext: SecureContext,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure(): ChannelCredentials {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials?: CallCredentials) {\n    super(callCredentials);\n  }\n\n  compose(callCredentials: CallCredentials): never {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return null;\n  }\n  _isSecure(): boolean {\n    return false;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  connectionOptions: ConnectionOptions;\n\n  constructor(\n    private secureContext: SecureContext,\n    private verifyOptions: VerifyOptions\n  ) {\n    super();\n    this.connectionOptions = {\n      secureContext,\n    };\n    // Node asserts that this option is a function, so we cannot pass undefined\n    if (verifyOptions?.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity =\n        verifyOptions.checkServerIdentity;\n    }\n  }\n\n  compose(callCredentials: CallCredentials): ChannelCredentials {\n    const combinedCallCredentials =\n      this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return { ...this.connectionOptions };\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return (\n        this.secureContext === other.secureContext &&\n        this.verifyOptions.checkServerIdentity ===\n          other.verifyOptions.checkServerIdentity\n      );\n    } else {\n      return false;\n    }\n  }\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(\n    private channelCredentials: SecureChannelCredentialsImpl,\n    callCreds: CallCredentials\n  ) {\n    super(callCreds);\n  }\n  compose(callCredentials: CallCredentials) {\n    const combinedCallCredentials =\n      this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(\n      this.channelCredentials,\n      combinedCallCredentials\n    );\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return this.channelCredentials._getConnectionOptions();\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return (\n        this.channelCredentials._equals(other.channelCredentials) &&\n        this.callCredentials._equals(other.callCredentials)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 826, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 830, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/load-balancer.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions } from './channel-options';\nimport { SubchannelAddress } from './subchannel-address';\nimport { ConnectivityState } from './connectivity-state';\nimport { Picker } from './picker';\nimport { ChannelRef, SubchannelRef } from './channelz';\nimport { SubchannelInterface } from './subchannel-interface';\n\n/**\n * A collection of functions associated with a channel that a load balancer\n * can call as necessary.\n */\nexport interface ChannelControlHelper {\n  /**\n   * Returns a subchannel connected to the specified address.\n   * @param subchannelAddress The address to connect to\n   * @param subchannelArgs Extra channel arguments specified by the load balancer\n   */\n  createSubchannel(\n    subchannelAddress: SubchannelAddress,\n    subchannelArgs: ChannelOptions\n  ): SubchannelInterface;\n  /**\n   * Passes a new subchannel picker up to the channel. This is called if either\n   * the connectivity state changes or if a different picker is needed for any\n   * other reason.\n   * @param connectivityState New connectivity state\n   * @param picker New picker\n   */\n  updateState(connectivityState: ConnectivityState, picker: Picker): void;\n  /**\n   * Request new data from the resolver.\n   */\n  requestReresolution(): void;\n  addChannelzChild(child: ChannelRef | SubchannelRef): void;\n  removeChannelzChild(child: ChannelRef | SubchannelRef): void;\n}\n\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */\nexport function createChildChannelControlHelper(\n  parent: ChannelControlHelper,\n  overrides: Partial<ChannelControlHelper>\n): ChannelControlHelper {\n  return {\n    createSubchannel:\n      overrides.createSubchannel?.bind(overrides) ??\n      parent.createSubchannel.bind(parent),\n    updateState:\n      overrides.updateState?.bind(overrides) ?? parent.updateState.bind(parent),\n    requestReresolution:\n      overrides.requestReresolution?.bind(overrides) ??\n      parent.requestReresolution.bind(parent),\n    addChannelzChild:\n      overrides.addChannelzChild?.bind(overrides) ??\n      parent.addChannelzChild.bind(parent),\n    removeChannelzChild:\n      overrides.removeChannelzChild?.bind(overrides) ??\n      parent.removeChannelzChild.bind(parent),\n  };\n}\n\n/**\n * Tracks one or more connected subchannels and determines which subchannel\n * each request should use.\n */\nexport interface LoadBalancer {\n  /**\n   * Gives the load balancer a new list of addresses to start connecting to.\n   * The load balancer will start establishing connections with the new list,\n   * but will continue using any existing connections until the new connections\n   * are established\n   * @param addressList The new list of addresses to connect to\n   * @param lbConfig The load balancing config object from the service config,\n   *     if one was provided\n   */\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig,\n    attributes: { [key: string]: unknown }\n  ): void;\n  /**\n   * If the load balancer is currently in the IDLE state, start connecting.\n   */\n  exitIdle(): void;\n  /**\n   * If the load balancer is currently in the CONNECTING or TRANSIENT_FAILURE\n   * state, reset the current connection backoff timeout to its base value and\n   * transition to CONNECTING if in TRANSIENT_FAILURE.\n   */\n  resetBackoff(): void;\n  /**\n   * The load balancer unrefs all of its subchannels and stops calling methods\n   * of its channel control helper.\n   */\n  destroy(): void;\n  /**\n   * Get the type name for this load balancer type. Must be constant across an\n   * entire load balancer implementation class and must match the name that the\n   * balancer implementation class was registered with.\n   */\n  getTypeName(): string;\n}\n\nexport interface LoadBalancerConstructor {\n  new (channelControlHelper: ChannelControlHelper): LoadBalancer;\n}\n\nexport interface LoadBalancingConfig {\n  getLoadBalancerName(): string;\n  toJsonObject(): object;\n}\n\nexport interface LoadBalancingConfigConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any): LoadBalancingConfig;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  createFromJson(obj: any): LoadBalancingConfig;\n}\n\nconst registeredLoadBalancerTypes: {\n  [name: string]: {\n    LoadBalancer: LoadBalancerConstructor;\n    LoadBalancingConfig: LoadBalancingConfigConstructor;\n  };\n} = {};\n\nlet defaultLoadBalancerType: string | null = null;\n\nexport function registerLoadBalancerType(\n  typeName: string,\n  loadBalancerType: LoadBalancerConstructor,\n  loadBalancingConfigType: LoadBalancingConfigConstructor\n) {\n  registeredLoadBalancerTypes[typeName] = {\n    LoadBalancer: loadBalancerType,\n    LoadBalancingConfig: loadBalancingConfigType,\n  };\n}\n\nexport function registerDefaultLoadBalancerType(typeName: string) {\n  defaultLoadBalancerType = typeName;\n}\n\nexport function createLoadBalancer(\n  config: LoadBalancingConfig,\n  channelControlHelper: ChannelControlHelper\n): LoadBalancer | null {\n  const typeName = config.getLoadBalancerName();\n  if (typeName in registeredLoadBalancerTypes) {\n    return new registeredLoadBalancerTypes[typeName].LoadBalancer(\n      channelControlHelper\n    );\n  } else {\n    return null;\n  }\n}\n\nexport function isLoadBalancerNameRegistered(typeName: string): boolean {\n  return typeName in registeredLoadBalancerTypes;\n}\n\nexport function getFirstUsableConfig(\n  configs: LoadBalancingConfig[],\n  fallbackTodefault?: true\n): LoadBalancingConfig;\nexport function getFirstUsableConfig(\n  configs: LoadBalancingConfig[],\n  fallbackTodefault = false\n): LoadBalancingConfig | null {\n  for (const config of configs) {\n    if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n      return config;\n    }\n  }\n  if (fallbackTodefault) {\n    if (defaultLoadBalancerType) {\n      return new registeredLoadBalancerTypes[\n        defaultLoadBalancerType\n      ]!.LoadBalancingConfig();\n    } else {\n      return null;\n    }\n  } else {\n    return null;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function validateLoadBalancingConfig(obj: any): LoadBalancingConfig {\n  if (!(obj !== null && typeof obj === 'object')) {\n    throw new Error('Load balancing config must be an object');\n  }\n  const keys = Object.keys(obj);\n  if (keys.length !== 1) {\n    throw new Error(\n      'Provided load balancing config has multiple conflicting entries'\n    );\n  }\n  const typeName = keys[0];\n  if (typeName in registeredLoadBalancerTypes) {\n    return registeredLoadBalancerTypes[\n      typeName\n    ].LoadBalancingConfig.createFromJson(obj[typeName]);\n  } else {\n    throw new Error(`Unrecognized load balancing config name ${typeName}`);\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAsDA;;;;;;;IAQA,SAAgB,gCACd,MAA4B,EAC5B,SAAwC;;IAExC,OAAO;QACL,kBACE,CAAA,KAAA,CAAA,KAAA,UAAU,gBAAgB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAC3C,OAAO,gBAAgB,CAAC,IAAI,CAAC;QAC/B,aACE,CAAA,KAAA,CAAA,KAAA,UAAU,WAAW,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,OAAO,WAAW,CAAC,IAAI,CAAC;QACpE,qBACE,CAAA,KAAA,CAAA,KAAA,UAAU,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAC9C,OAAO,mBAAmB,CAAC,IAAI,CAAC;QAClC,kBACE,CAAA,KAAA,CAAA,KAAA,UAAU,gBAAgB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAC3C,OAAO,gBAAgB,CAAC,IAAI,CAAC;QAC/B,qBACE,CAAA,KAAA,CAAA,KAAA,UAAU,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAC9C,OAAO,mBAAmB,CAAC,IAAI,CAAC;;AAEtC;AApBA,QAAA,+BAAA,GAAA;AAgFA,MAAM,8BAKF,CAAA;AAEJ,IAAI,0BAAyC;AAE7C,SAAgB,yBACd,QAAgB,EAChB,gBAAyC,EACzC,uBAAuD;IAEvD,2BAA2B,CAAC,SAAS,GAAG;QACtC,cAAc;QACd,qBAAqB;;AAEzB;AATA,QAAA,wBAAA,GAAA;AAWA,SAAgB,gCAAgC,QAAgB;IAC9D,0BAA0B;AAC5B;AAFA,QAAA,+BAAA,GAAA;AAIA,SAAgB,mBACd,MAA2B,EAC3B,oBAA0C;IAE1C,MAAM,WAAW,OAAO,mBAAmB;IAC3C,IAAI,YAAY,6BAA6B;QAC3C,OAAO,IAAI,2BAA2B,CAAC,SAAS,CAAC,YAAY,CAC3D;IAEJ,OAAO;QACL,OAAO;IACT;AACF;AAZA,QAAA,kBAAA,GAAA;AAcA,SAAgB,6BAA6B,QAAgB;IAC3D,OAAO,YAAY;AACrB;AAFA,QAAA,4BAAA,GAAA;AAQA,SAAgB,qBACd,OAA8B,EAC9B,oBAAoB,KAAK;IAEzB,KAAK,MAAM,UAAU,QAAS;QAC5B,IAAI,OAAO,mBAAmB,MAAM,6BAA6B;YAC/D,OAAO;QACT;IACF;IACA,IAAI,mBAAmB;QACrB,IAAI,yBAAyB;YAC3B,OAAO,IAAI,2BAA2B,CACpC,wBACA,CAAC,mBAAmB;QACxB,OAAO;YACL,OAAO;QACT;IACF,OAAO;QACL,OAAO;IACT;AACF;AApBA,QAAA,oBAAA,GAAA;AAsBA,8DAA8D;AAC9D,SAAgB,4BAA4B,GAAQ;IAClD,IAAI,CAAC,CAAC,QAAQ,QAAQ,OAAO,QAAQ,QAAQ,GAAG;QAC9C,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,IAAI,KAAK,MAAM,KAAK,GAAG;QACrB,MAAM,IAAI,MACR;IAEJ;IACA,MAAM,WAAW,IAAI,CAAC,EAAE;IACxB,IAAI,YAAY,6BAA6B;QAC3C,OAAO,2BAA2B,CAChC,SACD,CAAC,mBAAmB,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS;IACpD,OAAO;QACL,MAAM,IAAI,MAAM,CAAA,wCAAA,EAA2C,SAAQ,CAAE;IACvE;AACF;AAlBA,QAAA,2BAAA,GAAA"}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/service-config.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport * as os from 'os';\nimport { Status } from './constants';\nimport { Duration } from './duration';\nimport {\n  LoadBalancingConfig,\n  validateLoadBalancingConfig,\n} from './load-balancer';\n\nexport interface MethodConfigName {\n  service?: string;\n  method?: string;\n}\n\nexport interface RetryPolicy {\n  maxAttempts: number;\n  initialBackoff: string;\n  maxBackoff: string;\n  backoffMultiplier: number;\n  retryableStatusCodes: (Status | string)[];\n}\n\nexport interface HedgingPolicy {\n  maxAttempts: number;\n  hedgingDelay?: string;\n  nonFatalStatusCodes?: (Status | string)[];\n}\n\nexport interface MethodConfig {\n  name: MethodConfigName[];\n  waitForReady?: boolean;\n  timeout?: Duration;\n  maxRequestBytes?: number;\n  maxResponseBytes?: number;\n  retryPolicy?: RetryPolicy;\n  hedgingPolicy?: HedgingPolicy;\n}\n\nexport interface RetryThrottling {\n  maxTokens: number;\n  tokenRatio: number;\n}\n\nexport interface ServiceConfig {\n  loadBalancingPolicy?: string;\n  loadBalancingConfig: LoadBalancingConfig[];\n  methodConfig: MethodConfig[];\n  retryThrottling?: RetryThrottling;\n}\n\nexport interface ServiceConfigCanaryConfig {\n  clientLanguage?: string[];\n  percentage?: number;\n  clientHostname?: string[];\n  serviceConfig: ServiceConfig;\n}\n\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\n\nfunction validateName(obj: any): MethodConfigName {\n  // In this context, and unset field and '' are considered the same\n  if ('service' in obj && obj.service !== '') {\n    if (typeof obj.service !== 'string') {\n      throw new Error(\n        `Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`\n      );\n    }\n    if ('method' in obj && obj.method !== '') {\n      if (typeof obj.method !== 'string') {\n        throw new Error(\n          `Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`\n        );\n      }\n      return {\n        service: obj.service,\n        method: obj.method,\n      };\n    } else {\n      return {\n        service: obj.service,\n      };\n    }\n  } else {\n    if ('method' in obj && obj.method !== undefined) {\n      throw new Error(\n        `Invalid method config name: method set with empty or unset service`\n      );\n    }\n    return {};\n  }\n}\n\nfunction validateRetryPolicy(obj: any): RetryPolicy {\n  if (\n    !('maxAttempts' in obj) ||\n    !Number.isInteger(obj.maxAttempts) ||\n    obj.maxAttempts < 2\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: maxAttempts must be an integer at least 2'\n    );\n  }\n  if (\n    !('initialBackoff' in obj) ||\n    typeof obj.initialBackoff !== 'string' ||\n    !DURATION_REGEX.test(obj.initialBackoff)\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s'\n    );\n  }\n  if (\n    !('maxBackoff' in obj) ||\n    typeof obj.maxBackoff !== 'string' ||\n    !DURATION_REGEX.test(obj.maxBackoff)\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s'\n    );\n  }\n  if (\n    !('backoffMultiplier' in obj) ||\n    typeof obj.backoffMultiplier !== 'number' ||\n    obj.backoffMultiplier <= 0\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: backoffMultiplier must be a number greater than 0'\n    );\n  }\n  if (\n    !('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))\n  ) {\n    throw new Error(\n      'Invalid method config retry policy: retryableStatusCodes is required'\n    );\n  }\n  if (obj.retryableStatusCodes.length === 0) {\n    throw new Error(\n      'Invalid method config retry policy: retryableStatusCodes must be non-empty'\n    );\n  }\n  for (const value of obj.retryableStatusCodes) {\n    if (typeof value === 'number') {\n      if (!Object.values(Status).includes(value)) {\n        throw new Error(\n          'Invalid method config retry policy: retryableStatusCodes value not in status code range'\n        );\n      }\n    } else if (typeof value === 'string') {\n      if (!Object.values(Status).includes(value.toUpperCase())) {\n        throw new Error(\n          'Invalid method config retry policy: retryableStatusCodes value not a status code name'\n        );\n      }\n    } else {\n      throw new Error(\n        'Invalid method config retry policy: retryableStatusCodes value must be a string or number'\n      );\n    }\n  }\n  return {\n    maxAttempts: obj.maxAttempts,\n    initialBackoff: obj.initialBackoff,\n    maxBackoff: obj.maxBackoff,\n    backoffMultiplier: obj.backoffMultiplier,\n    retryableStatusCodes: obj.retryableStatusCodes,\n  };\n}\n\nfunction validateHedgingPolicy(obj: any): HedgingPolicy {\n  if (\n    !('maxAttempts' in obj) ||\n    !Number.isInteger(obj.maxAttempts) ||\n    obj.maxAttempts < 2\n  ) {\n    throw new Error(\n      'Invalid method config hedging policy: maxAttempts must be an integer at least 2'\n    );\n  }\n  if (\n    'hedgingDelay' in obj &&\n    (typeof obj.hedgingDelay !== 'string' ||\n      !DURATION_REGEX.test(obj.hedgingDelay))\n  ) {\n    throw new Error(\n      'Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s'\n    );\n  }\n  if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n    for (const value of obj.nonFatalStatusCodes) {\n      if (typeof value === 'number') {\n        if (!Object.values(Status).includes(value)) {\n          throw new Error(\n            'Invlid method config hedging policy: nonFatalStatusCodes value not in status code range'\n          );\n        }\n      } else if (typeof value === 'string') {\n        if (!Object.values(Status).includes(value.toUpperCase())) {\n          throw new Error(\n            'Invlid method config hedging policy: nonFatalStatusCodes value not a status code name'\n          );\n        }\n      } else {\n        throw new Error(\n          'Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number'\n        );\n      }\n    }\n  }\n  const result: HedgingPolicy = {\n    maxAttempts: obj.maxAttempts,\n  };\n  if (obj.hedgingDelay) {\n    result.hedgingDelay = obj.hedgingDelay;\n  }\n  if (obj.nonFatalStatusCodes) {\n    result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n  }\n  return result;\n}\n\nfunction validateMethodConfig(obj: any): MethodConfig {\n  const result: MethodConfig = {\n    name: [],\n  };\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n    result.waitForReady = obj.waitForReady;\n  }\n  if ('timeout' in obj) {\n    if (typeof obj.timeout === 'object') {\n      if (\n        !('seconds' in obj.timeout) ||\n        !(typeof obj.timeout.seconds === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.seconds');\n      }\n      if (\n        !('nanos' in obj.timeout) ||\n        !(typeof obj.timeout.nanos === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.nanos');\n      }\n      result.timeout = obj.timeout;\n    } else if (\n      typeof obj.timeout === 'string' &&\n      DURATION_REGEX.test(obj.timeout)\n    ) {\n      const timeoutParts = obj.timeout\n        .substring(0, obj.timeout.length - 1)\n        .split('.');\n      result.timeout = {\n        seconds: timeoutParts[0] | 0,\n        nanos: (timeoutParts[1] ?? 0) | 0,\n      };\n    } else {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n  }\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n  if ('retryPolicy' in obj) {\n    if ('hedgingPolicy' in obj) {\n      throw new Error(\n        'Invalid method config: retryPolicy and hedgingPolicy cannot both be specified'\n      );\n    } else {\n      result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n    }\n  } else if ('hedgingPolicy' in obj) {\n    result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n  }\n  return result;\n}\n\nexport function validateRetryThrottling(obj: any): RetryThrottling {\n  if (\n    !('maxTokens' in obj) ||\n    typeof obj.maxTokens !== 'number' ||\n    obj.maxTokens <= 0 ||\n    obj.maxTokens > 1000\n  ) {\n    throw new Error(\n      'Invalid retryThrottling: maxTokens must be a number in (0, 1000]'\n    );\n  }\n  if (\n    !('tokenRatio' in obj) ||\n    typeof obj.tokenRatio !== 'number' ||\n    obj.tokenRatio <= 0\n  ) {\n    throw new Error(\n      'Invalid retryThrottling: tokenRatio must be a number greater than 0'\n    );\n  }\n  return {\n    maxTokens: +(obj.maxTokens as number).toFixed(3),\n    tokenRatio: +(obj.tokenRatio as number).toFixed(3),\n  };\n}\n\nexport function validateServiceConfig(obj: any): ServiceConfig {\n  const result: ServiceConfig = {\n    loadBalancingConfig: [],\n    methodConfig: [],\n  };\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  }\n  if ('retryThrottling' in obj) {\n    result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n  }\n  // Validate method name uniqueness\n  const seenMethodNames: MethodConfigName[] = [];\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (\n          name.service === seenName.service &&\n          name.method === seenName.method\n        ) {\n          throw new Error(\n            `Invalid service config: duplicate name ${name.service}/${name.method}`\n          );\n        }\n      }\n      seenMethodNames.push(name);\n    }\n  }\n  return result;\n}\n\nfunction validateCanaryConfig(obj: any): ServiceConfigCanaryConfig {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n  const result: ServiceConfigCanaryConfig = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig),\n  };\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientLanguage'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientHostname'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n  if ('percentage' in obj) {\n    if (\n      typeof obj.percentage === 'number' &&\n      0 <= obj.percentage &&\n      obj.percentage <= 100\n    ) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  }\n  // Validate that no unexpected fields are present\n  const allowedFields = [\n    'clientLanguage',\n    'percentage',\n    'clientHostname',\n    'serviceConfig',\n  ];\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(\n        `Invalid service config choice: unexpected field ${field}`\n      );\n    }\n  }\n  return result;\n}\n\nfunction validateAndSelectCanaryConfig(\n  obj: any,\n  percentage: number\n): ServiceConfig {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n    if (\n      typeof validatedConfig.percentage === 'number' &&\n      percentage > validatedConfig.percentage\n    ) {\n      continue;\n    }\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n      if (!languageMatched) {\n        continue;\n      }\n    }\n    return validatedConfig.serviceConfig;\n  }\n  throw new Error('No matching service config found');\n}\n\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nexport function extractAndSelectServiceConfig(\n  txtRecord: string[][],\n  percentage: number\n): ServiceConfig | null {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson: any = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n  return null;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1298, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1302, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/connectivity-state.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexport enum ConnectivityState {\n  IDLE,\n  CONNECTING,\n  READY,\n  TRANSIENT_FAILURE,\n  SHUTDOWN,\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,IAAY;AAAZ,CAAA,SAAY,iBAAiB;IAC3B,iBAAA,CAAA,iBAAA,CAAA,OAAA,GAAA,EAAA,GAAA;IACA,iBAAA,CAAA,iBAAA,CAAA,aAAA,GAAA,EAAA,GAAA;IACA,iBAAA,CAAA,iBAAA,CAAA,QAAA,GAAA,EAAA,GAAA;IACA,iBAAA,CAAA,iBAAA,CAAA,oBAAA,GAAA,EAAA,GAAA;IACA,iBAAA,CAAA,iBAAA,CAAA,WAAA,GAAA,EAAA,GAAA;AACF,CAAC,EANW,qBAAiB,CAAA,QAAA,iBAAA,GAAjB,oBAAiB,CAAA,CAAA"}},
    {"offset": {"line": 1330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1334, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/uri-parser.ts"],"sourcesContent":["/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexport interface GrpcUri {\n  scheme?: string;\n  authority?: string;\n  path: string;\n}\n\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\n\nexport function parseUri(uriString: string): GrpcUri | null {\n  const parsedUri = URI_REGEX.exec(uriString);\n  if (parsedUri === null) {\n    return null;\n  }\n  return {\n    scheme: parsedUri[1],\n    authority: parsedUri[2],\n    path: parsedUri[3],\n  };\n}\n\nexport interface HostPort {\n  host: string;\n  port?: number;\n}\n\nconst NUMBER_REGEX = /^\\d+$/;\n\nexport function splitHostPort(path: string): HostPort | null {\n  if (path.startsWith('[')) {\n    const hostEnd = path.indexOf(']');\n    if (hostEnd === -1) {\n      return null;\n    }\n    const host = path.substring(1, hostEnd);\n    /* Only an IPv6 address should be in bracketed notation, and an IPv6\n     * address should have at least one colon */\n    if (host.indexOf(':') === -1) {\n      return null;\n    }\n    if (path.length > hostEnd + 1) {\n      if (path[hostEnd + 1] === ':') {\n        const portString = path.substring(hostEnd + 2);\n        if (NUMBER_REGEX.test(portString)) {\n          return {\n            host: host,\n            port: +portString,\n          };\n        } else {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else {\n      return {\n        host,\n      };\n    }\n  } else {\n    const splitPath = path.split(':');\n    /* Exactly one colon means that this is host:port. Zero colons means that\n     * there is no port. And multiple colons means that this is a bare IPv6\n     * address with no port */\n    if (splitPath.length === 2) {\n      if (NUMBER_REGEX.test(splitPath[1])) {\n        return {\n          host: splitPath[0],\n          port: +splitPath[1],\n        };\n      } else {\n        return null;\n      }\n    } else {\n      return {\n        host: path,\n      };\n    }\n  }\n}\n\nexport function uriToString(uri: GrpcUri): string {\n  let result = '';\n  if (uri.scheme !== undefined) {\n    result += uri.scheme + ':';\n  }\n  if (uri.authority !== undefined) {\n    result += '//' + uri.authority + '/';\n  }\n  result += uri.path;\n  return result;\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAuBA;;;;;IAMA,MAAM,YAAY;AAElB,SAAgB,SAAS,SAAiB;IACxC,MAAM,YAAY,UAAU,IAAI,CAAC;IACjC,IAAI,cAAc,MAAM;QACtB,OAAO;IACT;IACA,OAAO;QACL,QAAQ,SAAS,CAAC,EAAE;QACpB,WAAW,SAAS,CAAC,EAAE;QACvB,MAAM,SAAS,CAAC,EAAE;;AAEtB;AAVA,QAAA,QAAA,GAAA;AAiBA,MAAM,eAAe;AAErB,SAAgB,cAAc,IAAY;IACxC,IAAI,KAAK,UAAU,CAAC,MAAM;QACxB,MAAM,UAAU,KAAK,OAAO,CAAC;QAC7B,IAAI,YAAY,CAAC,GAAG;YAClB,OAAO;QACT;QACA,MAAM,OAAO,KAAK,SAAS,CAAC,GAAG;QAC/B;qDAEA,IAAI,KAAK,OAAO,CAAC,SAAS,CAAC,GAAG;YAC5B,OAAO;QACT;QACA,IAAI,KAAK,MAAM,GAAG,UAAU,GAAG;YAC7B,IAAI,IAAI,CAAC,UAAU,EAAE,KAAK,KAAK;gBAC7B,MAAM,aAAa,KAAK,SAAS,CAAC,UAAU;gBAC5C,IAAI,aAAa,IAAI,CAAC,aAAa;oBACjC,OAAO;wBACL,MAAM;wBACN,MAAM,CAAC;;gBAEX,OAAO;oBACL,OAAO;gBACT;YACF,OAAO;gBACL,OAAO;YACT;QACF,OAAO;YACL,OAAO;gBACL;;QAEJ;IACF,OAAO;QACL,MAAM,YAAY,KAAK,KAAK,CAAC;QAC7B;;mCAGA,IAAI,UAAU,MAAM,KAAK,GAAG;YAC1B,IAAI,aAAa,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG;gBACnC,OAAO;oBACL,MAAM,SAAS,CAAC,EAAE;oBAClB,MAAM,CAAC,SAAS,CAAC,EAAE;;YAEvB,OAAO;gBACL,OAAO;YACT;QACF,OAAO;YACL,OAAO;gBACL,MAAM;;QAEV;IACF;AACF;AAnDA,QAAA,aAAA,GAAA;AAqDA,SAAgB,YAAY,GAAY;IACtC,IAAI,SAAS;IACb,IAAI,IAAI,MAAM,KAAK,WAAW;QAC5B,UAAU,IAAI,MAAM,GAAG;IACzB;IACA,IAAI,IAAI,SAAS,KAAK,WAAW;QAC/B,UAAU,OAAO,IAAI,SAAS,GAAG;IACnC;IACA,UAAU,IAAI,IAAI;IAClB,OAAO;AACT;AAVA,QAAA,WAAA,GAAA"}},
    {"offset": {"line": 1436, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1440, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/resolver.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { MethodConfig, ServiceConfig } from './service-config';\nimport { StatusObject } from './call-interface';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChannelOptions } from './channel-options';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { Filter, FilterFactory } from './filter';\n\nexport interface CallConfig {\n  methodConfig: MethodConfig;\n  onCommitted?: () => void;\n  pickInformation: { [key: string]: string };\n  status: Status;\n  dynamicFilterFactories: FilterFactory<Filter>[];\n}\n\n/**\n * Selects a configuration for a method given the name and metadata. Defined in\n * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#new-functionality-in-grpc\n */\nexport interface ConfigSelector {\n  (methodName: string, metadata: Metadata): CallConfig;\n}\n\n/**\n * A listener object passed to the resolver's constructor that provides name\n * resolution updates back to the resolver's owner.\n */\nexport interface ResolverListener {\n  /**\n   * Called whenever the resolver has new name resolution results to report\n   * @param addressList The new list of backend addresses\n   * @param serviceConfig The new service configuration corresponding to the\n   *     `addressList`. Will be `null` if no service configuration was\n   *     retrieved or if the service configuration was invalid\n   * @param serviceConfigError If non-`null`, indicates that the retrieved\n   *     service configuration was invalid\n   */\n  onSuccessfulResolution(\n    addressList: SubchannelAddress[],\n    serviceConfig: ServiceConfig | null,\n    serviceConfigError: StatusObject | null,\n    configSelector: ConfigSelector | null,\n    attributes: { [key: string]: unknown }\n  ): void;\n  /**\n   * Called whenever a name resolution attempt fails.\n   * @param error Describes how resolution failed\n   */\n  onError(error: StatusObject): void;\n}\n\n/**\n * A resolver class that handles one or more of the name syntax schemes defined\n * in the [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n */\nexport interface Resolver {\n  /**\n   * Indicates that the caller wants new name resolution data. Calling this\n   * function may eventually result in calling one of the `ResolverListener`\n   * functions, but that is not guaranteed. Those functions will never be\n   * called synchronously with the constructor or updateResolution.\n   */\n  updateResolution(): void;\n\n  /**\n   * Discard all resources owned by the resolver. A later call to\n   * `updateResolution` should reinitialize those resources.  No\n   * `ResolverListener` callbacks should be called after `destroy` is called\n   * until `updateResolution` is called again.\n   */\n  destroy(): void;\n}\n\nexport interface ResolverConstructor {\n  new (\n    target: GrpcUri,\n    listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ): Resolver;\n  /**\n   * Get the default authority for a target. This loosely corresponds to that\n   * target's hostname. Throws an error if this resolver class cannot parse the\n   * `target`.\n   * @param target\n   */\n  getDefaultAuthority(target: GrpcUri): string;\n}\n\nconst registeredResolvers: { [scheme: string]: ResolverConstructor } = {};\nlet defaultScheme: string | null = null;\n\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nexport function registerResolver(\n  scheme: string,\n  resolverClass: ResolverConstructor\n) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nexport function registerDefaultScheme(scheme: string) {\n  defaultScheme = scheme;\n}\n\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nexport function createResolver(\n  target: GrpcUri,\n  listener: ResolverListener,\n  options: ChannelOptions\n): Resolver {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(\n      `No resolver could be created for target ${uriToString(target)}`\n    );\n  }\n}\n\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nexport function getDefaultAuthority(target: GrpcUri): string {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uriToString(target)}`);\n  }\n}\n\nexport function mapUriDefaultScheme(target: GrpcUri): GrpcUri | null {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uriToString(target),\n      };\n    } else {\n      return null;\n    }\n  }\n  return target;\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAoBA,MAAA;AAuFA,MAAM,sBAAiE,CAAA;AACvE,IAAI,gBAA+B;AAEnC;;;;;;IAOA,SAAgB,iBACd,MAAc,EACd,aAAkC;IAElC,mBAAmB,CAAC,OAAO,GAAG;AAChC;AALA,QAAA,gBAAA,GAAA;AAOA;;;;IAKA,SAAgB,sBAAsB,MAAc;IAClD,gBAAgB;AAClB;AAFA,QAAA,qBAAA,GAAA;AAIA;;;;;IAMA,SAAgB,eACd,MAAe,EACf,QAA0B,EAC1B,OAAuB;IAEvB,IAAI,OAAO,MAAM,KAAK,aAAa,OAAO,MAAM,IAAI,qBAAqB;QACvE,OAAO,IAAI,mBAAmB,CAAC,OAAO,MAAM,CAAC,CAAC,QAAQ,UAAU;IAClE,OAAO;QACL,MAAM,IAAI,MACR,CAAA,wCAAA,EAA2C,CAAA,GAAA,aAAA,WAAW,EAAC,QAAO,CAAE;IAEpE;AACF;AAZA,QAAA,cAAA,GAAA;AAcA;;;;IAKA,SAAgB,oBAAoB,MAAe;IACjD,IAAI,OAAO,MAAM,KAAK,aAAa,OAAO,MAAM,IAAI,qBAAqB;QACvE,OAAO,mBAAmB,CAAC,OAAO,MAAM,CAAC,CAAC,mBAAmB,CAAC;IAChE,OAAO;QACL,MAAM,IAAI,MAAM,CAAA,eAAA,EAAkB,CAAA,GAAA,aAAA,WAAW,EAAC,QAAO,CAAE;IACzD;AACF;AANA,QAAA,mBAAA,GAAA;AAQA,SAAgB,oBAAoB,MAAe;IACjD,IAAI,OAAO,MAAM,KAAK,aAAa,CAAC,CAAC,OAAO,MAAM,IAAI,mBAAmB,GAAG;QAC1E,IAAI,kBAAkB,MAAM;YAC1B,OAAO;gBACL,QAAQ;gBACR,WAAW;gBACX,MAAM,CAAA,GAAA,aAAA,WAAW,EAAC;;QAEtB,OAAO;YACL,OAAO;QACT;IACF;IACA,OAAO;AACT;AAbA,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 1521, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1525, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/picker.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { StatusObject } from './call-interface';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { LoadBalancer } from './load-balancer';\nimport { SubchannelInterface } from './subchannel-interface';\n\nexport enum PickResultType {\n  COMPLETE,\n  QUEUE,\n  TRANSIENT_FAILURE,\n  DROP,\n}\n\nexport interface PickResult {\n  pickResultType: PickResultType;\n  /**\n   * The subchannel to use as the transport for the call. Only meaningful if\n   * `pickResultType` is COMPLETE. If null, indicates that the call should be\n   * dropped.\n   */\n  subchannel: SubchannelInterface | null;\n  /**\n   * The status object to end the call with. Populated if and only if\n   * `pickResultType` is TRANSIENT_FAILURE.\n   */\n  status: StatusObject | null;\n  onCallStarted: (() => void) | null;\n  onCallEnded: ((statusCode: Status) => void) | null;\n}\n\nexport interface CompletePickResult extends PickResult {\n  pickResultType: PickResultType.COMPLETE;\n  subchannel: SubchannelInterface | null;\n  status: null;\n  onCallStarted: (() => void) | null;\n  onCallEnded: ((statusCode: Status) => void) | null;\n}\n\nexport interface QueuePickResult extends PickResult {\n  pickResultType: PickResultType.QUEUE;\n  subchannel: null;\n  status: null;\n  onCallStarted: null;\n  onCallEnded: null;\n}\n\nexport interface TransientFailurePickResult extends PickResult {\n  pickResultType: PickResultType.TRANSIENT_FAILURE;\n  subchannel: null;\n  status: StatusObject;\n  onCallStarted: null;\n  onCallEnded: null;\n}\n\nexport interface DropCallPickResult extends PickResult {\n  pickResultType: PickResultType.DROP;\n  subchannel: null;\n  status: StatusObject;\n  onCallStarted: null;\n  onCallEnded: null;\n}\n\nexport interface PickArgs {\n  metadata: Metadata;\n  extraPickInfo: { [key: string]: string };\n}\n\n/**\n * A proxy object representing the momentary state of a load balancer. Picks\n * subchannels or returns other information based on that state. Should be\n * replaced every time the load balancer changes state.\n */\nexport interface Picker {\n  pick(pickArgs: PickArgs): PickResult;\n}\n\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */\nexport class UnavailablePicker implements Picker {\n  private status: StatusObject;\n  constructor(status?: Partial<StatusObject>) {\n    this.status = {\n      code: Status.UNAVAILABLE,\n      details: 'No connection established',\n      metadata: new Metadata(),\n      ...status,\n    };\n  }\n  pick(pickArgs: PickArgs): TransientFailurePickResult {\n    return {\n      pickResultType: PickResultType.TRANSIENT_FAILURE,\n      subchannel: null,\n      status: this.status,\n      onCallStarted: null,\n      onCallEnded: null,\n    };\n  }\n}\n\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */\nexport class QueuePicker {\n  private calledExitIdle = false;\n  // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n  constructor(private loadBalancer: LoadBalancer) {}\n\n  pick(pickArgs: PickArgs): QueuePickResult {\n    if (!this.calledExitIdle) {\n      process.nextTick(() => {\n        this.loadBalancer.exitIdle();\n      });\n      this.calledExitIdle = true;\n    }\n    return {\n      pickResultType: PickResultType.QUEUE,\n      subchannel: null,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null,\n    };\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAkBA,MAAA;AACA,MAAA;AAIA,IAAY;AAAZ,CAAA,SAAY,cAAc;IACxB,cAAA,CAAA,cAAA,CAAA,WAAA,GAAA,EAAA,GAAA;IACA,cAAA,CAAA,cAAA,CAAA,QAAA,GAAA,EAAA,GAAA;IACA,cAAA,CAAA,cAAA,CAAA,oBAAA,GAAA,EAAA,GAAA;IACA,cAAA,CAAA,cAAA,CAAA,OAAA,GAAA,EAAA,GAAA;AACF,CAAC,EALW,kBAAc,CAAA,QAAA,cAAA,GAAd,iBAAc,CAAA,CAAA;AAsE1B;;;IAIA,MAAa;IAEX,YAAY,MAA8B,CAAA;QACxC,IAAI,CAAC,MAAM,GAAA,OAAA,MAAA,CAAA;YACT,MAAM,YAAA,MAAM,CAAC,WAAW;YACxB,SAAS;YACT,UAAU,IAAI,WAAA,QAAQ;QAAE,GACrB;IAEP;IACA,KAAK,QAAkB,EAAA;QACrB,OAAO;YACL,gBAAgB,eAAe,iBAAiB;YAChD,YAAY;YACZ,QAAQ,IAAI,CAAC,MAAM;YACnB,eAAe;YACf,aAAa;;IAEjB;;AAlBF,QAAA,iBAAA,GAAA;AAqBA;;;;;;IAOA,MAAa;IAEX,uFAAuF;IACvF,YAAoB,YAA0B,CAAA;QAA1B,IAAA,CAAA,YAAY,GAAZ;QAFZ,IAAA,CAAA,cAAc,GAAG;IAEwB;IAEjD,KAAK,QAAkB,EAAA;QACrB,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACxB,QAAQ,QAAQ,CAAC;gBACf,IAAI,CAAC,YAAY,CAAC,QAAQ;YAC5B;YACA,IAAI,CAAC,cAAc,GAAG;QACxB;QACA,OAAO;YACL,gBAAgB,eAAe,KAAK;YACpC,YAAY;YACZ,QAAQ;YACR,eAAe;YACf,aAAa;;IAEjB;;AAnBF,QAAA,WAAA,GAAA"}},
    {"offset": {"line": 1605, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1609, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/backoff-timeout.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nexport interface BackoffOptions {\n  initialDelay?: number;\n  multiplier?: number;\n  jitter?: number;\n  maxDelay?: number;\n}\n\nexport class BackoffTimeout {\n  /**\n   * The delay time at the start, and after each reset.\n   */\n  private readonly initialDelay: number = INITIAL_BACKOFF_MS;\n  /**\n   * The exponential backoff multiplier.\n   */\n  private readonly multiplier: number = BACKOFF_MULTIPLIER;\n  /**\n   * The maximum delay time\n   */\n  private readonly maxDelay: number = MAX_BACKOFF_MS;\n  /**\n   * The maximum fraction by which the delay time can randomly vary after\n   * applying the multiplier.\n   */\n  private readonly jitter: number = BACKOFF_JITTER;\n  /**\n   * The delay time for the next time the timer runs.\n   */\n  private nextDelay: number;\n  /**\n   * The handle of the underlying timer. If running is false, this value refers\n   * to an object representing a timer that has ended, but it can still be\n   * interacted with without error.\n   */\n  private timerId: NodeJS.Timeout;\n  /**\n   * Indicates whether the timer is currently running.\n   */\n  private running = false;\n  /**\n   * Indicates whether the timer should keep the Node process running if no\n   * other async operation is doing so.\n   */\n  private hasRef = true;\n  /**\n   * The time that the currently running timer was started. Only valid if\n   * running is true.\n   */\n  private startTime: Date = new Date();\n  /**\n   * The approximate time that the currently running timer will end. Only valid\n   * if running is true.\n   */\n  private endTime: Date = new Date();\n\n  constructor(private callback: () => void, options?: BackoffOptions) {\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  private runTimer(delay: number) {\n    this.endTime = this.startTime;\n    this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      this.timerId.unref?.();\n    }\n  }\n\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(\n      this.nextDelay * this.multiplier,\n      this.maxDelay\n    );\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay =\n      nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    this.hasRef = true;\n    this.timerId.ref?.();\n  }\n\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    this.hasRef = false;\n    this.timerId.unref?.();\n  }\n\n  /**\n   * Get the approximate timestamp of when the timer will fire. Only valid if\n   * this.isRunning() is true.\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1769, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/load-balancer-child-handler.ts"],"sourcesContent":["/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  createLoadBalancer,\n} from './load-balancer';\nimport { SubchannelAddress } from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { Picker } from './picker';\nimport { ChannelRef, SubchannelRef } from './channelz';\nimport { SubchannelInterface } from './subchannel-interface';\n\nconst TYPE_NAME = 'child_load_balancer_helper';\n\nexport class ChildLoadBalancerHandler implements LoadBalancer {\n  private currentChild: LoadBalancer | null = null;\n  private pendingChild: LoadBalancer | null = null;\n  private latestConfig: LoadBalancingConfig | null = null;\n\n  private ChildPolicyHelper = class {\n    private child: LoadBalancer | null = null;\n    constructor(private parent: ChildLoadBalancerHandler) {}\n    createSubchannel(\n      subchannelAddress: SubchannelAddress,\n      subchannelArgs: ChannelOptions\n    ): SubchannelInterface {\n      return this.parent.channelControlHelper.createSubchannel(\n        subchannelAddress,\n        subchannelArgs\n      );\n    }\n    updateState(connectivityState: ConnectivityState, picker: Picker): void {\n      if (this.calledByPendingChild()) {\n        if (connectivityState === ConnectivityState.CONNECTING) {\n          return;\n        }\n        this.parent.currentChild?.destroy();\n        this.parent.currentChild = this.parent.pendingChild;\n        this.parent.pendingChild = null;\n      } else if (!this.calledByCurrentChild()) {\n        return;\n      }\n      this.parent.channelControlHelper.updateState(connectivityState, picker);\n    }\n    requestReresolution(): void {\n      const latestChild = this.parent.pendingChild ?? this.parent.currentChild;\n      if (this.child === latestChild) {\n        this.parent.channelControlHelper.requestReresolution();\n      }\n    }\n    setChild(newChild: LoadBalancer) {\n      this.child = newChild;\n    }\n    addChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.addChannelzChild(child);\n    }\n    removeChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.removeChannelzChild(child);\n    }\n\n    private calledByPendingChild(): boolean {\n      return this.child === this.parent.pendingChild;\n    }\n    private calledByCurrentChild(): boolean {\n      return this.child === this.parent.currentChild;\n    }\n  };\n\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {}\n\n  protected configUpdateRequiresNewPolicyInstance(\n    oldConfig: LoadBalancingConfig,\n    newConfig: LoadBalancingConfig\n  ): boolean {\n    return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\n  }\n\n  /**\n   * Prerequisites: lbConfig !== null and lbConfig.name is registered\n   * @param addressList\n   * @param lbConfig\n   * @param attributes\n   */\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig,\n    attributes: { [key: string]: unknown }\n  ): void {\n    let childToUpdate: LoadBalancer;\n    if (\n      this.currentChild === null ||\n      this.latestConfig === null ||\n      this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)\n    ) {\n      const newHelper = new this.ChildPolicyHelper(this);\n      const newChild = createLoadBalancer(lbConfig, newHelper)!;\n      newHelper.setChild(newChild);\n      if (this.currentChild === null) {\n        this.currentChild = newChild;\n        childToUpdate = this.currentChild;\n      } else {\n        if (this.pendingChild) {\n          this.pendingChild.destroy();\n        }\n        this.pendingChild = newChild;\n        childToUpdate = this.pendingChild;\n      }\n    } else {\n      if (this.pendingChild === null) {\n        childToUpdate = this.currentChild;\n      } else {\n        childToUpdate = this.pendingChild;\n      }\n    }\n    this.latestConfig = lbConfig;\n    childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n  }\n  exitIdle(): void {\n    if (this.currentChild) {\n      this.currentChild.exitIdle();\n      if (this.pendingChild) {\n        this.pendingChild.exitIdle();\n      }\n    }\n  }\n  resetBackoff(): void {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n  destroy(): void {\n    /* Note: state updates are only propagated from the child balancer if that\n     * object is equal to this.currentChild or this.pendingChild. Since this\n     * function sets both of those to null, no further state updates will\n     * occur after this function returns. */\n    if (this.currentChild) {\n      this.currentChild.destroy();\n      this.currentChild = null;\n    }\n    if (this.pendingChild) {\n      this.pendingChild.destroy();\n      this.pendingChild = null;\n    }\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1912, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1916, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/resolving-load-balancer.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ChannelControlHelper,\n  LoadBalancer,\n  LoadBalancingConfig,\n  getFirstUsableConfig,\n} from './load-balancer';\nimport {\n  MethodConfig,\n  ServiceConfig,\n  validateServiceConfig,\n} from './service-config';\nimport { ConnectivityState } from './connectivity-state';\nimport { ConfigSelector, createResolver, Resolver } from './resolver';\nimport { ServiceError } from './call';\nimport { Picker, UnavailablePicker, QueuePicker } from './picker';\nimport { BackoffOptions, BackoffTimeout } from './backoff-timeout';\nimport { Status } from './constants';\nimport { StatusObject } from './call-interface';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChildLoadBalancerHandler } from './load-balancer-child-handler';\nimport { ChannelOptions } from './channel-options';\n\nconst TRACER_NAME = 'resolving_load_balancer';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ntype NameMatchLevel = 'EMPTY' | 'SERVICE' | 'SERVICE_AND_METHOD';\n\n/**\n * Name match levels in order from most to least specific. This is the order in\n * which searches will be performed.\n */\nconst NAME_MATCH_LEVEL_ORDER: NameMatchLevel[] = [\n  'SERVICE_AND_METHOD',\n  'SERVICE',\n  'EMPTY',\n];\n\nfunction hasMatchingName(\n  service: string,\n  method: string,\n  methodConfig: MethodConfig,\n  matchLevel: NameMatchLevel\n): boolean {\n  for (const name of methodConfig.name) {\n    switch (matchLevel) {\n      case 'EMPTY':\n        if (!name.service && !name.method) {\n          return true;\n        }\n        break;\n      case 'SERVICE':\n        if (name.service === service && !name.method) {\n          return true;\n        }\n        break;\n      case 'SERVICE_AND_METHOD':\n        if (name.service === service && name.method === method) {\n          return true;\n        }\n    }\n  }\n  return false;\n}\n\nfunction findMatchingConfig(\n  service: string,\n  method: string,\n  methodConfigs: MethodConfig[],\n  matchLevel: NameMatchLevel\n): MethodConfig | null {\n  for (const config of methodConfigs) {\n    if (hasMatchingName(service, method, config, matchLevel)) {\n      return config;\n    }\n  }\n  return null;\n}\n\nfunction getDefaultConfigSelector(\n  serviceConfig: ServiceConfig | null\n): ConfigSelector {\n  return function defaultConfigSelector(\n    methodName: string,\n    metadata: Metadata\n  ) {\n    const splitName = methodName.split('/').filter(x => x.length > 0);\n    const service = splitName[0] ?? '';\n    const method = splitName[1] ?? '';\n    if (serviceConfig && serviceConfig.methodConfig) {\n      /* Check for the following in order, and return the first method\n       * config that matches:\n       * 1. A name that exactly matches the service and method\n       * 2. A name with no method set that matches the service\n       * 3. An empty name\n       */\n      for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {\n        const matchingConfig = findMatchingConfig(\n          service,\n          method,\n          serviceConfig.methodConfig,\n          matchLevel\n        );\n        if (matchingConfig) {\n          return {\n            methodConfig: matchingConfig,\n            pickInformation: {},\n            status: Status.OK,\n            dynamicFilterFactories: [],\n          };\n        }\n      }\n    }\n    return {\n      methodConfig: { name: [] },\n      pickInformation: {},\n      status: Status.OK,\n      dynamicFilterFactories: [],\n    };\n  };\n}\n\nexport interface ResolutionCallback {\n  (serviceConfig: ServiceConfig, configSelector: ConfigSelector): void;\n}\n\nexport interface ResolutionFailureCallback {\n  (status: StatusObject): void;\n}\n\nexport class ResolvingLoadBalancer implements LoadBalancer {\n  /**\n   * The resolver class constructed for the target address.\n   */\n  private readonly innerResolver: Resolver;\n\n  private readonly childLoadBalancer: ChildLoadBalancerHandler;\n  private latestChildState: ConnectivityState = ConnectivityState.IDLE;\n  private latestChildPicker: Picker = new QueuePicker(this);\n  /**\n   * This resolving load balancer's current connectivity state.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  private readonly defaultServiceConfig: ServiceConfig;\n  /**\n   * The service config object from the last successful resolution, if\n   * available. A value of null indicates that we have not yet received a valid\n   * service config from the resolver.\n   */\n  private previousServiceConfig: ServiceConfig | null = null;\n\n  /**\n   * The backoff timer for handling name resolution failures.\n   */\n  private readonly backoffTimeout: BackoffTimeout;\n\n  /**\n   * Indicates whether we should attempt to resolve again after the backoff\n   * timer runs out.\n   */\n  private continueResolving = false;\n\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(\n    private readonly target: GrpcUri,\n    private readonly channelControlHelper: ChannelControlHelper,\n    channelOptions: ChannelOptions,\n    private readonly onSuccessfulResolution: ResolutionCallback,\n    private readonly onFailedResolution: ResolutionFailureCallback\n  ) {\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = validateServiceConfig(\n        JSON.parse(channelOptions['grpc.service_config']!)\n      );\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n      };\n    }\n    this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    this.childLoadBalancer = new ChildLoadBalancerHandler({\n      createSubchannel:\n        channelControlHelper.createSubchannel.bind(channelControlHelper),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          trace('requestReresolution delayed by backoff timer until ' + this.backoffTimeout.getEndTime().toISOString());\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState: ConnectivityState, picker: Picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      },\n      addChannelzChild:\n        channelControlHelper.addChannelzChild.bind(channelControlHelper),\n      removeChannelzChild:\n        channelControlHelper.removeChannelzChild.bind(channelControlHelper),\n    });\n    this.innerResolver = createResolver(\n      target,\n      {\n        onSuccessfulResolution: (\n          addressList: SubchannelAddress[],\n          serviceConfig: ServiceConfig | null,\n          serviceConfigError: ServiceError | null,\n          configSelector: ConfigSelector | null,\n          attributes: { [key: string]: unknown }\n        ) => {\n          this.backoffTimeout.stop();\n          this.backoffTimeout.reset();\n          let workingServiceConfig: ServiceConfig | null = null;\n          /* This first group of conditionals implements the algorithm described\n           * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n           * in the section called \"Behavior on receiving a new gRPC Config\".\n           */\n          if (serviceConfig === null) {\n            // Step 4 and 5\n            if (serviceConfigError === null) {\n              // Step 5\n              this.previousServiceConfig = null;\n              workingServiceConfig = this.defaultServiceConfig;\n            } else {\n              // Step 4\n              if (this.previousServiceConfig === null) {\n                // Step 4.ii\n                this.handleResolutionFailure(serviceConfigError);\n              } else {\n                // Step 4.i\n                workingServiceConfig = this.previousServiceConfig;\n              }\n            }\n          } else {\n            // Step 3\n            workingServiceConfig = serviceConfig;\n            this.previousServiceConfig = serviceConfig;\n          }\n          const workingConfigList =\n            workingServiceConfig?.loadBalancingConfig ?? [];\n          const loadBalancingConfig = getFirstUsableConfig(\n            workingConfigList,\n            true\n          );\n          if (loadBalancingConfig === null) {\n            // There were load balancing configs but none are supported. This counts as a resolution failure\n            this.handleResolutionFailure({\n              code: Status.UNAVAILABLE,\n              details:\n                'All load balancer options in service config are not compatible',\n              metadata: new Metadata(),\n            });\n            return;\n          }\n          this.childLoadBalancer.updateAddressList(\n            addressList,\n            loadBalancingConfig,\n            attributes\n          );\n          const finalServiceConfig =\n            workingServiceConfig ?? this.defaultServiceConfig;\n          this.onSuccessfulResolution(\n            finalServiceConfig,\n            configSelector ?? getDefaultConfigSelector(finalServiceConfig)\n          );\n        },\n        onError: (error: StatusObject) => {\n          this.handleResolutionFailure(error);\n        },\n      },\n      channelOptions\n    );\n    const backoffOptions: BackoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n  }\n\n  private updateResolution() {\n    this.innerResolver.updateResolution();\n    if (this.currentState === ConnectivityState.IDLE) {\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    }\n    this.backoffTimeout.runOnce();\n  }\n\n  private updateState(connectivityState: ConnectivityState, picker: Picker) {\n    trace(\n      uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[connectivityState]\n    );\n    // Ensure that this.exitIdle() is called by the picker\n    if (connectivityState === ConnectivityState.IDLE) {\n      picker = new QueuePicker(this);\n    }\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n\n  private handleResolutionFailure(error: StatusObject) {\n    if (this.latestChildState === ConnectivityState.IDLE) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker(error)\n      );\n      this.onFailedResolution(error);\n    }\n  }\n\n  exitIdle() {\n    if (\n      this.currentState === ConnectivityState.IDLE ||\n      this.currentState === ConnectivityState.TRANSIENT_FAILURE\n    ) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n    }\n    this.childLoadBalancer.exitIdle();\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig | null\n  ): never {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.backoffTimeout.reset();\n    this.backoffTimeout.stop();\n    this.latestChildState = ConnectivityState.IDLE;\n    this.latestChildPicker = new QueuePicker(this);\n    this.currentState = ConnectivityState.IDLE;\n    this.previousServiceConfig = null;\n    this.continueResolving = false;\n  }\n\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2202, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2206, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/channel-options.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CompressionAlgorithms } from './compression-algorithms';\n\n/**\n * An interface that contains options used when initializing a Channel instance.\n */\nexport interface ChannelOptions {\n  'grpc.ssl_target_name_override'?: string;\n  'grpc.primary_user_agent'?: string;\n  'grpc.secondary_user_agent'?: string;\n  'grpc.default_authority'?: string;\n  'grpc.keepalive_time_ms'?: number;\n  'grpc.keepalive_timeout_ms'?: number;\n  'grpc.keepalive_permit_without_calls'?: number;\n  'grpc.service_config'?: string;\n  'grpc.max_concurrent_streams'?: number;\n  'grpc.initial_reconnect_backoff_ms'?: number;\n  'grpc.max_reconnect_backoff_ms'?: number;\n  'grpc.use_local_subchannel_pool'?: number;\n  'grpc.max_send_message_length'?: number;\n  'grpc.max_receive_message_length'?: number;\n  'grpc.enable_http_proxy'?: number;\n  /* http_connect_target and http_connect_creds are used for passing data\n   * around internally, and should not be documented as public-facing options\n   */\n  'grpc.http_connect_target'?: string;\n  'grpc.http_connect_creds'?: string;\n  'grpc.default_compression_algorithm'?: CompressionAlgorithms;\n  'grpc.enable_channelz'?: number;\n  'grpc.dns_min_time_between_resolutions_ms'?: number;\n  'grpc.enable_retries'?: number;\n  'grpc.per_rpc_retry_buffer_size'?: number;\n  /* This option is pattered like a core option, but the core does not have\n   * this option. It is closely related to the option\n   * grpc.per_rpc_retry_buffer_size, which is in the core. The core will likely\n   * implement this functionality using the ResourceQuota mechanism, so there\n   * will probably not be any collision or other inconsistency. */\n  'grpc.retry_buffer_size'?: number;\n  'grpc.max_connection_age_ms'?: number;\n  'grpc.max_connection_age_grace_ms'?: number;\n  'grpc-node.max_session_memory'?: number;\n  'grpc.service_config_disable_resolution'?: number;\n  'grpc.client_idle_timeout_ms'?: number;\n  /**\n   * Set the enableTrace option in TLS clients and servers\n   */\n  'grpc-node.tls_enable_trace'?: number;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */\nexport const recognizedOptions = {\n  'grpc.ssl_target_name_override': true,\n  'grpc.primary_user_agent': true,\n  'grpc.secondary_user_agent': true,\n  'grpc.default_authority': true,\n  'grpc.keepalive_time_ms': true,\n  'grpc.keepalive_timeout_ms': true,\n  'grpc.keepalive_permit_without_calls': true,\n  'grpc.service_config': true,\n  'grpc.max_concurrent_streams': true,\n  'grpc.initial_reconnect_backoff_ms': true,\n  'grpc.max_reconnect_backoff_ms': true,\n  'grpc.use_local_subchannel_pool': true,\n  'grpc.max_send_message_length': true,\n  'grpc.max_receive_message_length': true,\n  'grpc.enable_http_proxy': true,\n  'grpc.enable_channelz': true,\n  'grpc.dns_min_time_between_resolutions_ms': true,\n  'grpc.enable_retries': true,\n  'grpc.per_rpc_retry_buffer_size': true,\n  'grpc.retry_buffer_size': true,\n  'grpc.max_connection_age_ms': true,\n  'grpc.max_connection_age_grace_ms': true,\n  'grpc-node.max_session_memory': true,\n  'grpc.service_config_disable_resolution': true,\n  'grpc.client_idle_timeout_ms': true,\n  'grpc-node.tls_enable_trace': true,\n};\n\nexport function channelOptionsEqual(\n  options1: ChannelOptions,\n  options2: ChannelOptions\n) {\n  const keys1 = Object.keys(options1).sort();\n  const keys2 = Object.keys(options2).sort();\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n  for (let i = 0; i < keys1.length; i += 1) {\n    if (keys1[i] !== keys2[i]) {\n      return false;\n    }\n    if (options1[keys1[i]] !== options2[keys2[i]]) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAmEA;;;IAIa,QAAA,iBAAiB,GAAG;IAC/B,iCAAiC;IACjC,2BAA2B;IAC3B,6BAA6B;IAC7B,0BAA0B;IAC1B,0BAA0B;IAC1B,6BAA6B;IAC7B,uCAAuC;IACvC,uBAAuB;IACvB,+BAA+B;IAC/B,qCAAqC;IACrC,iCAAiC;IACjC,kCAAkC;IAClC,gCAAgC;IAChC,mCAAmC;IACnC,0BAA0B;IAC1B,wBAAwB;IACxB,4CAA4C;IAC5C,uBAAuB;IACvB,kCAAkC;IAClC,0BAA0B;IAC1B,8BAA8B;IAC9B,oCAAoC;IACpC,gCAAgC;IAChC,0CAA0C;IAC1C,+BAA+B;IAC/B,8BAA8B;;AAGhC,SAAgB,oBACd,QAAwB,EACxB,QAAwB;IAExB,MAAM,QAAQ,OAAO,IAAI,CAAC,UAAU,IAAI;IACxC,MAAM,QAAQ,OAAO,IAAI,CAAC,UAAU,IAAI;IACxC,IAAI,MAAM,MAAM,KAAK,MAAM,MAAM,EAAE;QACjC,OAAO;IACT;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;QACxC,IAAI,KAAK,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE,EAAE;YACzB,OAAO;QACT;QACA,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;YAC7C,OAAO;QACT;IACF;IACA,OAAO;AACT;AAlBA,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 2274, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2278, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/subchannel-address.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIP } from 'net';\n\nexport interface TcpSubchannelAddress {\n  port: number;\n  host: string;\n}\n\nexport interface IpcSubchannelAddress {\n  path: string;\n}\n/**\n * This represents a single backend address to connect to. This interface is a\n * subset of net.SocketConnectOpts, i.e. the options described at\n * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener.\n * Those are in turn a subset of the options that can be passed to http2.connect.\n */\n\nexport type SubchannelAddress = TcpSubchannelAddress | IpcSubchannelAddress;\n\nexport function isTcpSubchannelAddress(\n  address: SubchannelAddress\n): address is TcpSubchannelAddress {\n  return 'port' in address;\n}\n\nexport function subchannelAddressEqual(\n  address1?: SubchannelAddress,\n  address2?: SubchannelAddress\n): boolean {\n  if (!address1 && !address2) {\n    return true;\n  }\n  if (!address1 || !address2) {\n    return false;\n  }\n  if (isTcpSubchannelAddress(address1)) {\n    return (\n      isTcpSubchannelAddress(address2) &&\n      address1.host === address2.host &&\n      address1.port === address2.port\n    );\n  } else {\n    return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n  }\n}\n\nexport function subchannelAddressToString(address: SubchannelAddress): string {\n  if (isTcpSubchannelAddress(address)) {\n    return address.host + ':' + address.port;\n  } else {\n    return address.path;\n  }\n}\n\nconst DEFAULT_PORT = 443;\n\nexport function stringToSubchannelAddress(\n  addressString: string,\n  port?: number\n): SubchannelAddress {\n  if (isIP(addressString)) {\n    return {\n      host: addressString,\n      port: port ?? DEFAULT_PORT,\n    };\n  } else {\n    return {\n      path: addressString,\n    };\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,MAAA;AAmBA,SAAgB,uBACd,OAA0B;IAE1B,OAAO,UAAU;AACnB;AAJA,QAAA,sBAAA,GAAA;AAMA,SAAgB,uBACd,QAA4B,EAC5B,QAA4B;IAE5B,IAAI,CAAC,YAAY,CAAC,UAAU;QAC1B,OAAO;IACT;IACA,IAAI,CAAC,YAAY,CAAC,UAAU;QAC1B,OAAO;IACT;IACA,IAAI,uBAAuB,WAAW;QACpC,OACE,uBAAuB,aACvB,SAAS,IAAI,KAAK,SAAS,IAAI,IAC/B,SAAS,IAAI,KAAK,SAAS,IAAI;IAEnC,OAAO;QACL,OAAO,CAAC,uBAAuB,aAAa,SAAS,IAAI,KAAK,SAAS,IAAI;IAC7E;AACF;AAnBA,QAAA,sBAAA,GAAA;AAqBA,SAAgB,0BAA0B,OAA0B;IAClE,IAAI,uBAAuB,UAAU;QACnC,OAAO,QAAQ,IAAI,GAAG,MAAM,QAAQ,IAAI;IAC1C,OAAO;QACL,OAAO,QAAQ,IAAI;IACrB;AACF;AANA,QAAA,yBAAA,GAAA;AAQA,MAAM,eAAe;AAErB,SAAgB,0BACd,aAAqB,EACrB,IAAa;IAEb,IAAI,CAAA,GAAA,MAAA,IAAI,EAAC,gBAAgB;QACvB,OAAO;YACL,MAAM;YACN,MAAM,SAAI,QAAJ,SAAI,KAAA,IAAJ,OAAQ;;IAElB,OAAO;QACL,OAAO;YACL,MAAM;;IAEV;AACF;AAdA,QAAA,yBAAA,GAAA"}},
    {"offset": {"line": 2339, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2343, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/admin.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ServiceDefinition } from './make-client';\nimport { Server, UntypedServiceImplementation } from './server';\n\ninterface GetServiceDefinition {\n  (): ServiceDefinition;\n}\n\ninterface GetHandlers {\n  (): UntypedServiceImplementation;\n}\n\nconst registeredAdminServices: {\n  getServiceDefinition: GetServiceDefinition;\n  getHandlers: GetHandlers;\n}[] = [];\n\nexport function registerAdminService(\n  getServiceDefinition: GetServiceDefinition,\n  getHandlers: GetHandlers\n) {\n  registeredAdminServices.push({ getServiceDefinition, getHandlers });\n}\n\nexport function addAdminServicesToServer(server: Server): void {\n  for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\n    server.addService(getServiceDefinition(), getHandlers());\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AA4BA,MAAM,0BAGA,EAAE;AAER,SAAgB,qBACd,oBAA0C,EAC1C,WAAwB;IAExB,wBAAwB,IAAI,CAAC;QAAE;QAAsB;IAAW;AAClE;AALA,QAAA,oBAAA,GAAA;AAOA,SAAgB,yBAAyB,MAAc;IACrD,KAAK,MAAM,EAAE,oBAAoB,EAAE,WAAW,EAAE,IAAI,wBAAyB;QAC3E,OAAO,UAAU,CAAC,wBAAwB;IAC5C;AACF;AAJA,QAAA,wBAAA,GAAA"}},
    {"offset": {"line": 2377, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2381, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { EventEmitter } from 'events';\nimport { Duplex, Readable, Writable } from 'stream';\n\nimport { StatusObject, MessageContext } from './call-interface';\nimport { Status } from './constants';\nimport { EmitterAugmentation1 } from './events';\nimport { Metadata } from './metadata';\nimport { ObjectReadable, ObjectWritable, WriteCallback } from './object-stream';\nimport { InterceptingCallInterface } from './client-interceptors';\n\n/**\n * A type extending the built-in Error object with additional fields.\n */\nexport type ServiceError = StatusObject & Error;\n\n/**\n * A base type for all user-facing values returned by client-side method calls.\n */\nexport type SurfaceCall = {\n  call?: InterceptingCallInterface;\n  cancel(): void;\n  getPeer(): string;\n} & EmitterAugmentation1<'metadata', Metadata> &\n  EmitterAugmentation1<'status', StatusObject> &\n  EventEmitter;\n\n/**\n * A type representing the return value of a unary method call.\n */\nexport type ClientUnaryCall = SurfaceCall;\n\n/**\n * A type representing the return value of a server stream method call.\n */\nexport type ClientReadableStream<ResponseType> = {\n  deserialize: (chunk: Buffer) => ResponseType;\n} & SurfaceCall &\n  ObjectReadable<ResponseType>;\n\n/**\n * A type representing the return value of a client stream method call.\n */\nexport type ClientWritableStream<RequestType> = {\n  serialize: (value: RequestType) => Buffer;\n} & SurfaceCall &\n  ObjectWritable<RequestType>;\n\n/**\n * A type representing the return value of a bidirectional stream method call.\n */\nexport type ClientDuplexStream<RequestType, ResponseType> =\n  ClientWritableStream<RequestType> & ClientReadableStream<ResponseType>;\n\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nexport function callErrorFromStatus(\n  status: StatusObject,\n  callerStack: string\n): ServiceError {\n  const message = `${status.code} ${Status[status.code]}: ${status.details}`;\n  const error = new Error(message);\n  const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n  return Object.assign(new Error(message), status, { stack });\n}\n\nexport class ClientUnaryCallImpl\n  extends EventEmitter\n  implements ClientUnaryCall\n{\n  public call?: InterceptingCallInterface;\n  constructor() {\n    super();\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n}\n\nexport class ClientReadableStreamImpl<ResponseType>\n  extends Readable\n  implements ClientReadableStream<ResponseType>\n{\n  public call?: InterceptingCallInterface;\n  constructor(readonly deserialize: (chunk: Buffer) => ResponseType) {\n    super({ objectMode: true });\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n\n  _read(_size: number): void {\n    this.call?.startRead();\n  }\n}\n\nexport class ClientWritableStreamImpl<RequestType>\n  extends Writable\n  implements ClientWritableStream<RequestType>\n{\n  public call?: InterceptingCallInterface;\n  constructor(readonly serialize: (value: RequestType) => Buffer) {\n    super({ objectMode: true });\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n\n  _write(chunk: RequestType, encoding: string, cb: WriteCallback) {\n    const context: MessageContext = {\n      callback: cb,\n    };\n    const flags = Number(encoding);\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n    this.call?.sendMessageWithContext(context, chunk);\n  }\n\n  _final(cb: Function) {\n    this.call?.halfClose();\n    cb();\n  }\n}\n\nexport class ClientDuplexStreamImpl<RequestType, ResponseType>\n  extends Duplex\n  implements ClientDuplexStream<RequestType, ResponseType>\n{\n  public call?: InterceptingCallInterface;\n  constructor(\n    readonly serialize: (value: RequestType) => Buffer,\n    readonly deserialize: (chunk: Buffer) => ResponseType\n  ) {\n    super({ objectMode: true });\n  }\n\n  cancel(): void {\n    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer(): string {\n    return this.call?.getPeer() ?? 'unknown';\n  }\n\n  _read(_size: number): void {\n    this.call?.startRead();\n  }\n\n  _write(chunk: RequestType, encoding: string, cb: WriteCallback) {\n    const context: MessageContext = {\n      callback: cb,\n    };\n    const flags = Number(encoding);\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n    this.call?.sendMessageWithContext(context, chunk);\n  }\n\n  _final(cb: Function) {\n    this.call?.halfClose();\n    cb();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2524, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2528, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/call-interface.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from './call-credentials';\nimport { Status } from './constants';\nimport { Deadline } from './deadline';\nimport { Metadata } from './metadata';\nimport { ServerSurfaceCall } from './server-call';\n\nexport interface CallStreamOptions {\n  deadline: Deadline;\n  flags: number;\n  host: string;\n  parentCall: ServerSurfaceCall | null;\n}\n\nexport type PartialCallStreamOptions = Partial<CallStreamOptions>;\n\nexport interface StatusObject {\n  code: Status;\n  details: string;\n  metadata: Metadata;\n}\n\nexport type PartialStatusObject = Pick<StatusObject, 'code' | 'details'> & {\n  metadata: Metadata | null;\n};\n\nexport const enum WriteFlags {\n  BufferHint = 1,\n  NoCompress = 2,\n  WriteThrough = 4,\n}\n\nexport interface WriteObject {\n  message: Buffer;\n  flags?: number;\n}\n\nexport interface MetadataListener {\n  (metadata: Metadata, next: (metadata: Metadata) => void): void;\n}\n\nexport interface MessageListener {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface StatusListener {\n  (status: StatusObject, next: (status: StatusObject) => void): void;\n}\n\nexport interface FullListener {\n  onReceiveMetadata: MetadataListener;\n  onReceiveMessage: MessageListener;\n  onReceiveStatus: StatusListener;\n}\n\nexport type Listener = Partial<FullListener>;\n\n/**\n * An object with methods for handling the responses to a call.\n */\nexport interface InterceptingListener {\n  onReceiveMetadata(metadata: Metadata): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onReceiveMessage(message: any): void;\n  onReceiveStatus(status: StatusObject): void;\n}\n\nexport function isInterceptingListener(\n  listener: Listener | InterceptingListener\n): listener is InterceptingListener {\n  return (\n    listener.onReceiveMetadata !== undefined &&\n    listener.onReceiveMetadata.length === 1\n  );\n}\n\nexport class InterceptingListenerImpl implements InterceptingListener {\n  private processingMetadata = false;\n  private hasPendingMessage = false;\n  private pendingMessage: any;\n  private processingMessage = false;\n  private pendingStatus: StatusObject | null = null;\n  constructor(\n    private listener: FullListener,\n    private nextListener: InterceptingListener\n  ) {}\n\n  private processPendingMessage() {\n    if (this.hasPendingMessage) {\n      this.nextListener.onReceiveMessage(this.pendingMessage);\n      this.pendingMessage = null;\n      this.hasPendingMessage = false;\n    }\n  }\n\n  private processPendingStatus() {\n    if (this.pendingStatus) {\n      this.nextListener.onReceiveStatus(this.pendingStatus);\n    }\n  }\n\n  onReceiveMetadata(metadata: Metadata): void {\n    this.processingMetadata = true;\n    this.listener.onReceiveMetadata(metadata, metadata => {\n      this.processingMetadata = false;\n      this.nextListener.onReceiveMetadata(metadata);\n      this.processPendingMessage();\n      this.processPendingStatus();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onReceiveMessage(message: any): void {\n    /* If this listener processes messages asynchronously, the last message may\n     * be reordered with respect to the status */\n    this.processingMessage = true;\n    this.listener.onReceiveMessage(message, msg => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessage = msg;\n        this.hasPendingMessage = true;\n      } else {\n        this.nextListener.onReceiveMessage(msg);\n        this.processPendingStatus();\n      }\n    });\n  }\n  onReceiveStatus(status: StatusObject): void {\n    this.listener.onReceiveStatus(status, processedStatus => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingStatus = processedStatus;\n      } else {\n        this.nextListener.onReceiveStatus(processedStatus);\n      }\n    });\n  }\n}\n\nexport interface WriteCallback {\n  (error?: Error | null): void;\n}\n\nexport interface MessageContext {\n  callback?: WriteCallback;\n  flags?: number;\n}\n\nexport interface Call {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener: InterceptingListener): void;\n  sendMessageWithContext(context: MessageContext, message: Buffer): void;\n  startRead(): void;\n  halfClose(): void;\n  getCallNumber(): number;\n  setCredentials(credentials: CallCredentials): void;\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAoFA,SAAgB,uBACd,QAAyC;IAEzC,OACE,SAAS,iBAAiB,KAAK,aAC/B,SAAS,iBAAiB,CAAC,MAAM,KAAK;AAE1C;AAPA,QAAA,sBAAA,GAAA;AASA,MAAa;IAMX,YACU,QAAsB,EACtB,YAAkC,CAAA;QADlC,IAAA,CAAA,QAAQ,GAAR;QACA,IAAA,CAAA,YAAY,GAAZ;QAPF,IAAA,CAAA,kBAAkB,GAAG;QACrB,IAAA,CAAA,iBAAiB,GAAG;QAEpB,IAAA,CAAA,iBAAiB,GAAG;QACpB,IAAA,CAAA,aAAa,GAAwB;IAI1C;IAEK,wBAAqB;QAC3B,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc;YACtD,IAAI,CAAC,cAAc,GAAG;YACtB,IAAI,CAAC,iBAAiB,GAAG;QAC3B;IACF;IAEQ,uBAAoB;QAC1B,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,IAAI,CAAC,aAAa;QACtD;IACF;IAEA,kBAAkB,QAAkB,EAAA;QAClC,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,UAAU,CAAA;YACxC,IAAI,CAAC,kBAAkB,GAAG;YAC1B,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC;YACpC,IAAI,CAAC,qBAAqB;YAC1B,IAAI,CAAC,oBAAoB;QAC3B;IACF;IACA,8DAA8D;IAC9D,iBAAiB,OAAY,EAAA;QAC3B;sDAEA,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,SAAS,CAAA;YACtC,IAAI,CAAC,iBAAiB,GAAG;YACzB,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC3B,IAAI,CAAC,cAAc,GAAG;gBACtB,IAAI,CAAC,iBAAiB,GAAG;YAC3B,OAAO;gBACL,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC;gBACnC,IAAI,CAAC,oBAAoB;YAC3B;QACF;IACF;IACA,gBAAgB,MAAoB,EAAA;QAClC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,QAAQ,CAAA;YACpC,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,iBAAiB,EAAE;gBACrD,IAAI,CAAC,aAAa,GAAG;YACvB,OAAO;gBACL,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC;YACpC;QACF;IACF;;AA1DF,QAAA,wBAAA,GAAA"}},
    {"offset": {"line": 2608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2612, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/client-interceptors.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\nimport {\n  StatusObject,\n  Listener,\n  MetadataListener,\n  MessageListener,\n  StatusListener,\n  FullListener,\n  InterceptingListener,\n  InterceptingListenerImpl,\n  isInterceptingListener,\n  MessageContext,\n  Call,\n} from './call-interface';\nimport { Status } from './constants';\nimport { Channel } from './channel';\nimport { CallOptions } from './client';\nimport { ClientMethodDefinition } from './make-client';\nimport { getErrorMessage } from './error';\n\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nexport class InterceptorConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\n\nexport interface MetadataRequester {\n  (\n    metadata: Metadata,\n    listener: InterceptingListener,\n    next: (\n      metadata: Metadata,\n      listener: InterceptingListener | Listener\n    ) => void\n  ): void;\n}\n\nexport interface MessageRequester {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface CloseRequester {\n  (next: () => void): void;\n}\n\nexport interface CancelRequester {\n  (next: () => void): void;\n}\n\n/**\n * An object with methods for intercepting and modifying outgoing call operations.\n */\nexport interface FullRequester {\n  start: MetadataRequester;\n  sendMessage: MessageRequester;\n  halfClose: CloseRequester;\n  cancel: CancelRequester;\n}\n\nexport type Requester = Partial<FullRequester>;\n\nexport class ListenerBuilder {\n  private metadata: MetadataListener | undefined = undefined;\n  private message: MessageListener | undefined = undefined;\n  private status: StatusListener | undefined = undefined;\n\n  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage: MessageListener): this {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus: StatusListener): this {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build(): Listener {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status,\n    };\n  }\n}\n\nexport class RequesterBuilder {\n  private start: MetadataRequester | undefined = undefined;\n  private message: MessageRequester | undefined = undefined;\n  private halfClose: CloseRequester | undefined = undefined;\n  private cancel: CancelRequester | undefined = undefined;\n\n  withStart(start: MetadataRequester): this {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage: MessageRequester): this {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose: CloseRequester): this {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel: CancelRequester): this {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build(): Requester {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel,\n    };\n  }\n}\n\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener: FullListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  },\n};\n\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester: FullRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  },\n};\n\nexport interface InterceptorOptions extends CallOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  method_definition: ClientMethodDefinition<any, any>;\n}\n\nexport interface InterceptingCallInterface {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void;\n  startRead(): void;\n  halfClose(): void;\n}\n\nexport class InterceptingCall implements InterceptingCallInterface {\n  /**\n   * The requester that this InterceptingCall uses to modify outgoing operations\n   */\n  private requester: FullRequester;\n  /**\n   * Indicates that metadata has been passed to the requester's start\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMetadata = false;\n  /**\n   * Message context for a pending message that is waiting for\n   */\n  private pendingMessageContext: MessageContext | null = null;\n  private pendingMessage: any;\n  /**\n   * Indicates that a message has been passed to the requester's sendMessage\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMessage = false;\n  /**\n   * Indicates that a status was received but could not be propagated because\n   * a message was still being processed.\n   */\n  private pendingHalfClose = false;\n  constructor(\n    private nextCall: InterceptingCallInterface,\n    requester?: Requester\n  ) {\n    if (requester) {\n      this.requester = {\n        start: requester.start ?? defaultRequester.start,\n        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,\n        halfClose: requester.halfClose ?? defaultRequester.halfClose,\n        cancel: requester.cancel ?? defaultRequester.cancel,\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  private processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(\n        this.pendingMessageContext,\n        this.pendingMessage\n      );\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  private processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    const fullInterceptingListener: InterceptingListener = {\n      onReceiveMetadata:\n        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??\n        (metadata => {}),\n      onReceiveMessage:\n        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??\n        (message => {}),\n      onReceiveStatus:\n        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??\n        (status => {}),\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      this.processingMetadata = false;\n      let finalInterceptingListener: InterceptingListener;\n      if (isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener: FullListener = {\n          onReceiveMetadata:\n            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,\n          onReceiveMessage:\n            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,\n          onReceiveStatus:\n            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,\n        };\n        finalInterceptingListener = new InterceptingListenerImpl(\n          fullListener,\n          fullInterceptingListener\n        );\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead(): void {\n    this.nextCall.startRead();\n  }\n  halfClose(): void {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n}\n\nfunction getCall(channel: Channel, path: string, options: CallOptions): Call {\n  const deadline = options.deadline ?? Infinity;\n  const host = options.host;\n  const parent = options.parent ?? null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall implements InterceptingCallInterface {\n  constructor(\n    protected call: Call,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected methodDefinition: ClientMethodDefinition<any, any>\n  ) {}\n  cancelWithStatus(status: Status, details: string): void {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    let serialized: Buffer;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(\n        Status.INTERNAL,\n        `Request message serialization failure: ${getErrorMessage(e)}`\n      );\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    let readError: StatusObject | null = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        interceptingListener?.onReceiveMetadata?.(metadata);\n      },\n      onReceiveMessage: message => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized: any;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: Status.INTERNAL,\n            details: `Response message parsing error: ${getErrorMessage(e)}`,\n            metadata: new Metadata(),\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        interceptingListener?.onReceiveMessage?.(deserialized);\n      },\n      onReceiveStatus: status => {\n        if (readError) {\n          interceptingListener?.onReceiveStatus?.(readError);\n        } else {\n          interceptingListener?.onReceiveStatus?.(status);\n        }\n      },\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose(): void {\n    this.call.halfClose();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface\n{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) {\n    super(call, methodDefinition);\n  }\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void {\n    let receivedMessage = false;\n    const wrapperListener: InterceptingListener = {\n      onReceiveMetadata:\n        listener?.onReceiveMetadata?.bind(listener) ?? (metadata => {}),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: (message: any) => {\n        receivedMessage = true;\n        listener?.onReceiveMessage?.(message);\n      },\n      onReceiveStatus: (status: StatusObject) => {\n        if (!receivedMessage) {\n          listener?.onReceiveMessage?.(null);\n        }\n        listener?.onReceiveStatus?.(status);\n      },\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {}\n\nfunction getBottomInterceptingCall(\n  channel: Channel,\n  options: InterceptorOptions,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>\n) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nexport interface NextCall {\n  (options: InterceptorOptions): InterceptingCallInterface;\n}\n\nexport interface Interceptor {\n  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;\n}\n\nexport interface InterceptorProvider {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;\n}\n\nexport interface InterceptorArguments {\n  clientInterceptors: Interceptor[];\n  clientInterceptorProviders: InterceptorProvider[];\n  callInterceptors: Interceptor[];\n  callInterceptorProviders: InterceptorProvider[];\n}\n\nexport function getInterceptingCall(\n  interceptorArgs: InterceptorArguments,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>,\n  options: CallOptions,\n  channel: Channel\n): InterceptingCallInterface {\n  if (\n    interceptorArgs.clientInterceptors.length > 0 &&\n    interceptorArgs.clientInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as options ' +\n        'to the client constructor. Only one of these is allowed.'\n    );\n  }\n  if (\n    interceptorArgs.callInterceptors.length > 0 &&\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as call ' +\n        'options. Only one of these is allowed.'\n    );\n  }\n  let interceptors: Interceptor[] = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (\n    interceptorArgs.callInterceptors.length > 0 ||\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.callInterceptors,\n        interceptorArgs.callInterceptorProviders.map(provider =>\n          provider(methodDefinition)\n        )\n      )\n      .filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.clientInterceptors,\n        interceptorArgs.clientInterceptorProviders.map(provider =>\n          provider(methodDefinition)\n        )\n      )\n      .filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition,\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall: NextCall = interceptors.reduceRight<NextCall>(\n    (nextCall: NextCall, nextInterceptor: Interceptor) => {\n      return currentOptions => nextInterceptor(currentOptions, nextCall);\n    },\n    (finalOptions: InterceptorOptions) =>\n      getBottomInterceptingCall(channel, finalOptions, methodDefinition)\n  );\n  return getCall(interceptorOptions);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3008, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3012, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/client.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ClientDuplexStream,\n  ClientDuplexStreamImpl,\n  ClientReadableStream,\n  ClientReadableStreamImpl,\n  ClientUnaryCall,\n  ClientUnaryCallImpl,\n  ClientWritableStream,\n  ClientWritableStreamImpl,\n  ServiceError,\n  callErrorFromStatus,\n  SurfaceCall,\n} from './call';\nimport { CallCredentials } from './call-credentials';\nimport { StatusObject } from './call-interface';\nimport { Channel, ChannelImplementation } from './channel';\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { Status } from './constants';\nimport { Metadata } from './metadata';\nimport { ClientMethodDefinition } from './make-client';\nimport {\n  getInterceptingCall,\n  Interceptor,\n  InterceptorProvider,\n  InterceptorArguments,\n  InterceptingCallInterface,\n} from './client-interceptors';\nimport {\n  ServerUnaryCall,\n  ServerReadableStream,\n  ServerWritableStream,\n  ServerDuplexStream,\n} from './server-call';\nimport { Deadline } from './deadline';\n\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\n\nfunction isFunction<ResponseType>(\n  arg: Metadata | CallOptions | UnaryCallback<ResponseType> | undefined\n): arg is UnaryCallback<ResponseType> {\n  return typeof arg === 'function';\n}\n\nexport interface UnaryCallback<ResponseType> {\n  (err: ServiceError | null, value?: ResponseType): void;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport interface CallOptions {\n  deadline?: Deadline;\n  host?: string;\n  parent?:\n    | ServerUnaryCall<any, any>\n    | ServerReadableStream<any, any>\n    | ServerWritableStream<any, any>\n    | ServerDuplexStream<any, any>;\n  propagate_flags?: number;\n  credentials?: CallCredentials;\n  interceptors?: Interceptor[];\n  interceptor_providers?: InterceptorProvider[];\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport interface CallProperties<RequestType, ResponseType> {\n  argument?: RequestType;\n  metadata: Metadata;\n  call: SurfaceCall;\n  channel: Channel;\n  methodDefinition: ClientMethodDefinition<RequestType, ResponseType>;\n  callOptions: CallOptions;\n  callback?: UnaryCallback<ResponseType>;\n}\n\nexport interface CallInvocationTransformer {\n  (callProperties: CallProperties<any, any>): CallProperties<any, any>; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\nexport type ClientOptions = Partial<ChannelOptions> & {\n  channelOverride?: Channel;\n  channelFactoryOverride?: (\n    address: string,\n    credentials: ChannelCredentials,\n    options: ClientOptions\n  ) => Channel;\n  interceptors?: Interceptor[];\n  interceptor_providers?: InterceptorProvider[];\n  callInvocationTransformer?: CallInvocationTransformer;\n};\n\nfunction getErrorStackString(error: Error): string {\n  return error.stack!.split('\\n').slice(1).join('\\n');\n}\n\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nexport class Client {\n  private readonly [CHANNEL_SYMBOL]: Channel;\n  private readonly [INTERCEPTOR_SYMBOL]: Interceptor[];\n  private readonly [INTERCEPTOR_PROVIDER_SYMBOL]: InterceptorProvider[];\n  private readonly [CALL_INVOCATION_TRANSFORMER_SYMBOL]?: CallInvocationTransformer;\n  constructor(\n    address: string,\n    credentials: ChannelCredentials,\n    options: ClientOptions = {}\n  ) {\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = options.interceptors ?? [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = options.interceptor_providers ?? [];\n    delete options.interceptor_providers;\n    if (\n      this[INTERCEPTOR_SYMBOL].length > 0 &&\n      this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0\n    ) {\n      throw new Error(\n        'Both interceptors and interceptor_providers were passed as options ' +\n          'to the client constructor. Only one of these is allowed.'\n      );\n    }\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n      options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      const channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(\n        address,\n        credentials,\n        options\n      );\n    } else {\n      this[CHANNEL_SYMBOL] = new ChannelImplementation(\n        address,\n        credentials,\n        options\n      );\n    }\n  }\n\n  close(): void {\n    this[CHANNEL_SYMBOL].close();\n  }\n\n  getChannel(): Channel {\n    return this[CHANNEL_SYMBOL];\n  }\n\n  waitForReady(deadline: Deadline, callback: (error?: Error) => void): void {\n    const checkState = (err?: Error) => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n      let newState;\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n      if (newState === ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(\n            newState,\n            deadline,\n            checkState\n          );\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n    setImmediate(checkState);\n  }\n\n  private checkOptionalUnaryResponseArguments<ResponseType>(\n    arg1: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    arg2?: CallOptions | UnaryCallback<ResponseType>,\n    arg3?: UnaryCallback<ResponseType>\n  ): {\n    metadata: Metadata;\n    options: CallOptions;\n    callback: UnaryCallback<ResponseType>;\n  } {\n    if (isFunction(arg1)) {\n      return { metadata: new Metadata(), options: {}, callback: arg1 };\n    } else if (isFunction(arg2)) {\n      if (arg1 instanceof Metadata) {\n        return { metadata: arg1, options: {}, callback: arg2 };\n      } else {\n        return { metadata: new Metadata(), options: arg1, callback: arg2 };\n      }\n    } else {\n      if (\n        !(\n          arg1 instanceof Metadata &&\n          arg2 instanceof Object &&\n          isFunction(arg3)\n        )\n      ) {\n        throw new Error('Incorrect arguments passed');\n      }\n      return { metadata: arg1, options: arg2, callback: arg3 };\n    }\n  }\n\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    options?: CallOptions | UnaryCallback<ResponseType>,\n    callback?: UnaryCallback<ResponseType>\n  ): ClientUnaryCall {\n    const checkedArguments =\n      this.checkOptionalUnaryResponseArguments<ResponseType>(\n        metadata,\n        options,\n        callback\n      );\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: false,\n        responseStream: false,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new ClientUnaryCallImpl(),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const emitter: ClientUnaryCall = callProperties.call;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    let responseMessage: ResponseType | null = null;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(Status.INTERNAL, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError!);\n            callProperties.callback!(\n              callErrorFromStatus(\n                {\n                  code: Status.INTERNAL,\n                  details: 'No message received',\n                  metadata: status.metadata,\n                },\n                callerStack\n              )\n            );\n          } else {\n            callProperties.callback!(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError!);\n          callProperties.callback!(callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        emitter.emit('status', status);\n      },\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return emitter;\n  }\n\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    options?: CallOptions | UnaryCallback<ResponseType>,\n    callback?: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType> {\n    const checkedArguments =\n      this.checkOptionalUnaryResponseArguments<ResponseType>(\n        metadata,\n        options,\n        callback\n      );\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: true,\n        responseStream: false,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      metadata: checkedArguments.metadata,\n      call: new ClientWritableStreamImpl<RequestType>(serialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const emitter: ClientWritableStream<RequestType> =\n      callProperties.call as ClientWritableStream<RequestType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    let responseMessage: ResponseType | null = null;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(Status.INTERNAL, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === Status.OK) {\n          if (responseMessage === null) {\n            const callerStack = getErrorStackString(callerStackError!);\n            callProperties.callback!(\n              callErrorFromStatus(\n                {\n                  code: Status.INTERNAL,\n                  details: 'No message received',\n                  metadata: status.metadata,\n                },\n                callerStack\n              )\n            );\n          } else {\n            callProperties.callback!(null, responseMessage);\n          }\n        } else {\n          const callerStack = getErrorStackString(callerStackError!);\n          callProperties.callback!(callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        emitter.emit('status', status);\n      },\n    });\n    return emitter;\n  }\n\n  private checkMetadataAndOptions(\n    arg1?: Metadata | CallOptions,\n    arg2?: CallOptions\n  ): { metadata: Metadata; options: CallOptions } {\n    let metadata: Metadata;\n    let options: CallOptions;\n    if (arg1 instanceof Metadata) {\n      metadata = arg1;\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n      metadata = new Metadata();\n    }\n    return { metadata, options };\n  }\n\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType>;\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType>;\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata?: Metadata | CallOptions,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType> {\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: false,\n        responseStream: true,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new ClientReadableStreamImpl<ResponseType>(deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const stream: ClientReadableStream<ResponseType> =\n      callProperties.call as ClientReadableStream<ResponseType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata: Metadata) {\n        stream.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        stream.push(message);\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== Status.OK) {\n          const callerStack = getErrorStackString(callerStackError!);\n          stream.emit('error', callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        stream.emit('status', status);\n      },\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return stream;\n  }\n\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType>;\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType>;\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata?: Metadata | CallOptions,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType> {\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =\n      {\n        path: method,\n        requestStream: true,\n        responseStream: true,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize,\n      };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      metadata: checkedArguments.metadata,\n      call: new ClientDuplexStreamImpl<RequestType, ResponseType>(\n        serialize,\n        deserialize\n      ),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const stream: ClientDuplexStream<RequestType, ResponseType> =\n      callProperties.call as ClientDuplexStream<RequestType, ResponseType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    let receivedStatus = false;\n    let callerStackError: Error | null = new Error();\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata: Metadata) {\n        stream.emit('metadata', metadata);\n      },\n      onReceiveMessage(message: Buffer) {\n        stream.push(message);\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== Status.OK) {\n          const callerStack = getErrorStackString(callerStackError!);\n          stream.emit('error', callErrorFromStatus(status, callerStack));\n        }\n        /* Avoid retaining the callerStackError object in the call context of\n         * the status event handler. */\n        callerStackError = null;\n        stream.emit('status', status);\n      },\n    });\n    return stream;\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,MAAA;AAeA,MAAA;AACA,MAAA;AAGA,MAAA;AACA,MAAA;AAEA,MAAA;AAeA,MAAM,iBAAiB;AACvB,MAAM,qBAAqB;AAC3B,MAAM,8BAA8B;AACpC,MAAM,qCAAqC;AAE3C,SAAS,WACP,GAAqE;IAErE,OAAO,OAAO,QAAQ;AACxB;AAgDA,SAAS,oBAAoB,KAAY;IACvC,OAAO,MAAM,KAAM,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC;AAChD;AAEA;;;IAIA,MAAa;IAKX,YACE,OAAe,EACf,WAA+B,EAC/B,UAAyB,CAAA,CAAE,CAAA;;QAE3B,UAAU,OAAO,MAAM,CAAC,CAAA,GAAI;QAC5B,IAAI,CAAC,mBAAmB,GAAG,CAAA,KAAA,QAAQ,YAAY,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;QACrD,OAAO,QAAQ,YAAY;QAC3B,IAAI,CAAC,4BAA4B,GAAG,CAAA,KAAA,QAAQ,qBAAqB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;QACvE,OAAO,QAAQ,qBAAqB;QACpC,IACE,IAAI,CAAC,mBAAmB,CAAC,MAAM,GAAG,KAClC,IAAI,CAAC,4BAA4B,CAAC,MAAM,GAAG,GAC3C;YACA,MAAM,IAAI,MACR,wEACE;QAEN;QACA,IAAI,CAAC,mCAAmC,GACtC,QAAQ,yBAAyB;QACnC,OAAO,QAAQ,yBAAyB;QACxC,IAAI,QAAQ,eAAe,EAAE;YAC3B,IAAI,CAAC,eAAe,GAAG,QAAQ,eAAe;QAChD,OAAO,IAAI,QAAQ,sBAAsB,EAAE;YACzC,MAAM,yBAAyB,QAAQ,sBAAsB;YAC7D,OAAO,QAAQ,sBAAsB;YACrC,IAAI,CAAC,eAAe,GAAG,uBACrB,SACA,aACA;QAEJ,OAAO;YACL,IAAI,CAAC,eAAe,GAAG,IAAI,UAAA,qBAAqB,CAC9C,SACA,aACA;QAEJ;IACF;IAEA,QAAK;QACH,IAAI,CAAC,eAAe,CAAC,KAAK;IAC5B;IAEA,aAAU;QACR,OAAO,IAAI,CAAC,eAAe;IAC7B;IAEA,aAAa,QAAkB,EAAE,QAAiC,EAAA;QAChE,MAAM,aAAa,CAAC;YAClB,IAAI,KAAK;gBACP,SAAS,IAAI,MAAM;gBACnB;YACF;YACA,IAAI;YACJ,IAAI;gBACF,WAAW,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC;YACvD,EAAE,OAAO,GAAG;gBACV,SAAS,IAAI,MAAM;gBACnB;YACF;YACA,IAAI,aAAa,qBAAA,iBAAiB,CAAC,KAAK,EAAE;gBACxC;YACF,OAAO;gBACL,IAAI;oBACF,IAAI,CAAC,eAAe,CAAC,sBAAsB,CACzC,UACA,UACA;gBAEJ,EAAE,OAAO,GAAG;oBACV,SAAS,IAAI,MAAM;gBACrB;YACF;QACF;QACA,aAAa;IACf;IAEQ,oCACN,IAA0D,EAC1D,IAAgD,EAChD,IAAkC,EAAA;QAMlC,IAAI,WAAW,OAAO;YACpB,OAAO;gBAAE,UAAU,IAAI,WAAA,QAAQ;gBAAI,SAAS,CAAA;gBAAI,UAAU;YAAI;QAChE,OAAO,IAAI,WAAW,OAAO;YAC3B,IAAI,gBAAgB,WAAA,QAAQ,EAAE;gBAC5B,OAAO;oBAAE,UAAU;oBAAM,SAAS,CAAA;oBAAI,UAAU;gBAAI;YACtD,OAAO;gBACL,OAAO;oBAAE,UAAU,IAAI,WAAA,QAAQ;oBAAI,SAAS;oBAAM,UAAU;gBAAI;YAClE;QACF,OAAO;YACL,IACE,CAAC,CACC,gBAAgB,WAAA,QAAQ,IACxB,gBAAgB,UAChB,WAAW,KAAK,GAElB;gBACA,MAAM,IAAI,MAAM;YAClB;YACA,OAAO;gBAAE,UAAU;gBAAM,SAAS;gBAAM,UAAU;YAAI;QACxD;IACF;IAkCA,iBACE,MAAc,EACd,SAAyC,EACzC,WAA4C,EAC5C,QAAqB,EACrB,QAA8D,EAC9D,OAAmD,EACnD,QAAsC,EAAA;;QAEtC,MAAM,mBACJ,IAAI,CAAC,mCAAmC,CACtC,UACA,SACA;QAEJ,MAAM,mBACJ;YACE,MAAM;YACN,eAAe;YACf,gBAAgB;YAChB,kBAAkB;YAClB,qBAAqB;;QAEzB,IAAI,iBAA4D;YAC9D,UAAU;YACV,UAAU,iBAAiB,QAAQ;YACnC,MAAM,IAAI,OAAA,mBAAmB;YAC7B,SAAS,IAAI,CAAC,eAAe;YAC7B,kBAAkB;YAClB,aAAa,iBAAiB,OAAO;YACrC,UAAU,iBAAiB,QAAQ;;QAErC,IAAI,IAAI,CAAC,mCAAmC,EAAE;YAC5C,iBAAiB,IAAI,CAAC,mCAAoC,CACxD;QAEJ;QACA,MAAM,UAA2B,eAAe,IAAI;QACpD,MAAM,kBAAwC;YAC5C,oBAAoB,IAAI,CAAC,mBAAmB;YAC5C,4BAA4B,IAAI,CAAC,4BAA4B;YAC7D,kBAAkB,CAAA,KAAA,eAAe,WAAW,CAAC,YAAY,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;YAC/D,0BACE,CAAA,KAAA,eAAe,WAAW,CAAC,qBAAqB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;;QAE1D,MAAM,OAAkC,CAAA,GAAA,sBAAA,mBAAmB,EACzD,iBACA,eAAe,gBAAgB,EAC/B,eAAe,WAAW,EAC1B,eAAe,OAAO;QAExB;;;+BAIA,QAAQ,IAAI,GAAG;QACf,IAAI,kBAAuC;QAC3C,IAAI,iBAAiB;QACrB,IAAI,mBAAiC,IAAI;QACzC,KAAK,KAAK,CAAC,eAAe,QAAQ,EAAE;YAClC,mBAAmB,CAAA;gBACjB,QAAQ,IAAI,CAAC,YAAY;YAC3B;YACA,8DAA8D;YAC9D,kBAAiB,OAAY;gBAC3B,IAAI,oBAAoB,MAAM;oBAC5B,KAAK,gBAAgB,CAAC,YAAA,MAAM,CAAC,QAAQ,EAAE;gBACzC;gBACA,kBAAkB;YACpB;YACA,iBAAgB,MAAoB;gBAClC,IAAI,gBAAgB;oBAClB;gBACF;gBACA,iBAAiB;gBACjB,IAAI,OAAO,IAAI,KAAK,YAAA,MAAM,CAAC,EAAE,EAAE;oBAC7B,IAAI,oBAAoB,MAAM;wBAC5B,MAAM,cAAc,oBAAoB;wBACxC,eAAe,QAAS,CACtB,CAAA,GAAA,OAAA,mBAAmB,EACjB;4BACE,MAAM,YAAA,MAAM,CAAC,QAAQ;4BACrB,SAAS;4BACT,UAAU,OAAO,QAAQ;2BAE3B;oBAGN,OAAO;wBACL,eAAe,QAAS,CAAC,MAAM;oBACjC;gBACF,OAAO;oBACL,MAAM,cAAc,oBAAoB;oBACxC,eAAe,QAAS,CAAC,CAAA,GAAA,OAAA,mBAAmB,EAAC,QAAQ;gBACvD;gBACA;gDAEA,mBAAmB;gBACnB,QAAQ,IAAI,CAAC,UAAU;YACzB;;QAEF,KAAK,WAAW,CAAC;QACjB,KAAK,SAAS;QACd,OAAO;IACT;IA8BA,wBACE,MAAc,EACd,SAAyC,EACzC,WAA4C,EAC5C,QAA8D,EAC9D,OAAmD,EACnD,QAAsC,EAAA;;QAEtC,MAAM,mBACJ,IAAI,CAAC,mCAAmC,CACtC,UACA,SACA;QAEJ,MAAM,mBACJ;YACE,MAAM;YACN,eAAe;YACf,gBAAgB;YAChB,kBAAkB;YAClB,qBAAqB;;QAEzB,IAAI,iBAA4D;YAC9D,UAAU,iBAAiB,QAAQ;YACnC,MAAM,IAAI,OAAA,wBAAwB,CAAc;YAChD,SAAS,IAAI,CAAC,eAAe;YAC7B,kBAAkB;YAClB,aAAa,iBAAiB,OAAO;YACrC,UAAU,iBAAiB,QAAQ;;QAErC,IAAI,IAAI,CAAC,mCAAmC,EAAE;YAC5C,iBAAiB,IAAI,CAAC,mCAAoC,CACxD;QAEJ;QACA,MAAM,UACJ,eAAe,IAAyC;QAC1D,MAAM,kBAAwC;YAC5C,oBAAoB,IAAI,CAAC,mBAAmB;YAC5C,4BAA4B,IAAI,CAAC,4BAA4B;YAC7D,kBAAkB,CAAA,KAAA,eAAe,WAAW,CAAC,YAAY,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;YAC/D,0BACE,CAAA,KAAA,eAAe,WAAW,CAAC,qBAAqB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;;QAE1D,MAAM,OAAkC,CAAA,GAAA,sBAAA,mBAAmB,EACzD,iBACA,eAAe,gBAAgB,EAC/B,eAAe,WAAW,EAC1B,eAAe,OAAO;QAExB;;;+BAIA,QAAQ,IAAI,GAAG;QACf,IAAI,kBAAuC;QAC3C,IAAI,iBAAiB;QACrB,IAAI,mBAAiC,IAAI;QACzC,KAAK,KAAK,CAAC,eAAe,QAAQ,EAAE;YAClC,mBAAmB,CAAA;gBACjB,QAAQ,IAAI,CAAC,YAAY;YAC3B;YACA,8DAA8D;YAC9D,kBAAiB,OAAY;gBAC3B,IAAI,oBAAoB,MAAM;oBAC5B,KAAK,gBAAgB,CAAC,YAAA,MAAM,CAAC,QAAQ,EAAE;gBACzC;gBACA,kBAAkB;YACpB;YACA,iBAAgB,MAAoB;gBAClC,IAAI,gBAAgB;oBAClB;gBACF;gBACA,iBAAiB;gBACjB,IAAI,OAAO,IAAI,KAAK,YAAA,MAAM,CAAC,EAAE,EAAE;oBAC7B,IAAI,oBAAoB,MAAM;wBAC5B,MAAM,cAAc,oBAAoB;wBACxC,eAAe,QAAS,CACtB,CAAA,GAAA,OAAA,mBAAmB,EACjB;4BACE,MAAM,YAAA,MAAM,CAAC,QAAQ;4BACrB,SAAS;4BACT,UAAU,OAAO,QAAQ;2BAE3B;oBAGN,OAAO;wBACL,eAAe,QAAS,CAAC,MAAM;oBACjC;gBACF,OAAO;oBACL,MAAM,cAAc,oBAAoB;oBACxC,eAAe,QAAS,CAAC,CAAA,GAAA,OAAA,mBAAmB,EAAC,QAAQ;gBACvD;gBACA;gDAEA,mBAAmB;gBACnB,QAAQ,IAAI,CAAC,UAAU;YACzB;;QAEF,OAAO;IACT;IAEQ,wBACN,IAA6B,EAC7B,IAAkB,EAAA;QAElB,IAAI;QACJ,IAAI;QACJ,IAAI,gBAAgB,WAAA,QAAQ,EAAE;YAC5B,WAAW;YACX,IAAI,MAAM;gBACR,UAAU;YACZ,OAAO;gBACL,UAAU,CAAA;YACZ;QACF,OAAO;YACL,IAAI,MAAM;gBACR,UAAU;YACZ,OAAO;gBACL,UAAU,CAAA;YACZ;YACA,WAAW,IAAI,WAAA,QAAQ;QACzB;QACA,OAAO;YAAE;YAAU;QAAO;IAC5B;IAiBA,wBACE,MAAc,EACd,SAAyC,EACzC,WAA4C,EAC5C,QAAqB,EACrB,QAAiC,EACjC,OAAqB,EAAA;;QAErB,MAAM,mBAAmB,IAAI,CAAC,uBAAuB,CAAC,UAAU;QAChE,MAAM,mBACJ;YACE,MAAM;YACN,eAAe;YACf,gBAAgB;YAChB,kBAAkB;YAClB,qBAAqB;;QAEzB,IAAI,iBAA4D;YAC9D,UAAU;YACV,UAAU,iBAAiB,QAAQ;YACnC,MAAM,IAAI,OAAA,wBAAwB,CAAe;YACjD,SAAS,IAAI,CAAC,eAAe;YAC7B,kBAAkB;YAClB,aAAa,iBAAiB,OAAO;;QAEvC,IAAI,IAAI,CAAC,mCAAmC,EAAE;YAC5C,iBAAiB,IAAI,CAAC,mCAAoC,CACxD;QAEJ;QACA,MAAM,SACJ,eAAe,IAA0C;QAC3D,MAAM,kBAAwC;YAC5C,oBAAoB,IAAI,CAAC,mBAAmB;YAC5C,4BAA4B,IAAI,CAAC,4BAA4B;YAC7D,kBAAkB,CAAA,KAAA,eAAe,WAAW,CAAC,YAAY,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;YAC/D,0BACE,CAAA,KAAA,eAAe,WAAW,CAAC,qBAAqB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;;QAE1D,MAAM,OAAkC,CAAA,GAAA,sBAAA,mBAAmB,EACzD,iBACA,eAAe,gBAAgB,EAC/B,eAAe,WAAW,EAC1B,eAAe,OAAO;QAExB;;;+BAIA,OAAO,IAAI,GAAG;QACd,IAAI,iBAAiB;QACrB,IAAI,mBAAiC,IAAI;QACzC,KAAK,KAAK,CAAC,eAAe,QAAQ,EAAE;YAClC,mBAAkB,QAAkB;gBAClC,OAAO,IAAI,CAAC,YAAY;YAC1B;YACA,8DAA8D;YAC9D,kBAAiB,OAAY;gBAC3B,OAAO,IAAI,CAAC;YACd;YACA,iBAAgB,MAAoB;gBAClC,IAAI,gBAAgB;oBAClB;gBACF;gBACA,iBAAiB;gBACjB,OAAO,IAAI,CAAC;gBACZ,IAAI,OAAO,IAAI,KAAK,YAAA,MAAM,CAAC,EAAE,EAAE;oBAC7B,MAAM,cAAc,oBAAoB;oBACxC,OAAO,IAAI,CAAC,SAAS,CAAA,GAAA,OAAA,mBAAmB,EAAC,QAAQ;gBACnD;gBACA;gDAEA,mBAAmB;gBACnB,OAAO,IAAI,CAAC,UAAU;YACxB;;QAEF,KAAK,WAAW,CAAC;QACjB,KAAK,SAAS;QACd,OAAO;IACT;IAeA,sBACE,MAAc,EACd,SAAyC,EACzC,WAA4C,EAC5C,QAAiC,EACjC,OAAqB,EAAA;;QAErB,MAAM,mBAAmB,IAAI,CAAC,uBAAuB,CAAC,UAAU;QAChE,MAAM,mBACJ;YACE,MAAM;YACN,eAAe;YACf,gBAAgB;YAChB,kBAAkB;YAClB,qBAAqB;;QAEzB,IAAI,iBAA4D;YAC9D,UAAU,iBAAiB,QAAQ;YACnC,MAAM,IAAI,OAAA,sBAAsB,CAC9B,WACA;YAEF,SAAS,IAAI,CAAC,eAAe;YAC7B,kBAAkB;YAClB,aAAa,iBAAiB,OAAO;;QAEvC,IAAI,IAAI,CAAC,mCAAmC,EAAE;YAC5C,iBAAiB,IAAI,CAAC,mCAAoC,CACxD;QAEJ;QACA,MAAM,SACJ,eAAe,IAAqD;QACtE,MAAM,kBAAwC;YAC5C,oBAAoB,IAAI,CAAC,mBAAmB;YAC5C,4BAA4B,IAAI,CAAC,4BAA4B;YAC7D,kBAAkB,CAAA,KAAA,eAAe,WAAW,CAAC,YAAY,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;YAC/D,0BACE,CAAA,KAAA,eAAe,WAAW,CAAC,qBAAqB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;;QAE1D,MAAM,OAAkC,CAAA,GAAA,sBAAA,mBAAmB,EACzD,iBACA,eAAe,gBAAgB,EAC/B,eAAe,WAAW,EAC1B,eAAe,OAAO;QAExB;;;+BAIA,OAAO,IAAI,GAAG;QACd,IAAI,iBAAiB;QACrB,IAAI,mBAAiC,IAAI;QACzC,KAAK,KAAK,CAAC,eAAe,QAAQ,EAAE;YAClC,mBAAkB,QAAkB;gBAClC,OAAO,IAAI,CAAC,YAAY;YAC1B;YACA,kBAAiB,OAAe;gBAC9B,OAAO,IAAI,CAAC;YACd;YACA,iBAAgB,MAAoB;gBAClC,IAAI,gBAAgB;oBAClB;gBACF;gBACA,iBAAiB;gBACjB,OAAO,IAAI,CAAC;gBACZ,IAAI,OAAO,IAAI,KAAK,YAAA,MAAM,CAAC,EAAE,EAAE;oBAC7B,MAAM,cAAc,oBAAoB;oBACxC,OAAO,IAAI,CAAC,SAAS,CAAA,GAAA,OAAA,mBAAmB,EAAC,QAAQ;gBACnD;gBACA;gDAEA,mBAAmB;gBACnB,OAAO,IAAI,CAAC,UAAU;YACxB;;QAEF,OAAO;IACT;;AAllBF,QAAA,MAAA,GAAA"}},
    {"offset": {"line": 3433, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3437, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/make-client.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { Client } from './client';\nimport { UntypedServiceImplementation } from './server';\n\nexport interface Serialize<T> {\n  (value: T): Buffer;\n}\n\nexport interface Deserialize<T> {\n  (bytes: Buffer): T;\n}\n\nexport interface ClientMethodDefinition<RequestType, ResponseType> {\n  path: string;\n  requestStream: boolean;\n  responseStream: boolean;\n  requestSerialize: Serialize<RequestType>;\n  responseDeserialize: Deserialize<ResponseType>;\n  originalName?: string;\n}\n\nexport interface ServerMethodDefinition<RequestType, ResponseType> {\n  path: string;\n  requestStream: boolean;\n  responseStream: boolean;\n  responseSerialize: Serialize<ResponseType>;\n  requestDeserialize: Deserialize<RequestType>;\n  originalName?: string;\n}\n\nexport interface MethodDefinition<RequestType, ResponseType>\n  extends ClientMethodDefinition<RequestType, ResponseType>,\n    ServerMethodDefinition<RequestType, ResponseType> {}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type ServiceDefinition<\n  ImplementationType = UntypedServiceImplementation\n> = {\n  readonly [index in keyof ImplementationType]: MethodDefinition<any, any>;\n};\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport interface ProtobufTypeDefinition {\n  format: string;\n  type: object;\n  fileDescriptorProtos: Buffer[];\n}\n\nexport interface PackageDefinition {\n  [index: string]: ServiceDefinition | ProtobufTypeDefinition;\n}\n\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n  unary: Client.prototype.makeUnaryRequest,\n  server_stream: Client.prototype.makeServerStreamRequest,\n  client_stream: Client.prototype.makeClientStreamRequest,\n  bidi: Client.prototype.makeBidiStreamRequest,\n};\n\nexport interface ServiceClient extends Client {\n  [methodName: string]: Function;\n}\n\nexport interface ServiceClientConstructor {\n  new (\n    address: string,\n    credentials: ChannelCredentials,\n    options?: Partial<ChannelOptions>\n  ): ServiceClient;\n  service: ServiceDefinition;\n  serviceName: string;\n}\n\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */\nfunction isPrototypePolluted(key: string): boolean {\n  return ['__proto__', 'prototype', 'constructor'].includes(key);\n}\n\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nexport function makeClientConstructor(\n  methods: ServiceDefinition,\n  serviceName: string,\n  classOptions?: {}\n): ServiceClientConstructor {\n  if (!classOptions) {\n    classOptions = {};\n  }\n\n  class ServiceClientImpl extends Client implements ServiceClient {\n    static service: ServiceDefinition;\n    static serviceName: string;\n    [methodName: string]: Function;\n  }\n\n  Object.keys(methods).forEach(name => {\n    if (isPrototypePolluted(name)) {\n      return;\n    }\n    const attrs = methods[name];\n    let methodType: keyof typeof requesterFuncs;\n    // TODO(murgatroid99): Verify that we don't need this anymore\n    if (typeof name === 'string' && name.charAt(0) === '$') {\n      throw new Error('Method names cannot start with $');\n    }\n    if (attrs.requestStream) {\n      if (attrs.responseStream) {\n        methodType = 'bidi';\n      } else {\n        methodType = 'client_stream';\n      }\n    } else {\n      if (attrs.responseStream) {\n        methodType = 'server_stream';\n      } else {\n        methodType = 'unary';\n      }\n    }\n    const serialize = attrs.requestSerialize;\n    const deserialize = attrs.responseDeserialize;\n    const methodFunc = partial(\n      requesterFuncs[methodType],\n      attrs.path,\n      serialize,\n      deserialize\n    );\n    ServiceClientImpl.prototype[name] = methodFunc;\n    // Associate all provided attributes with the method\n    Object.assign(ServiceClientImpl.prototype[name], attrs);\n    if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n      ServiceClientImpl.prototype[attrs.originalName] =\n        ServiceClientImpl.prototype[name];\n    }\n  });\n\n  ServiceClientImpl.service = methods;\n  ServiceClientImpl.serviceName = serviceName;\n\n  return ServiceClientImpl;\n}\n\nfunction partial(\n  fn: Function,\n  path: string,\n  serialize: Function,\n  deserialize: Function\n): Function {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: any, ...args: any[]) {\n    return fn.call(this, path, serialize, deserialize, ...args);\n  };\n}\n\nexport interface GrpcObject {\n  [index: string]:\n    | GrpcObject\n    | ServiceClientConstructor\n    | ProtobufTypeDefinition;\n}\n\nfunction isProtobufTypeDefinition(\n  obj: ServiceDefinition | ProtobufTypeDefinition\n): obj is ProtobufTypeDefinition {\n  return 'format' in obj;\n}\n\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nexport function loadPackageDefinition(\n  packageDef: PackageDefinition\n): GrpcObject {\n  const result: GrpcObject = {};\n  for (const serviceFqn in packageDef) {\n    if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n      const service = packageDef[serviceFqn];\n      const nameComponents = serviceFqn.split('.');\n      if (nameComponents.some((comp: string) => isPrototypePolluted(comp))) {\n        continue;\n      }\n      const serviceName = nameComponents[nameComponents.length - 1];\n      let current = result;\n      for (const packageName of nameComponents.slice(0, -1)) {\n        if (!current[packageName]) {\n          current[packageName] = {};\n        }\n        current = current[packageName] as GrpcObject;\n      }\n      if (isProtobufTypeDefinition(service)) {\n        current[serviceName] = service;\n      } else {\n        current[serviceName] = makeClientConstructor(service, serviceName, {});\n      }\n    }\n  }\n  return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3576, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3580, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/channelz.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIPv4, isIPv6 } from 'net';\nimport { ConnectivityState } from './connectivity-state';\nimport { Status } from './constants';\nimport { Timestamp } from './generated/google/protobuf/Timestamp';\nimport { Channel as ChannelMessage } from './generated/grpc/channelz/v1/Channel';\nimport { ChannelConnectivityState__Output } from './generated/grpc/channelz/v1/ChannelConnectivityState';\nimport { ChannelRef as ChannelRefMessage } from './generated/grpc/channelz/v1/ChannelRef';\nimport { ChannelTrace } from './generated/grpc/channelz/v1/ChannelTrace';\nimport { GetChannelRequest__Output } from './generated/grpc/channelz/v1/GetChannelRequest';\nimport { GetChannelResponse } from './generated/grpc/channelz/v1/GetChannelResponse';\nimport { sendUnaryData, ServerUnaryCall } from './server-call';\nimport { ServerRef as ServerRefMessage } from './generated/grpc/channelz/v1/ServerRef';\nimport { SocketRef as SocketRefMessage } from './generated/grpc/channelz/v1/SocketRef';\nimport {\n  isTcpSubchannelAddress,\n  SubchannelAddress,\n} from './subchannel-address';\nimport { SubchannelRef as SubchannelRefMessage } from './generated/grpc/channelz/v1/SubchannelRef';\nimport { GetServerRequest__Output } from './generated/grpc/channelz/v1/GetServerRequest';\nimport { GetServerResponse } from './generated/grpc/channelz/v1/GetServerResponse';\nimport { Server as ServerMessage } from './generated/grpc/channelz/v1/Server';\nimport { GetServersRequest__Output } from './generated/grpc/channelz/v1/GetServersRequest';\nimport { GetServersResponse } from './generated/grpc/channelz/v1/GetServersResponse';\nimport { GetTopChannelsRequest__Output } from './generated/grpc/channelz/v1/GetTopChannelsRequest';\nimport { GetTopChannelsResponse } from './generated/grpc/channelz/v1/GetTopChannelsResponse';\nimport { GetSubchannelRequest__Output } from './generated/grpc/channelz/v1/GetSubchannelRequest';\nimport { GetSubchannelResponse } from './generated/grpc/channelz/v1/GetSubchannelResponse';\nimport { Subchannel as SubchannelMessage } from './generated/grpc/channelz/v1/Subchannel';\nimport { GetSocketRequest__Output } from './generated/grpc/channelz/v1/GetSocketRequest';\nimport { GetSocketResponse } from './generated/grpc/channelz/v1/GetSocketResponse';\nimport { Socket as SocketMessage } from './generated/grpc/channelz/v1/Socket';\nimport { Address } from './generated/grpc/channelz/v1/Address';\nimport { Security } from './generated/grpc/channelz/v1/Security';\nimport { GetServerSocketsRequest__Output } from './generated/grpc/channelz/v1/GetServerSocketsRequest';\nimport { GetServerSocketsResponse } from './generated/grpc/channelz/v1/GetServerSocketsResponse';\nimport {\n  ChannelzDefinition,\n  ChannelzHandlers,\n} from './generated/grpc/channelz/v1/Channelz';\nimport { ProtoGrpcType as ChannelzProtoGrpcType } from './generated/channelz';\nimport type { loadSync } from '@grpc/proto-loader';\nimport { registerAdminService } from './admin';\nimport { loadPackageDefinition } from './make-client';\n\nexport type TraceSeverity =\n  | 'CT_UNKNOWN'\n  | 'CT_INFO'\n  | 'CT_WARNING'\n  | 'CT_ERROR';\n\nexport interface ChannelRef {\n  kind: 'channel';\n  id: number;\n  name: string;\n}\n\nexport interface SubchannelRef {\n  kind: 'subchannel';\n  id: number;\n  name: string;\n}\n\nexport interface ServerRef {\n  kind: 'server';\n  id: number;\n}\n\nexport interface SocketRef {\n  kind: 'socket';\n  id: number;\n  name: string;\n}\n\nfunction channelRefToMessage(ref: ChannelRef): ChannelRefMessage {\n  return {\n    channel_id: ref.id,\n    name: ref.name,\n  };\n}\n\nfunction subchannelRefToMessage(ref: SubchannelRef): SubchannelRefMessage {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name,\n  };\n}\n\nfunction serverRefToMessage(ref: ServerRef): ServerRefMessage {\n  return {\n    server_id: ref.id,\n  };\n}\n\nfunction socketRefToMessage(ref: SocketRef): SocketRefMessage {\n  return {\n    socket_id: ref.id,\n    name: ref.name,\n  };\n}\n\ninterface TraceEvent {\n  description: string;\n  severity: TraceSeverity;\n  timestamp: Date;\n  childChannel?: ChannelRef;\n  childSubchannel?: SubchannelRef;\n}\n\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\n\nexport class ChannelzTrace {\n  events: TraceEvent[] = [];\n  creationTimestamp: Date;\n  eventsLogged = 0;\n\n  constructor() {\n    this.creationTimestamp = new Date();\n  }\n\n  addTrace(\n    severity: TraceSeverity,\n    description: string,\n    child?: ChannelRef | SubchannelRef\n  ) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: child?.kind === 'channel' ? child : undefined,\n      childSubchannel: child?.kind === 'subchannel' ? child : undefined,\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n\n  getTraceMessage(): ChannelTrace {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel\n            ? channelRefToMessage(event.childChannel)\n            : null,\n          subchannel_ref: event.childSubchannel\n            ? subchannelRefToMessage(event.childSubchannel)\n            : null,\n        };\n      }),\n    };\n  }\n}\n\nexport class ChannelzChildrenTracker {\n  private channelChildren: Map<number, { ref: ChannelRef; count: number }> =\n    new Map<number, { ref: ChannelRef; count: number }>();\n  private subchannelChildren: Map<\n    number,\n    { ref: SubchannelRef; count: number }\n  > = new Map<number, { ref: SubchannelRef; count: number }>();\n  private socketChildren: Map<number, { ref: SocketRef; count: number }> =\n    new Map<number, { ref: SocketRef; count: number }>();\n\n  refChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        const trackedChild = this.channelChildren.get(child.id) ?? {\n          ref: child,\n          count: 0,\n        };\n        trackedChild.count += 1;\n        this.channelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'subchannel': {\n        const trackedChild = this.subchannelChildren.get(child.id) ?? {\n          ref: child,\n          count: 0,\n        };\n        trackedChild.count += 1;\n        this.subchannelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'socket': {\n        const trackedChild = this.socketChildren.get(child.id) ?? {\n          ref: child,\n          count: 0,\n        };\n        trackedChild.count += 1;\n        this.socketChildren.set(child.id, trackedChild);\n        break;\n      }\n    }\n  }\n\n  unrefChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        const trackedChild = this.channelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.channelChildren.delete(child.id);\n          } else {\n            this.channelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'subchannel': {\n        const trackedChild = this.subchannelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.subchannelChildren.delete(child.id);\n          } else {\n            this.subchannelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'socket': {\n        const trackedChild = this.socketChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.socketChildren.delete(child.id);\n          } else {\n            this.socketChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  getChildLists(): ChannelzChildren {\n    const channels: ChannelRef[] = [];\n    for (const { ref } of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n    const subchannels: SubchannelRef[] = [];\n    for (const { ref } of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n    const sockets: SocketRef[] = [];\n    for (const { ref } of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n    return { channels, subchannels, sockets };\n  }\n}\n\nexport class ChannelzCallTracker {\n  callsStarted = 0;\n  callsSucceeded = 0;\n  callsFailed = 0;\n  lastCallStartedTimestamp: Date | null = null;\n\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\n\nexport interface ChannelzChildren {\n  channels: ChannelRef[];\n  subchannels: SubchannelRef[];\n  sockets: SocketRef[];\n}\n\nexport interface ChannelInfo {\n  target: string;\n  state: ConnectivityState;\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  children: ChannelzChildren;\n}\n\nexport type SubchannelInfo = ChannelInfo;\n\nexport interface ServerInfo {\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  listenerChildren: ChannelzChildren;\n  sessionChildren: ChannelzChildren;\n}\n\nexport interface TlsInfo {\n  cipherSuiteStandardName: string | null;\n  cipherSuiteOtherName: string | null;\n  localCertificate: Buffer | null;\n  remoteCertificate: Buffer | null;\n}\n\nexport interface SocketInfo {\n  localAddress: SubchannelAddress | null;\n  remoteAddress: SubchannelAddress | null;\n  security: TlsInfo | null;\n  remoteName: string | null;\n  streamsStarted: number;\n  streamsSucceeded: number;\n  streamsFailed: number;\n  messagesSent: number;\n  messagesReceived: number;\n  keepAlivesSent: number;\n  lastLocalStreamCreatedTimestamp: Date | null;\n  lastRemoteStreamCreatedTimestamp: Date | null;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n  localFlowControlWindow: number | null;\n  remoteFlowControlWindow: number | null;\n}\n\ninterface ChannelEntry {\n  ref: ChannelRef;\n  getInfo(): ChannelInfo;\n}\n\ninterface SubchannelEntry {\n  ref: SubchannelRef;\n  getInfo(): SubchannelInfo;\n}\n\ninterface ServerEntry {\n  ref: ServerRef;\n  getInfo(): ServerInfo;\n}\n\ninterface SocketEntry {\n  ref: SocketRef;\n  getInfo(): SocketInfo;\n}\n\nlet nextId = 1;\n\nfunction getNextId(): number {\n  return nextId++;\n}\n\nconst channels: (ChannelEntry | undefined)[] = [];\nconst subchannels: (SubchannelEntry | undefined)[] = [];\nconst servers: (ServerEntry | undefined)[] = [];\nconst sockets: (SocketEntry | undefined)[] = [];\n\nexport function registerChannelzChannel(\n  name: string,\n  getInfo: () => ChannelInfo,\n  channelzEnabled: boolean\n): ChannelRef {\n  const id = getNextId();\n  const ref: ChannelRef = { id, name, kind: 'channel' };\n  if (channelzEnabled) {\n    channels[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzSubchannel(\n  name: string,\n  getInfo: () => SubchannelInfo,\n  channelzEnabled: boolean\n): SubchannelRef {\n  const id = getNextId();\n  const ref: SubchannelRef = { id, name, kind: 'subchannel' };\n  if (channelzEnabled) {\n    subchannels[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzServer(\n  getInfo: () => ServerInfo,\n  channelzEnabled: boolean\n): ServerRef {\n  const id = getNextId();\n  const ref: ServerRef = { id, kind: 'server' };\n  if (channelzEnabled) {\n    servers[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzSocket(\n  name: string,\n  getInfo: () => SocketInfo,\n  channelzEnabled: boolean\n): SocketRef {\n  const id = getNextId();\n  const ref: SocketRef = { id, name, kind: 'socket' };\n  if (channelzEnabled) {\n    sockets[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function unregisterChannelzRef(\n  ref: ChannelRef | SubchannelRef | ServerRef | SocketRef\n) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n    case 'server':\n      delete servers[ref.id];\n      return;\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\n\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection: string): [number, number] {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [(numberValue / 256) | 0, numberValue % 256];\n}\n\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk: string): number[] {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk\n    .split(':')\n    .map(section => parseIPv6Section(section));\n  const result: number[] = [];\n  return result.concat(...bytePairs);\n}\n\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress: string): Buffer | null {\n  if (isIPv4(ipAddress)) {\n    return Buffer.from(\n      Uint8Array.from(\n        ipAddress.split('.').map(segment => Number.parseInt(segment))\n      )\n    );\n  } else if (isIPv6(ipAddress)) {\n    let leftSection: string;\n    let rightSection: string;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(\n      16 - leftBuffer.length - rightBuffer.length,\n      0\n    );\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\n\nfunction connectivityStateToMessage(\n  state: ConnectivityState\n): ChannelConnectivityState__Output {\n  switch (state) {\n    case ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING',\n      };\n    case ConnectivityState.IDLE:\n      return {\n        state: 'IDLE',\n      };\n    case ConnectivityState.READY:\n      return {\n        state: 'READY',\n      };\n    case ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN',\n      };\n    case ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE',\n      };\n    default:\n      return {\n        state: 'UNKNOWN',\n      };\n  }\n}\n\nfunction dateToProtoTimestamp(date?: Date | null): Timestamp | null {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: (millisSinceEpoch / 1000) | 0,\n    nanos: (millisSinceEpoch % 1000) * 1_000_000,\n  };\n}\n\nfunction getChannelMessage(channelEntry: ChannelEntry): ChannelMessage {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(\n        resolvedInfo.callTracker.lastCallStartedTimestamp\n      ),\n      trace: resolvedInfo.trace.getTraceMessage(),\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref =>\n      channelRefToMessage(ref)\n    ),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref =>\n      subchannelRefToMessage(ref)\n    ),\n  };\n}\n\nfunction GetChannel(\n  call: ServerUnaryCall<GetChannelRequest__Output, GetChannelResponse>,\n  callback: sendUnaryData<GetChannelResponse>\n): void {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n  if (channelEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No channel data found for id ' + channelId,\n    });\n    return;\n  }\n  callback(null, { channel: getChannelMessage(channelEntry) });\n}\n\nfunction GetTopChannels(\n  call: ServerUnaryCall<GetTopChannelsRequest__Output, GetTopChannelsResponse>,\n  callback: sendUnaryData<GetTopChannelsResponse>\n): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ChannelMessage[] = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n    if (channelEntry === undefined) {\n      continue;\n    }\n    resultList.push(getChannelMessage(channelEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length,\n  });\n}\n\nfunction getServerMessage(serverEntry: ServerEntry): ServerMessage {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(\n        resolvedInfo.callTracker.lastCallStartedTimestamp\n      ),\n      trace: resolvedInfo.trace.getTraceMessage(),\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref =>\n      socketRefToMessage(ref)\n    ),\n  };\n}\n\nfunction GetServer(\n  call: ServerUnaryCall<GetServerRequest__Output, GetServerResponse>,\n  callback: sendUnaryData<GetServerResponse>\n): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No server data found for id ' + serverId,\n    });\n    return;\n  }\n  callback(null, { server: getServerMessage(serverEntry) });\n}\n\nfunction GetServers(\n  call: ServerUnaryCall<GetServersRequest__Output, GetServersResponse>,\n  callback: sendUnaryData<GetServersResponse>\n): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ServerMessage[] = [];\n  let i = Number.parseInt(call.request.start_server_id);\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n    if (serverEntry === undefined) {\n      continue;\n    }\n    resultList.push(getServerMessage(serverEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length,\n  });\n}\n\nfunction GetSubchannel(\n  call: ServerUnaryCall<GetSubchannelRequest__Output, GetSubchannelResponse>,\n  callback: sendUnaryData<GetSubchannelResponse>\n): void {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n  if (subchannelEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No subchannel data found for id ' + subchannelId,\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage: SubchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(\n        resolvedInfo.callTracker.lastCallStartedTimestamp\n      ),\n      trace: resolvedInfo.trace.getTraceMessage(),\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref =>\n      socketRefToMessage(ref)\n    ),\n  };\n  callback(null, { subchannel: subchannelMessage });\n}\n\nfunction subchannelAddressToAddressMessage(\n  subchannelAddress: SubchannelAddress\n): Address {\n  if (isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address:\n          ipAddressStringToBuffer(subchannelAddress.host) ?? undefined,\n        port: subchannelAddress.port,\n      },\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path,\n      },\n    };\n  }\n}\n\nfunction GetSocket(\n  call: ServerUnaryCall<GetSocketRequest__Output, GetSocketResponse>,\n  callback: sendUnaryData<GetSocketResponse>\n): void {\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n  if (socketEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No socket data found for id ' + socketId,\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage: Security | null = resolvedInfo.security\n    ? {\n        model: 'tls',\n        tls: {\n          cipher_suite: resolvedInfo.security.cipherSuiteStandardName\n            ? 'standard_name'\n            : 'other_name',\n          standard_name:\n            resolvedInfo.security.cipherSuiteStandardName ?? undefined,\n          other_name: resolvedInfo.security.cipherSuiteOtherName ?? undefined,\n          local_certificate:\n            resolvedInfo.security.localCertificate ?? undefined,\n          remote_certificate:\n            resolvedInfo.security.remoteCertificate ?? undefined,\n        },\n      }\n    : null;\n  const socketMessage: SocketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress\n      ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)\n      : null,\n    remote: resolvedInfo.remoteAddress\n      ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)\n      : null,\n    remote_name: resolvedInfo.remoteName ?? undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastLocalStreamCreatedTimestamp\n      ),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastRemoteStreamCreatedTimestamp\n      ),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastMessageReceivedTimestamp\n      ),\n      last_message_sent_timestamp: dateToProtoTimestamp(\n        resolvedInfo.lastMessageSentTimestamp\n      ),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow\n        ? { value: resolvedInfo.localFlowControlWindow }\n        : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow\n        ? { value: resolvedInfo.remoteFlowControlWindow }\n        : null,\n    },\n  };\n  callback(null, { socket: socketMessage });\n}\n\nfunction GetServerSockets(\n  call: ServerUnaryCall<\n    GetServerSocketsRequest__Output,\n    GetServerSocketsResponse\n  >,\n  callback: sendUnaryData<GetServerSocketsResponse>\n): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      code: Status.NOT_FOUND,\n      details: 'No server data found for id ' + serverId,\n    });\n    return;\n  }\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort(\n    (ref1, ref2) => ref1.id - ref2.id\n  );\n  const resultList: SocketRefMessage[] = [];\n  let i = 0;\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length,\n  });\n}\n\nexport function getChannelzHandlers(): ChannelzHandlers {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets,\n  };\n}\n\nlet loadedChannelzDefinition: ChannelzDefinition | null = null;\n\nexport function getChannelzServiceDefinition(): ChannelzDefinition {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader')\n    .loadSync as typeof loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`],\n  });\n  const channelzGrpcObject = loadPackageDefinition(\n    loadedProto\n  ) as unknown as ChannelzProtoGrpcType;\n  loadedChannelzDefinition =\n    channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\n\nexport function setup() {\n  registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4243, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4247, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport {\n  SubchannelRef,\n  ChannelzTrace,\n  ChannelzChildrenTracker,\n  SubchannelInfo,\n  registerChannelzSubchannel,\n  ChannelzCallTracker,\n  unregisterChannelzRef,\n} from './channelz';\nimport {\n  ConnectivityStateListener,\n  SubchannelInterface,\n} from './subchannel-interface';\nimport { SubchannelCallInterceptingListener } from './subchannel-call';\nimport { SubchannelCall } from './subchannel-call';\nimport { CallEventTracker, SubchannelConnector, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel';\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private transport: Transport | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: Set<ConnectivityStateListener> = new Set();\n\n  private backoffTimeout: BackoffTimeout;\n\n  private keepaliveTime: number;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private streamTracker = new ChannelzCallTracker();\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials,\n    private connector: SubchannelConnector\n  ) {\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzSubchannel(\n      this.subchannelAddressString,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace(\n      'Subchannel constructed with options ' +\n        JSON.stringify(options, undefined, 2)\n    );\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString,\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'subchannel_refcount',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(\n        this.keepaliveTime,\n        KEEPALIVE_MAX_TIME_MS\n      );\n      options = { ...options, 'grpc.keepalive_time_ms': adjustedKeepaliveTime };\n    }\n    this.connector\n      .connect(this.subchannelAddress, this.credentials, options)\n      .then(\n        transport => {\n          if (\n            this.transitionToState(\n              [ConnectivityState.CONNECTING],\n              ConnectivityState.READY\n            )\n          ) {\n            this.transport = transport;\n            if (this.channelzEnabled) {\n              this.childrenTracker.refChild(transport.getChannelzRef());\n            }\n            transport.addDisconnectListener(tooManyPings => {\n              this.transitionToState(\n                [ConnectivityState.READY],\n                ConnectivityState.IDLE\n              );\n              if (tooManyPings && this.keepaliveTime > 0) {\n                this.keepaliveTime *= 2;\n                logging.log(\n                  LogVerbosity.ERROR,\n                  `Connection to ${uriToString(this.channelTarget)} at ${\n                    this.subchannelAddressString\n                  } rejected by server because of excess pings. Increasing ping interval to ${\n                    this.keepaliveTime\n                  } ms`\n                );\n              }\n            });\n          } else {\n            /* If we can't transition from CONNECTING to READY here, we will\n             * not be using this transport, so release its resources. */\n            transport.shutdown();\n          }\n        },\n        error => {\n          this.transitionToState(\n            [ConnectivityState.CONNECTING],\n            ConnectivityState.TRANSIENT_FAILURE,\n            `${error}`\n          );\n        }\n      );\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState,\n    errorMessage?: string\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace(\n        'CT_INFO',\n        'Connectivity state change to ' + ConnectivityState[newState]\n      );\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    for (const listener of this.stateListeners) {\n      listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n    }\n    return true;\n  }\n\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n      process.nextTick(() => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING, ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      });\n    }\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener\n  ): SubchannelCall {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker: Partial<CallEventTracker>;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        },\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(\n      metadata,\n      host,\n      method,\n      listener,\n      statsTracker\n    );\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    process.nextTick(() => {\n      /* First, try to transition from IDLE to connecting. If that doesn't happen\n       * because the state is not currently IDLE, check if it is\n       * TRANSIENT_FAILURE, and if so indicate that it should go back to\n       * connecting after the backoff timer ends. Otherwise do nothing */\n      if (\n        !this.transitionToState(\n          [ConnectivityState.IDLE],\n          ConnectivityState.CONNECTING\n        )\n      ) {\n        if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n          this.continueConnecting = true;\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.add(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.delete(listener);\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    process.nextTick(() => {\n      this.backoffTimeout.reset();\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    });\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n\n  realSubchannelEquals(other: SubchannelInterface): boolean {\n    return other.getRealSubchannel() === this;\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4583, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4587, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/resolver-dns.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Resolver,\n  ResolverListener,\n  registerResolver,\n  registerDefaultScheme,\n} from './resolver';\nimport * as dns from 'dns';\nimport * as util from 'util';\nimport { extractAndSelectServiceConfig, ServiceConfig } from './service-config';\nimport { Status } from './constants';\nimport { StatusObject } from './call-interface';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { SubchannelAddress, TcpSubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString, splitHostPort } from './uri-parser';\nimport { isIPv6, isIPv4 } from 'net';\nimport { ChannelOptions } from './channel-options';\nimport { BackoffOptions, BackoffTimeout } from './backoff-timeout';\n\nconst TRACER_NAME = 'dns_resolver';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nexport const DEFAULT_PORT = 443;\n\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30_000;\n\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays<T>(...arrays: T[][]): T[] {\n  const result: T[] = [];\n  for (\n    let i = 0;\n    i <\n    Math.max.apply(\n      null,\n      arrays.map(array => array.length)\n    );\n    i++\n  ) {\n    for (const array of arrays) {\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver implements Resolver {\n  private readonly ipResult: SubchannelAddress[] | null;\n  private readonly dnsHostname: string | null;\n  private readonly port: number | null;\n  /**\n   * Minimum time between resolutions, measured as the time between starting\n   * successive resolution requests. Only applies to successful resolutions.\n   * Failures are handled by the backoff timer.\n   */\n  private readonly minTimeBetweenResolutionsMs: number;\n  private pendingLookupPromise: Promise<dns.LookupAddress[]> | null = null;\n  private pendingTxtPromise: Promise<string[][]> | null = null;\n  private latestLookupResult: TcpSubchannelAddress[] | null = null;\n  private latestServiceConfig: ServiceConfig | null = null;\n  private latestServiceConfigError: StatusObject | null = null;\n  private percentage: number;\n  private defaultResolutionError: StatusObject;\n  private backoff: BackoffTimeout;\n  private continueResolving = false;\n  private nextResolutionTimer: NodeJS.Timeout;\n  private isNextResolutionTimerRunning = false;\n  private isServiceConfigEnabled = true;\n  private returnedIpResult = false;\n  constructor(\n    private target: GrpcUri,\n    private listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ) {\n    trace('Resolver constructed for target ' + uriToString(target));\n    const hostPort = splitHostPort(target.path);\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if (isIPv4(hostPort.host) || isIPv6(hostPort.host)) {\n        this.ipResult = [\n          {\n            host: hostPort.host,\n            port: hostPort.port ?? DEFAULT_PORT,\n          },\n        ];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = hostPort.port ?? DEFAULT_PORT;\n      }\n    }\n    this.percentage = Math.random() * 100;\n\n    if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\n      this.isServiceConfigEnabled = false;\n    }\n\n    this.defaultResolutionError = {\n      code: Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${uriToString(this.target)}`,\n      metadata: new Metadata(),\n    };\n\n    const backoffOptions: BackoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n    };\n\n    this.backoff = new BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, backoffOptions);\n    this.backoff.unref();\n\n    this.minTimeBetweenResolutionsMs =\n      channelOptions['grpc.dns_min_time_between_resolutions_ms'] ??\n      DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n    this.nextResolutionTimer = setTimeout(() => {}, 0);\n    clearTimeout(this.nextResolutionTimer);\n  }\n\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n  private startResolution() {\n    if (this.ipResult !== null) {\n      if (!this.returnedIpResult) {\n        trace('Returning IP address for target ' + uriToString(this.target));\n        setImmediate(() => {\n          this.listener.onSuccessfulResolution(\n            this.ipResult!,\n            null,\n            null,\n            null,\n            {}\n          );\n        });\n        this.returnedIpResult = true;\n      }\n      this.backoff.stop();\n      this.backoff.reset();\n      this.stopNextResolutionTimer();\n      return;\n    }\n    if (this.dnsHostname === null) {\n      trace('Failed to parse DNS address ' + uriToString(this.target));\n      setImmediate(() => {\n        this.listener.onError({\n          code: Status.UNAVAILABLE,\n          details: `Failed to parse DNS address ${uriToString(this.target)}`,\n          metadata: new Metadata(),\n        });\n      });\n      this.stopNextResolutionTimer();\n    } else {\n      if (this.pendingLookupPromise !== null) {\n        return;\n      }\n      trace('Looking up DNS hostname ' + this.dnsHostname);\n      /* We clear out latestLookupResult here to ensure that it contains the\n       * latest result since the last time we started resolving. That way, the\n       * TXT resolution handler can use it, but only if it finishes second. We\n       * don't clear out any previous service config results because it's\n       * better to use a service config that's slightly out of date than to\n       * revert to an effectively blank one. */\n      this.latestLookupResult = null;\n      const hostname: string = this.dnsHostname;\n      /* We lookup both address families here and then split them up later\n       * because when looking up a single family, dns.lookup outputs an error\n       * if the name exists but there are no records for that family, and that\n       * error is indistinguishable from other kinds of errors */\n      this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\n      this.pendingLookupPromise.then(\n        addressList => {\n          if (this.pendingLookupPromise === null) {\n            return;\n          }\n          this.pendingLookupPromise = null;\n          this.backoff.reset();\n          this.backoff.stop();\n          const ip4Addresses: dns.LookupAddress[] = addressList.filter(\n            addr => addr.family === 4\n          );\n          const ip6Addresses: dns.LookupAddress[] = addressList.filter(\n            addr => addr.family === 6\n          );\n          this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(\n            addr => ({ host: addr.address, port: +this.port! })\n          );\n          const allAddressesString: string =\n            '[' +\n            this.latestLookupResult\n              .map(addr => addr.host + ':' + addr.port)\n              .join(',') +\n            ']';\n          trace(\n            'Resolved addresses for target ' +\n              uriToString(this.target) +\n              ': ' +\n              allAddressesString\n          );\n          if (this.latestLookupResult.length === 0) {\n            this.listener.onError(this.defaultResolutionError);\n            return;\n          }\n          /* If the TXT lookup has not yet finished, both of the last two\n           * arguments will be null, which is the equivalent of getting an\n           * empty TXT response. When the TXT lookup does finish, its handler\n           * can update the service config by using the same address list */\n          this.listener.onSuccessfulResolution(\n            this.latestLookupResult,\n            this.latestServiceConfig,\n            this.latestServiceConfigError,\n            null,\n            {}\n          );\n        },\n        err => {\n          if (this.pendingLookupPromise === null) {\n            return;\n          }\n          trace(\n            'Resolution error for target ' +\n              uriToString(this.target) +\n              ': ' +\n              (err as Error).message\n          );\n          this.pendingLookupPromise = null;\n          this.stopNextResolutionTimer();\n          this.listener.onError(this.defaultResolutionError);\n        }\n      );\n      /* If there already is a still-pending TXT resolution, we can just use\n       * that result when it comes in */\n      if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n        this.pendingTxtPromise = resolveTxtPromise(hostname);\n        this.pendingTxtPromise.then(\n          txtRecord => {\n            if (this.pendingTxtPromise === null) {\n              return;\n            }\n            this.pendingTxtPromise = null;\n            try {\n              this.latestServiceConfig = extractAndSelectServiceConfig(\n                txtRecord,\n                this.percentage\n              );\n            } catch (err) {\n              this.latestServiceConfigError = {\n                code: Status.UNAVAILABLE,\n                details: `Parsing service config failed with error ${\n                  (err as Error).message\n                }`,\n                metadata: new Metadata(),\n              };\n            }\n            if (this.latestLookupResult !== null) {\n              /* We rely here on the assumption that calling this function with\n               * identical parameters will be essentialy idempotent, and calling\n               * it with the same address list and a different service config\n               * should result in a fast and seamless switchover. */\n              this.listener.onSuccessfulResolution(\n                this.latestLookupResult,\n                this.latestServiceConfig,\n                this.latestServiceConfigError,\n                null,\n                {}\n              );\n            }\n          },\n          err => {\n            /* If TXT lookup fails we should do nothing, which means that we\n             * continue to use the result of the most recent successful lookup,\n             * or the default null config object if there has never been a\n             * successful lookup. We do not set the latestServiceConfigError\n             * here because that is specifically used for response validation\n             * errors. We still need to handle this error so that it does not\n             * bubble up as an unhandled promise rejection. */\n          }\n        );\n      }\n    }\n  }\n\n  private startNextResolutionTimer() {\n    clearTimeout(this.nextResolutionTimer);\n    this.nextResolutionTimer = setTimeout(() => {\n      this.stopNextResolutionTimer();\n      if (this.continueResolving) {\n        this.startResolutionWithBackoff();\n      }\n    }, this.minTimeBetweenResolutionsMs).unref?.();\n    this.isNextResolutionTimerRunning = true;\n  }\n\n  private stopNextResolutionTimer() {\n    clearTimeout(this.nextResolutionTimer);\n    this.isNextResolutionTimerRunning = false;\n  }\n\n  private startResolutionWithBackoff() {\n    if (this.pendingLookupPromise === null) {\n      this.continueResolving = false;\n      this.backoff.runOnce();\n      this.startNextResolutionTimer();\n      this.startResolution();\n    }\n  }\n\n  updateResolution() {\n    /* If there is a pending lookup, just let it finish. Otherwise, if the\n     * nextResolutionTimer or backoff timer is running, set the\n     * continueResolving flag to resolve when whichever of those timers\n     * fires. Otherwise, start resolving immediately. */\n    if (this.pendingLookupPromise === null) {\n      if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n        if (this.isNextResolutionTimerRunning) {\n          trace('resolution update delayed by \"min time between resolutions\" rate limit');\n        } else {\n          trace('resolution update delayed by backoff timer until ' + this.backoff.getEndTime().toISOString());\n        }\n        this.continueResolving = true;\n      } else {\n        this.startResolutionWithBackoff();\n      }\n    }\n  }\n\n  /**\n   * Reset the resolver to the same state it had when it was created. In-flight\n   * DNS requests cannot be cancelled, but they are discarded and their results\n   * will be ignored.\n   */\n  destroy() {\n    this.continueResolving = false;\n    this.backoff.reset();\n    this.backoff.stop();\n    this.stopNextResolutionTimer();\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    this.returnedIpResult = false;\n  }\n\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n  static getDefaultAuthority(target: GrpcUri): string {\n    return target.path;\n  }\n}\n\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nexport function setup(): void {\n  registerResolver('dns', DnsResolver);\n  registerDefaultScheme('dns');\n}\n\nexport interface DnsUrl {\n  host: string;\n  port?: string;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4887, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4891, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/http_proxy.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nimport { getDefaultAuthority } from './resolver';\nimport { Socket } from 'net';\nimport * as http from 'http';\nimport * as tls from 'tls';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { URL } from 'url';\nimport { DEFAULT_PORT } from './resolver-dns';\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface ProxyInfo {\n  address?: string;\n  creds?: string;\n}\n\nfunction getProxyInfo(): ProxyInfo {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl: URL;\n  try {\n    proxyUrl = new URL(proxyEnv);\n  } catch (e) {\n    log(LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    log(\n      LogVerbosity.ERROR,\n      `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`\n    );\n    return {};\n  }\n  let userCred: string | null = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      log(LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result: ProxyInfo = {\n    address: `${hostname}:${port}`,\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace(\n    'Proxy server ' + result.address + ' set by environment variable ' + envVar\n  );\n  return result;\n}\n\nfunction getNoProxyHostList(): string[] {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr: string | undefined = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nexport interface ProxyMapResult {\n  target: GrpcUri;\n  extraOptions: ChannelOptions;\n}\n\nexport function mapProxyName(\n  target: GrpcUri,\n  options: ChannelOptions\n): ProxyMapResult {\n  const noProxyResult: ProxyMapResult = {\n    target: target,\n    extraOptions: {},\n  };\n  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = splitHostPort(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace(\n        'Not using proxy for target in no_proxy list: ' + uriToString(target)\n      );\n      return noProxyResult;\n    }\n  }\n  const extraOptions: ChannelOptions = {\n    'grpc.http_connect_target': uriToString(target),\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address,\n    },\n    extraOptions: extraOptions,\n  };\n}\n\nexport interface ProxyConnectionResult {\n  socket?: Socket;\n  realTarget?: GrpcUri;\n}\n\nexport function getProxiedConnection(\n  address: SubchannelAddress,\n  channelOptions: ChannelOptions,\n  connectionOptions: tls.ConnectionOptions\n): Promise<ProxyConnectionResult> {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'] as string;\n  const parsedTarget = parseUri(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const splitHostPost = splitHostPort(parsedTarget.path);\n  if (splitHostPost === null) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const hostPort = `${splitHostPost.host}:${\n    splitHostPost.port ?? DEFAULT_PORT\n  }`;\n  const options: http.RequestOptions = {\n    method: 'CONNECT',\n    path: hostPort,\n  };\n  const headers: http.OutgoingHttpHeaders = {\n    Host: hostPort,\n  };\n  // Connect to the subchannel address as a proxy\n  if (isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] =\n      'Basic ' +\n      Buffer.from(channelOptions['grpc.http_connect_creds'] as string).toString(\n        'base64'\n      );\n  }\n  options.headers = headers;\n  const proxyAddressString = subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise<ProxyConnectionResult>((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace(\n          'Successfully connected to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString\n        );\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = getDefaultAuthority(parsedTarget);\n          const hostPort = splitHostPort(targetPath);\n          const remoteHost = hostPort?.host ?? targetPath;\n\n          const cts = tls.connect(\n            {\n              host: remoteHost,\n              servername: remoteHost,\n              socket: socket,\n              ...connectionOptions,\n            },\n            () => {\n              trace(\n                'Successfully established a TLS connection to ' +\n                  options.path +\n                  ' through proxy ' +\n                  proxyAddressString\n              );\n              resolve({ socket: cts, realTarget: parsedTarget });\n            }\n          );\n          cts.on('error', (error: Error) => {\n            trace(\n              'Failed to establish a TLS connection to ' +\n                options.path +\n                ' through proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                error.message\n            );\n            reject();\n          });\n        } else {\n          trace(\n            'Successfully established a plaintext connection to ' +\n              options.path +\n              ' through proxy ' +\n              proxyAddressString\n          );\n          resolve({\n            socket,\n            realTarget: parsedTarget,\n          });\n        }\n      } else {\n        log(\n          LogVerbosity.ERROR,\n          'Failed to connect to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString +\n            ' with status ' +\n            res.statusCode\n        );\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      log(\n        LogVerbosity.ERROR,\n        'Failed to connect to proxy ' +\n          proxyAddressString +\n          ' with error ' +\n          err.message\n      );\n      reject();\n    });\n    request.end();\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5125, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/stream-decoder.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nenum ReadState {\n  NO_DATA,\n  READING_SIZE,\n  READING_MESSAGE,\n}\n\nexport class StreamDecoder {\n  private readState: ReadState = ReadState.NO_DATA;\n  private readCompressFlag: Buffer = Buffer.alloc(1);\n  private readPartialSize: Buffer = Buffer.alloc(4);\n  private readSizeRemaining = 4;\n  private readMessageSize = 0;\n  private readPartialMessage: Buffer[] = [];\n  private readMessageRemaining = 0;\n\n  constructor(private maxReadMessageLength: number) {}\n\n  write(data: Buffer): Buffer[] {\n    let readHead = 0;\n    let toRead: number;\n    const result: Buffer[] = [];\n\n    while (readHead < data.length) {\n      switch (this.readState) {\n        case ReadState.NO_DATA:\n          this.readCompressFlag = data.slice(readHead, readHead + 1);\n          readHead += 1;\n          this.readState = ReadState.READING_SIZE;\n          this.readPartialSize.fill(0);\n          this.readSizeRemaining = 4;\n          this.readMessageSize = 0;\n          this.readMessageRemaining = 0;\n          this.readPartialMessage = [];\n          break;\n        case ReadState.READING_SIZE:\n          toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n          data.copy(\n            this.readPartialSize,\n            4 - this.readSizeRemaining,\n            readHead,\n            readHead + toRead\n          );\n          this.readSizeRemaining -= toRead;\n          readHead += toRead;\n          // readSizeRemaining >=0 here\n          if (this.readSizeRemaining === 0) {\n            this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n            if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\n              throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\n            }\n            this.readMessageRemaining = this.readMessageSize;\n            if (this.readMessageRemaining > 0) {\n              this.readState = ReadState.READING_MESSAGE;\n            } else {\n              const message = Buffer.concat(\n                [this.readCompressFlag, this.readPartialSize],\n                5\n              );\n\n              this.readState = ReadState.NO_DATA;\n              result.push(message);\n            }\n          }\n          break;\n        case ReadState.READING_MESSAGE:\n          toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n          this.readMessageRemaining -= toRead;\n          readHead += toRead;\n          // readMessageRemaining >=0 here\n          if (this.readMessageRemaining === 0) {\n            // At this point, we have read a full message\n            const framedMessageBuffers = [\n              this.readCompressFlag,\n              this.readPartialSize,\n            ].concat(this.readPartialMessage);\n            const framedMessage = Buffer.concat(\n              framedMessageBuffers,\n              this.readMessageSize + 5\n            );\n\n            this.readState = ReadState.NO_DATA;\n            result.push(framedMessage);\n          }\n          break;\n        default:\n          throw new Error('Unexpected read state');\n      }\n    }\n\n    return result;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5227, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5231, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/subchannel-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as os from 'os';\n\nimport { DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH, Status } from './constants';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n  WriteCallback,\n} from './call-interface';\nimport { CallEventTracker, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel_call';\n\n/**\n * https://nodejs.org/api/errors.html#errors_class_systemerror\n */\ninterface SystemError extends Error {\n  address?: string;\n  code: string;\n  dest?: string;\n  errno: number;\n  info?: object;\n  message: string;\n  path?: string;\n  port?: number;\n  syscall: string;\n}\n\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno: number): string {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\n\nexport interface SubchannelCall {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  sendMessageWithContext(context: MessageContext, message: Buffer): void;\n  startRead(): void;\n  halfClose(): void;\n  getCallNumber(): number;\n}\n\nexport interface StatusObjectWithRstCode extends StatusObject {\n  rstCode?: number;\n}\n\nexport interface SubchannelCallInterceptingListener\n  extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithRstCode): void;\n}\n\nexport class Http2SubchannelCall implements SubchannelCall {\n  private decoder: StreamDecoder;\n\n  private isReadFilterPending = false;\n  private isPushPending = false;\n  private canPush = false;\n  /**\n   * Indicates that an 'end' event has come from the http2 stream, so there\n   * will be no more data events.\n   */\n  private readsClosed = false;\n\n  private statusOutput = false;\n\n  private unpushedReadMessages: Buffer[] = [];\n\n  // Status code mapped from :status. To be used if grpc-status is not received\n  private mappedStatusCode: Status = Status.UNKNOWN;\n\n  // This is populated (non-null) if and only if the call has ended\n  private finalStatus: StatusObject | null = null;\n\n  private internalError: SystemError | null = null;\n\n  constructor(\n    private readonly http2Stream: http2.ClientHttp2Stream,\n    private readonly callEventTracker: CallEventTracker,\n    private readonly listener: SubchannelCallInterceptingListener,\n    private readonly transport: Transport,\n    private readonly callId: number\n  ) {\n    const maxReceiveMessageLength = transport.getOptions()['grpc.max_receive_message_length'] ?? DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.decoder = new StreamDecoder(maxReceiveMessageLength);\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      switch (headers[':status']) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n          this.mappedStatusCode = Status.INTERNAL;\n          break;\n        case 401:\n          this.mappedStatusCode = Status.UNAUTHENTICATED;\n          break;\n        case 403:\n          this.mappedStatusCode = Status.PERMISSION_DENIED;\n          break;\n        case 404:\n          this.mappedStatusCode = Status.UNIMPLEMENTED;\n          break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n          this.mappedStatusCode = Status.UNAVAILABLE;\n          break;\n        default:\n          this.mappedStatusCode = Status.UNKNOWN;\n      }\n\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata: Metadata;\n        try {\n          metadata = Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: Status.UNKNOWN,\n            details: (error as Error).message,\n            metadata: new Metadata(),\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', (headers: http2.IncomingHttpHeaders) => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', (data: Buffer) => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      let messages: Buffer[];\n      try {\n        messages = this.decoder.write(data);\n      } catch (e) {\n        this.cancelWithStatus(Status.RESOURCE_EXHAUSTED, (e as Error).message);\n        return;\n      }\n\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker!.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (this.finalStatus?.code === Status.OK) {\n          return;\n        }\n        let code: Status;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (\n                this.internalError.code === 'ECONNRESET' ||\n                this.internalError.code === 'ETIMEDOUT'\n              ) {\n                code = Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new Metadata(),\n          rstCode: http2Stream.rstCode,\n        });\n      });\n    });\n    http2Stream.on('error', (err: SystemError) => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace(\n          'Node error event: message=' +\n            err.message +\n            ' code=' +\n            err.code +\n            ' errno=' +\n            getSystemErrorName(err.errno) +\n            ' syscall=' +\n            err.syscall\n        );\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n\n  public onDisconnect() {\n    this.endCall({\n      code: Status.UNAVAILABLE,\n      details: 'Connection dropped',\n      metadata: new Metadata(),\n    });\n  }\n\n  private outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace(\n        'ended with status: code=' +\n          this.finalStatus!.code +\n          ' details=\"' +\n          this.finalStatus!.details +\n          '\"'\n      );\n      this.callEventTracker.onCallEnd(this.finalStatus!);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus!);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callId + '] ' + text\n    );\n  }\n\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  private endCall(status: StatusObjectWithRstCode): void {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n\n  private maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (\n        this.finalStatus.code !== Status.OK ||\n        (this.readsClosed &&\n          this.unpushedReadMessages.length === 0 &&\n          !this.isReadFilterPending &&\n          !this.isPushPending)\n      ) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  private push(message: Buffer): void {\n    this.trace(\n      'pushing to reader message of length ' +\n        (message instanceof Buffer ? message.length : null)\n    );\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  private tryPush(messageBytes: Buffer): void {\n    if (this.canPush) {\n      this.http2Stream!.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace(\n        'unpushedReadMessages.push message of length ' + messageBytes.length\n      );\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n\n  private handleTrailers(headers: http2.IncomingHttpHeaders) {\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata: Metadata;\n    try {\n      metadata = Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code: Status = this.mappedStatusCode;\n    if (\n      code === Status.UNKNOWN &&\n      typeof metadataMap['grpc-status'] === 'string'\n    ) {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace(\n        'received status details string \"' + details + '\" from server'\n      );\n    }\n    const status: StatusObject = { code, details, metadata };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n\n  private destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (!this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code: number;\n      if (this.finalStatus?.code === Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.endCall({ code: status, details, metadata: new Metadata() });\n  }\n\n  getStatus(): StatusObject | null {\n    return this.finalStatus;\n  }\n\n  getPeer(): string {\n    return this.transport.getPeerName();\n  }\n\n  getCallNumber(): number {\n    return this.callId;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage: Buffer = this.unpushedReadMessages.shift()!;\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n     * messages to emit */\n    this.http2Stream.resume();\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb: WriteCallback = (error?: Error | null) => {\n      /* nextTick here ensures that no stream action can be taken in the call\n       * stack of the write callback, in order to hopefully work around\n       * https://github.com/nodejs/node/issues/49147 */\n      process.nextTick(() => {\n        let code: Status = Status.UNAVAILABLE;\n        if (\n          (error as NodeJS.ErrnoException)?.code ===\n          'ERR_STREAM_WRITE_AFTER_END'\n        ) {\n          code = Status.INTERNAL;\n        }\n        if (error) {\n          this.cancelWithStatus(code, `Write error: ${error.message}`);\n        }\n        context.callback?.();\n      });\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream!.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: Status.UNAVAILABLE,\n        details: `Write failed with error ${(error as Error).message}`,\n        metadata: new Metadata(),\n      });\n    }\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5659, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5663, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/call-number.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nlet nextCallNumber = 0;\n\nexport function getNextCallNumber() {\n  return nextCallNumber++;\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,IAAI,iBAAiB;AAErB,SAAgB;IACd,OAAO;AACT;AAFA,QAAA,iBAAA,GAAA"}},
    {"offset": {"line": 5688, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5692, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/transport.ts"],"sourcesContent":["/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport {\n  checkServerIdentity,\n  CipherNameAndProtocol,\n  ConnectionOptions,\n  PeerCertificate,\n  TLSSocket,\n} from 'tls';\nimport { StatusObject } from './call-interface';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  ChannelzCallTracker,\n  registerChannelzSocket,\n  SocketInfo,\n  SocketRef,\n  TlsInfo,\n  unregisterChannelzRef,\n} from './channelz';\nimport { LogVerbosity } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as logging from './logging';\nimport { getDefaultAuthority } from './resolver';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport * as net from 'net';\nimport {\n  Http2SubchannelCall,\n  SubchannelCall,\n  SubchannelCallInterceptingListener,\n} from './subchannel-call';\nimport { Metadata } from './metadata';\nimport { getNextCallNumber } from './call-number';\n\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\n\nconst clientVersion = require('../../package.json').version;\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface CallEventTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n  onCallEnd(status: StatusObject): void;\n  onStreamEnd(success: boolean): void;\n}\n\nexport interface TransportDisconnectListener {\n  (tooManyPings: boolean): void;\n}\n\nexport interface Transport {\n  getChannelzRef(): SocketRef;\n  getPeerName(): string;\n  getOptions(): ChannelOptions;\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): SubchannelCall;\n  addDisconnectListener(listener: TransportDisconnectListener): void;\n  shutdown(): void;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nclass Http2Transport implements Transport {\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs = -1;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveTimerId: NodeJS.Timeout | null = null;\n  /**\n   * Indicates that the keepalive timer ran out while there were no active\n   * calls, and a ping should be sent the next time a call starts.\n   */\n  private pendingSendKeepalivePing = false;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timeout | null = null;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  private userAgent: string;\n\n  private activeCalls: Set<Http2SubchannelCall> = new Set();\n\n  private subchannelAddressString: string;\n\n  private disconnectListeners: TransportDisconnectListener[] = [];\n\n  private disconnectHandled = false;\n\n  // Channelz info\n  private channelzRef: SocketRef;\n  private readonly channelzEnabled: boolean = true;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  constructor(\n    private session: http2.ClientHttp2Session,\n    subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    private remoteName: string | null\n  ) {\n    /* Populate subchannelAddressString and channelzRef before doing anything\n     * else, because they are used in the trace methods. */\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = registerChannelzSocket(\n      this.subchannelAddressString,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter(e => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n\n    session.once('close', () => {\n      this.trace('session closed');\n      this.stopKeepalivePings();\n      this.handleDisconnect();\n    });\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => {\n        let tooManyPings = false;\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (\n          errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n          opaqueData &&\n          opaqueData.equals(tooManyPingsData)\n        ) {\n          tooManyPings = true;\n        }\n        this.trace('connection closed by GOAWAY with code ' + errorCode + ' and data ' + opaqueData?.toString());\n        this.reportDisconnectToOwner(tooManyPings);\n      }\n    );\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + (error as Error).message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n    /* Start the keepalive timer last, because this can trigger trace logs,\n     * which should only happen after everything else is set up. */\n    if (this.keepaliveWithoutCalls) {\n      this.maybeStartKeepalivePingTimer();\n    }\n  }\n\n  private getChannelzInfo(): SocketInfo {\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.remoteAddress,\n          sessionSocket.remotePort\n        )\n      : null;\n    const localAddress = sessionSocket.localAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.localAddress,\n          sessionSocket.localPort\n        )\n      : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =\n        tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate:\n          certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate:\n          peerCertificate && 'raw' in peerCertificate\n            ? peerCertificate.raw\n            : null,\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp:\n        this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null,\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      FLOW_CONTROL_TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'transport_internals',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  private reportDisconnectToOwner(tooManyPings: boolean) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  private handleDisconnect() {\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n    });\n  }\n\n  addDisconnectListener(listener: TransportDisconnectListener): void {\n    this.disconnectListeners.push(listener);\n  }\n\n  private clearKeepaliveTimer() {\n    if (!this.keepaliveTimerId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimerId);\n    this.keepaliveTimerId = null;\n  }\n\n  private clearKeepaliveTimeout() {\n    if (!this.keepaliveTimeoutId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimeoutId);\n    this.keepaliveTimeoutId = null;\n  }\n\n  private canSendPing() {\n    return (\n      this.keepaliveTimeMs > 0 &&\n      (this.keepaliveWithoutCalls || this.activeCalls.size > 0)\n    );\n  }\n\n  private maybeSendPing() {\n    this.clearKeepaliveTimer();\n    if (!this.canSendPing()) {\n      this.pendingSendKeepalivePing = true;\n      return;\n    }\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace(\n      'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n    );\n    if (!this.keepaliveTimeoutId) {\n      this.keepaliveTimeoutId = setTimeout(() => {\n        this.keepaliveTrace('Ping timeout passed without response');\n        this.handleDisconnect();\n      }, this.keepaliveTimeoutMs);\n      this.keepaliveTimeoutId.unref?.();\n    }\n    try {\n      this.session!.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          if (err) {\n            this.keepaliveTrace('Ping failed with error ' + err.message);\n            this.handleDisconnect();\n          }\n          this.keepaliveTrace('Received ping response');\n          this.clearKeepaliveTimeout();\n          this.maybeStartKeepalivePingTimer();\n        }\n      );\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.handleDisconnect();\n    }\n  }\n\n  /**\n   * Starts the keepalive ping timer if appropriate. If the timer already ran\n   * out while there were no active requests, instead send a ping immediately.\n   * If the ping timer is already running or a ping is currently in flight,\n   * instead do nothing and wait for them to resolve.\n   */\n  private maybeStartKeepalivePingTimer() {\n    if (!this.canSendPing()) {\n      return;\n    }\n    if (this.pendingSendKeepalivePing) {\n      this.pendingSendKeepalivePing = false;\n      this.maybeSendPing();\n    } else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\n      this.keepaliveTrace(\n        'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n      );\n      this.keepaliveTimerId = setTimeout(() => {\n        this.maybeSendPing();\n      }, this.keepaliveTimeMs).unref?.();\n    }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n     * wait for those to resolve. */\n  }\n\n  private stopKeepalivePings() {\n    if (this.keepaliveTimerId) {\n      clearTimeout(this.keepaliveTimerId);\n      this.keepaliveTimerId = null;\n    }\n    this.clearKeepaliveTimeout();\n  }\n\n  private removeActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n    }\n  }\n\n  private addActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.add(call);\n    if (this.activeCalls.size === 1) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.maybeStartKeepalivePingTimer();\n      }\n    }\n  }\n\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): Http2SubchannelCall {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session.state.localWindowSize +\n        ' remote window size: ' +\n        this.session.state.remoteWindowSize\n    );\n    this.internalsTrace(\n      'session.closed=' +\n        this.session.closed +\n        ' session.destroyed=' +\n        this.session.destroyed +\n        ' session.socket.destroyed=' +\n        this.session.socket.destroyed\n    );\n    let eventTracker: CallEventTracker;\n    // eslint-disable-next-line prefer-const\n    let call: Http2SubchannelCall;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    }\n    call = new Http2SubchannelCall(\n      http2Stream,\n      eventTracker,\n      listener,\n      this,\n      getNextCallNumber()\n    );\n    this.addActiveCall(call);\n    return call;\n  }\n\n  getChannelzRef(): SocketRef {\n    return this.channelzRef;\n  }\n\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  shutdown() {\n    this.session.close();\n    unregisterChannelzRef(this.channelzRef);\n  }\n}\n\nexport interface SubchannelConnector {\n  connect(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ): Promise<Transport>;\n  shutdown(): void;\n}\n\nexport class Http2SubchannelConnector implements SubchannelConnector {\n  private session: http2.ClientHttp2Session | null = null;\n  private isShutdown = false;\n  constructor(private channelTarget: GrpcUri) {}\n  private trace(text: string) {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      uriToString(this.channelTarget) + ' ' + text\n    );\n  }\n  private createSession(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions,\n    proxyConnectionResult: ProxyConnectionResult\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise<Http2Transport>((resolve, reject) => {\n      let remoteName: string | null;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = uriToString(proxyConnectionResult.realTarget);\n        this.trace(\n          'creating HTTP/2 session through proxy to ' +\n            uriToString(proxyConnectionResult.realTarget)\n        );\n      } else {\n        remoteName = null;\n        this.trace(\n          'creating HTTP/2 session to ' + subchannelAddressToString(address)\n        );\n      }\n      const targetAuthority = getDefaultAuthority(\n        proxyConnectionResult.realTarget ?? this.channelTarget\n      );\n      let connectionOptions: http2.SecureClientSessionOptions =\n        credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory =\n          options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride =\n            options['grpc.ssl_target_name_override']!;\n          connectionOptions.checkServerIdentity = (\n            host: string,\n            cert: PeerCertificate\n          ): Error | undefined => {\n            return checkServerIdentity(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname =\n            splitHostPort(targetAuthority)?.host ?? 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket!;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n\n      connectionOptions = {\n        ...connectionOptions,\n        ...address,\n        enableTrace: options['grpc-node.tls_enable_trace'] === 1,\n      };\n\n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(\n        addressScheme + targetAuthority,\n        connectionOptions\n      );\n      this.session = session;\n      let errorMessage = 'Failed to connect';\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options, remoteName));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        // Leave time for error event to happen before rejecting\n        setImmediate(() => {\n          reject(`${errorMessage} (${new Date().toISOString()})`);\n        });\n      });\n      session.once('error', error => {\n        errorMessage = (error as Error).message;\n        this.trace('connection failed with error ' + errorMessage);\n      });\n    });\n  }\n  connect(\n    address: SubchannelAddress,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override']!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n      if (options['grpc-node.tls_enable_trace']) {\n        connectionOptions.enableTrace = true;\n      }\n    }\n\n    return getProxiedConnection(address, options, connectionOptions).then(\n      result => this.createSession(address, credentials, options, result)\n    );\n  }\n\n  shutdown(): void {\n    this.isShutdown = true;\n    this.session?.close();\n    this.session = null;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6253, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6257, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/subchannel-pool.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions, channelOptionsEqual } from './channel-options';\nimport { Subchannel } from './subchannel';\nimport {\n  SubchannelAddress,\n  subchannelAddressEqual,\n} from './subchannel-address';\nimport { ChannelCredentials } from './channel-credentials';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { Http2SubchannelConnector } from './transport';\n\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10_000;\n\nexport class SubchannelPool {\n  private pool: {\n    [channelTarget: string]: Array<{\n      subchannelAddress: SubchannelAddress;\n      channelArguments: ChannelOptions;\n      channelCredentials: ChannelCredentials;\n      subchannel: Subchannel;\n    }>;\n  } = Object.create(null);\n\n  /**\n   * A timer of a task performing a periodic subchannel cleanup.\n   */\n  private cleanupTimer: NodeJS.Timeout | null = null;\n\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   */\n  constructor() {}\n\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n  unrefUnusedSubchannels(): void {\n    let allSubchannelsUnrefed = true;\n\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n\n      const refedSubchannels = subchannelObjArray.filter(\n        value => !value.subchannel.unrefIfOneRef()\n      );\n\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n\n    // Cancel the cleanup task if all subchannels have been unrefed.\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n  ensureCleanupTask(): void {\n    if (this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL);\n\n      // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n      this.cleanupTimer.unref?.();\n    }\n  }\n\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n  getOrCreateSubchannel(\n    channelTargetUri: GrpcUri,\n    subchannelTarget: SubchannelAddress,\n    channelArguments: ChannelOptions,\n    channelCredentials: ChannelCredentials\n  ): Subchannel {\n    this.ensureCleanupTask();\n    const channelTarget = uriToString(channelTargetUri);\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      for (const subchannelObj of subchannelObjArray) {\n        if (\n          subchannelAddressEqual(\n            subchannelTarget,\n            subchannelObj.subchannelAddress\n          ) &&\n          channelOptionsEqual(\n            channelArguments,\n            subchannelObj.channelArguments\n          ) &&\n          channelCredentials._equals(subchannelObj.channelCredentials)\n        ) {\n          return subchannelObj.subchannel;\n        }\n      }\n    }\n    // If we get here, no matching subchannel was found\n    const subchannel = new Subchannel(\n      channelTargetUri,\n      subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      new Http2SubchannelConnector(channelTargetUri)\n    );\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel,\n    });\n    subchannel.ref();\n    return subchannel;\n  }\n}\n\nconst globalSubchannelPool = new SubchannelPool();\n\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nexport function getSubchannelPool(global: boolean): SubchannelPool {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool();\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,MAAA;AACA,MAAA;AACA,MAAA;AAKA,MAAA;AACA,MAAA;AAEA,uDAAuD;AACvD;;;IAIA,MAAM,qBAAqB;AAE3B,MAAa;IAeX;;;QAIA,aAAA;QAlBQ,IAAA,CAAA,IAAI,GAOR,OAAO,MAAM,CAAC;QAElB;;YAGQ,IAAA,CAAA,YAAY,GAA0B;IAM/B;IAEf;;;QAIA,yBAAsB;QACpB,IAAI,wBAAwB;QAE5B;;yCAGA,yCAAyC;QACzC,IAAK,MAAM,iBAAiB,IAAI,CAAC,IAAI,CAAE;YACrC,MAAM,qBAAqB,IAAI,CAAC,IAAI,CAAC,cAAc;YAEnD,MAAM,mBAAmB,mBAAmB,MAAM,CAChD,CAAA,QAAS,CAAC,MAAM,UAAU,CAAC,aAAa;YAG1C,IAAI,iBAAiB,MAAM,GAAG,GAAG;gBAC/B,wBAAwB;YAC1B;YAEA;;mEAGA,IAAI,CAAC,IAAI,CAAC,cAAc,GAAG;QAC7B;QACA;+DAGA,gEAAgE;QAChE,IAAI,yBAAyB,IAAI,CAAC,YAAY,KAAK,MAAM;YACvD,cAAc,IAAI,CAAC,YAAY;YAC/B,IAAI,CAAC,YAAY,GAAG;QACtB;IACF;IAEA;;QAGA,oBAAiB;;QACf,IAAI,IAAI,CAAC,YAAY,KAAK,MAAM;YAC9B,IAAI,CAAC,YAAY,GAAG,YAAY;gBAC9B,IAAI,CAAC,sBAAsB;YAC7B,GAAG;YAEH,mEAAmE;YACnE,kEAAkE;YAClE,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,YAAY,EAAC,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAA,IAAA,CAAA;QACzB;IACF;IAEA;;;;;;;QAQA,sBACE,gBAAyB,EACzB,gBAAmC,EACnC,gBAAgC,EAChC,kBAAsC,EAAA;QAEtC,IAAI,CAAC,iBAAiB;QACtB,MAAM,gBAAgB,CAAA,GAAA,aAAA,WAAW,EAAC;QAClC,IAAI,iBAAiB,IAAI,CAAC,IAAI,EAAE;YAC9B,MAAM,qBAAqB,IAAI,CAAC,IAAI,CAAC,cAAc;YACnD,KAAK,MAAM,iBAAiB,mBAAoB;gBAC9C,IACE,CAAA,GAAA,qBAAA,sBAAsB,EACpB,kBACA,cAAc,iBAAiB,KAEjC,CAAA,GAAA,kBAAA,mBAAmB,EACjB,kBACA,cAAc,gBAAgB,KAEhC,mBAAmB,OAAO,CAAC,cAAc,kBAAkB,GAC3D;oBACA,OAAO,cAAc,UAAU;gBACjC;YACF;QACF;QACA,mDAAmD;QACnD,MAAM,aAAa,IAAI,aAAA,UAAU,CAC/B,kBACA,kBACA,kBACA,oBACA,IAAI,YAAA,wBAAwB,CAAC;QAE/B,IAAI,CAAC,CAAC,iBAAiB,IAAI,CAAC,IAAI,GAAG;YACjC,IAAI,CAAC,IAAI,CAAC,cAAc,GAAG,EAAE;QAC/B;QACA,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC;YAC5B,mBAAmB;YACnB;YACA;YACA;;QAEF,WAAW,GAAG;QACd,OAAO;IACT;;AA9HF,QAAA,cAAA,GAAA;AAiIA,MAAM,uBAAuB,IAAI;AAEjC;;;IAIA,SAAgB,kBAAkB,MAAe;IAC/C,IAAI,QAAQ;QACV,OAAO;IACT,OAAO;QACL,OAAO,IAAI;IACb;AACF;AANA,QAAA,iBAAA,GAAA"}},
    {"offset": {"line": 6381, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6385, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/filter-stack.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { StatusObject, WriteObject } from './call-interface';\nimport { Filter, FilterFactory } from './filter';\nimport { Metadata } from './metadata';\n\nexport class FilterStack implements Filter {\n  constructor(private readonly filters: Filter[]) {}\n\n  sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {\n    let result: Promise<Metadata> = metadata;\n\n    for (let i = 0; i < this.filters.length; i++) {\n      result = this.filters[i].sendMetadata(result);\n    }\n\n    return result;\n  }\n\n  receiveMetadata(metadata: Metadata) {\n    let result: Metadata = metadata;\n\n    for (let i = this.filters.length - 1; i >= 0; i--) {\n      result = this.filters[i].receiveMetadata(result);\n    }\n\n    return result;\n  }\n\n  sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {\n    let result: Promise<WriteObject> = message;\n\n    for (let i = 0; i < this.filters.length; i++) {\n      result = this.filters[i].sendMessage(result);\n    }\n\n    return result;\n  }\n\n  receiveMessage(message: Promise<Buffer>): Promise<Buffer> {\n    let result: Promise<Buffer> = message;\n\n    for (let i = this.filters.length - 1; i >= 0; i--) {\n      result = this.filters[i].receiveMessage(result);\n    }\n\n    return result;\n  }\n\n  receiveTrailers(status: StatusObject): StatusObject {\n    let result: StatusObject = status;\n\n    for (let i = this.filters.length - 1; i >= 0; i--) {\n      result = this.filters[i].receiveTrailers(result);\n    }\n\n    return result;\n  }\n\n  push(filters: Filter[]) {\n    this.filters.unshift(...filters);\n  }\n\n  getFilters(): Filter[] {\n    return this.filters;\n  }\n}\n\nexport class FilterStackFactory implements FilterFactory<FilterStack> {\n  constructor(private readonly factories: Array<FilterFactory<Filter>>) {}\n\n  push(filterFactories: FilterFactory<Filter>[]) {\n    this.factories.unshift(...filterFactories);\n  }\n\n  clone(): FilterStackFactory {\n    return new FilterStackFactory([...this.factories]);\n  }\n\n  createFilter(): FilterStack {\n    return new FilterStack(\n      this.factories.map(factory => factory.createFilter())\n    );\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAqBA,MAAa;IACX,YAA6B,OAAiB,CAAA;QAAjB,IAAA,CAAA,OAAO,GAAP;IAAoB;IAEjD,aAAa,QAA2B,EAAA;QACtC,IAAI,SAA4B;QAEhC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAK;YAC5C,SAAS,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,YAAY,CAAC;QACxC;QAEA,OAAO;IACT;IAEA,gBAAgB,QAAkB,EAAA;QAChC,IAAI,SAAmB;QAEvB,IAAK,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;YACjD,SAAS,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,eAAe,CAAC;QAC3C;QAEA,OAAO;IACT;IAEA,YAAY,OAA6B,EAAA;QACvC,IAAI,SAA+B;QAEnC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAK;YAC5C,SAAS,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,WAAW,CAAC;QACvC;QAEA,OAAO;IACT;IAEA,eAAe,OAAwB,EAAA;QACrC,IAAI,SAA0B;QAE9B,IAAK,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;YACjD,SAAS,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,cAAc,CAAC;QAC1C;QAEA,OAAO;IACT;IAEA,gBAAgB,MAAoB,EAAA;QAClC,IAAI,SAAuB;QAE3B,IAAK,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;YACjD,SAAS,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,eAAe,CAAC;QAC3C;QAEA,OAAO;IACT;IAEA,KAAK,OAAiB,EAAA;QACpB,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI;IAC1B;IAEA,aAAU;QACR,OAAO,IAAI,CAAC,OAAO;IACrB;;AA3DF,QAAA,WAAA,GAAA;AA8DA,MAAa;IACX,YAA6B,SAAuC,CAAA;QAAvC,IAAA,CAAA,SAAS,GAAT;IAA0C;IAEvE,KAAK,eAAwC,EAAA;QAC3C,IAAI,CAAC,SAAS,CAAC,OAAO,IAAI;IAC5B;IAEA,QAAK;QACH,OAAO,IAAI,mBAAmB;eAAI,IAAI,CAAC,SAAS;SAAC;IACnD;IAEA,eAAY;QACV,OAAO,IAAI,YACT,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAA,UAAW,QAAQ,YAAY;IAEtD;;AAfF,QAAA,kBAAA,GAAA"}},
    {"offset": {"line": 6469, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6473, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/compression-algorithms.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexport enum CompressionAlgorithms {\n  identity = 0,\n  deflate = 1,\n  gzip = 2,\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,IAAY;AAAZ,CAAA,SAAY,qBAAqB;IAC/B,qBAAA,CAAA,qBAAA,CAAA,WAAA,GAAA,EAAA,GAAA;IACA,qBAAA,CAAA,qBAAA,CAAA,UAAA,GAAA,EAAA,GAAA;IACA,qBAAA,CAAA,qBAAA,CAAA,OAAA,GAAA,EAAA,GAAA;AACF,CAAC,EAJW,yBAAqB,CAAA,QAAA,qBAAA,GAArB,wBAAqB,CAAA,CAAA"}},
    {"offset": {"line": 6499, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6503, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/filter.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { StatusObject, WriteObject } from './call-interface';\nimport { Metadata } from './metadata';\n\n/**\n * Filter classes represent related per-call logic and state that is primarily\n * used to modify incoming and outgoing data. All async filters can be\n * rejected. The rejection error must be a StatusObject, and a rejection will\n * cause the call to end with that status.\n */\nexport interface Filter {\n  sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;\n\n  receiveMetadata(metadata: Metadata): Metadata;\n\n  sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;\n\n  receiveMessage(message: Promise<Buffer>): Promise<Buffer>;\n\n  receiveTrailers(status: StatusObject): StatusObject;\n}\n\nexport abstract class BaseFilter implements Filter {\n  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {\n    return metadata;\n  }\n\n  receiveMetadata(metadata: Metadata): Metadata {\n    return metadata;\n  }\n\n  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {\n    return message;\n  }\n\n  async receiveMessage(message: Promise<Buffer>): Promise<Buffer> {\n    return message;\n  }\n\n  receiveTrailers(status: StatusObject): StatusObject {\n    return status;\n  }\n}\n\nexport interface FilterFactory<T extends Filter> {\n  createFilter(): T;\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAsCA,MAAsB;IACpB,MAAM,aAAa,QAA2B,EAAA;QAC5C,OAAO;IACT;IAEA,gBAAgB,QAAkB,EAAA;QAChC,OAAO;IACT;IAEA,MAAM,YAAY,OAA6B,EAAA;QAC7C,OAAO;IACT;IAEA,MAAM,eAAe,OAAwB,EAAA;QAC3C,OAAO;IACT;IAEA,gBAAgB,MAAoB,EAAA;QAClC,OAAO;IACT;;AAnBF,QAAA,UAAA,GAAA"}},
    {"offset": {"line": 6541, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6545, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/compression-filter.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as zlib from 'zlib';\n\nimport { WriteObject, WriteFlags } from './call-interface';\nimport { Channel } from './channel';\nimport { ChannelOptions } from './channel-options';\nimport { CompressionAlgorithms } from './compression-algorithms';\nimport { DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH, LogVerbosity, Status } from './constants';\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport * as logging from './logging';\nimport { Metadata, MetadataValue } from './metadata';\n\nconst isCompressionAlgorithmKey = (\n  key: number\n): key is CompressionAlgorithms => {\n  return (\n    typeof key === 'number' && typeof CompressionAlgorithms[key] === 'string'\n  );\n};\n\ntype CompressionAlgorithm = keyof typeof CompressionAlgorithms;\n\ntype SharedCompressionFilterConfig = {\n  serverSupportedEncodingHeader?: string;\n};\n\nabstract class CompressionHandler {\n  protected abstract compressMessage(message: Buffer): Promise<Buffer>;\n  protected abstract decompressMessage(data: Buffer): Promise<Buffer>;\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {\n    let messageBuffer = message;\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n  async readMessage(data: Buffer): Promise<Buffer> {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n    return messageBuffer;\n  }\n}\n\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message: Buffer) {\n    return message;\n  }\n\n  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n\n  decompressMessage(message: Buffer): Promise<Buffer> {\n    return Promise.reject<Buffer>(\n      new Error(\n        'Received compressed message but \"grpc-encoding\" header was identity'\n      )\n    );\n  }\n}\n\nclass DeflateHandler extends CompressionHandler {\n  constructor(private maxRecvMessageLength: number) {\n    super();\n  }\n\n  compressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      let totalLength = 0;\n      const messageParts: Buffer[] = [];\n      const decompresser = zlib.createInflate();\n      decompresser.on('data', (chunk: Buffer) => {\n        messageParts.push(chunk);\n        totalLength += chunk.byteLength;\n        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n          decompresser.destroy();\n          reject({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n          });\n        }\n      });\n      decompresser.on('end', () => {\n        resolve(Buffer.concat(messageParts));\n      });\n      decompresser.write(message);\n      decompresser.end();\n    });\n  }\n}\n\nclass GzipHandler extends CompressionHandler {\n  constructor(private maxRecvMessageLength: number) {\n    super();\n  }\n\n  compressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      let totalLength = 0;\n      const messageParts: Buffer[] = [];\n      const decompresser = zlib.createGunzip();\n      decompresser.on('data', (chunk: Buffer) => {\n        messageParts.push(chunk);\n        totalLength += chunk.byteLength;\n        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n          decompresser.destroy();\n          reject({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n          });\n        }\n      });\n      decompresser.on('end', () => {\n        resolve(Buffer.concat(messageParts));\n      });\n      decompresser.write(message);\n      decompresser.end();\n    });\n  }\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(private readonly compressionName: string) {\n    super();\n  }\n  compressMessage(message: Buffer): Promise<Buffer> {\n    return Promise.reject<Buffer>(\n      new Error(\n        `Received message compressed with unsupported compression method ${this.compressionName}`\n      )\n    );\n  }\n\n  decompressMessage(message: Buffer): Promise<Buffer> {\n    // This should be unreachable\n    return Promise.reject<Buffer>(\n      new Error(`Compression method not supported: ${this.compressionName}`)\n    );\n  }\n}\n\nfunction getCompressionHandler(compressionName: string, maxReceiveMessageSize: number): CompressionHandler {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n    case 'deflate':\n      return new DeflateHandler(maxReceiveMessageSize);\n    case 'gzip':\n      return new GzipHandler(maxReceiveMessageSize);\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nexport class CompressionFilter extends BaseFilter implements Filter {\n  private sendCompression: CompressionHandler = new IdentityHandler();\n  private receiveCompression: CompressionHandler = new IdentityHandler();\n  private currentCompressionAlgorithm: CompressionAlgorithm = 'identity';\n  private maxReceiveMessageLength: number;\n\n  constructor(\n    channelOptions: ChannelOptions,\n    private sharedFilterConfig: SharedCompressionFilterConfig\n  ) {\n    super();\n\n    const compressionAlgorithmKey =\n      channelOptions['grpc.default_compression_algorithm'];\n    this.maxReceiveMessageLength = channelOptions['grpc.max_receive_message_length'] ?? DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH\n    if (compressionAlgorithmKey !== undefined) {\n      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n        const clientSelectedEncoding = CompressionAlgorithms[\n          compressionAlgorithmKey\n        ] as CompressionAlgorithm;\n        const serverSupportedEncodings =\n          sharedFilterConfig.serverSupportedEncodingHeader?.split(',');\n        /**\n         * There are two possible situations here:\n         * 1) We don't have any info yet from the server about what compression it supports\n         *    In that case we should just use what the client tells us to use\n         * 2) We've previously received a response from the server including a grpc-accept-encoding header\n         *    In that case we only want to use the encoding chosen by the client if the server supports it\n         */\n        if (\n          !serverSupportedEncodings ||\n          serverSupportedEncodings.includes(clientSelectedEncoding)\n        ) {\n          this.currentCompressionAlgorithm = clientSelectedEncoding;\n          this.sendCompression = getCompressionHandler(\n            this.currentCompressionAlgorithm,\n            -1\n          );\n        }\n      } else {\n        logging.log(\n          LogVerbosity.ERROR,\n          `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`\n        );\n      }\n    }\n  }\n\n  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {\n    const headers: Metadata = await metadata;\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    headers.set('accept-encoding', 'identity');\n\n    // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n    if (this.currentCompressionAlgorithm === 'identity') {\n      headers.remove('grpc-encoding');\n    } else {\n      headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n    }\n\n    return headers;\n  }\n\n  receiveMetadata(metadata: Metadata): Metadata {\n    const receiveEncoding: MetadataValue[] = metadata.get('grpc-encoding');\n    if (receiveEncoding.length > 0) {\n      const encoding: MetadataValue = receiveEncoding[0];\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\n      }\n    }\n    metadata.remove('grpc-encoding');\n\n    /* Check to see if the compression we're using to send messages is supported by the server\n     * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n    const serverSupportedEncodingsHeader = metadata.get(\n      'grpc-accept-encoding'\n    )[0] as string | undefined;\n    if (serverSupportedEncodingsHeader) {\n      this.sharedFilterConfig.serverSupportedEncodingHeader =\n        serverSupportedEncodingsHeader;\n      const serverSupportedEncodings =\n        serverSupportedEncodingsHeader.split(',');\n\n      if (\n        !serverSupportedEncodings.includes(this.currentCompressionAlgorithm)\n      ) {\n        this.sendCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n      }\n    }\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n    const resolvedMessage: WriteObject = await message;\n    let compress: boolean;\n    if (this.sendCompression instanceof IdentityHandler) {\n      compress = false;\n    } else {\n      compress = ((resolvedMessage.flags ?? 0) & WriteFlags.NoCompress) === 0;\n    }\n\n    return {\n      message: await this.sendCompression.writeMessage(\n        resolvedMessage.message,\n        compress\n      ),\n      flags: resolvedMessage.flags,\n    };\n  }\n\n  async receiveMessage(message: Promise<Buffer>) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage(await message);\n  }\n}\n\nexport class CompressionFilterFactory\n  implements FilterFactory<CompressionFilter>\n{\n  private sharedFilterConfig: SharedCompressionFilterConfig = {};\n  constructor(channel: Channel, private readonly options: ChannelOptions) {}\n  createFilter(): CompressionFilter {\n    return new CompressionFilter(this.options, this.sharedFilterConfig);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6819, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6823, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/deadline.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexport type Deadline = Date | number;\n\nexport function minDeadline(...deadlineList: Deadline[]): Deadline {\n  let minValue = Infinity;\n  for (const deadline of deadlineList) {\n    const deadlineMsecs =\n      deadline instanceof Date ? deadline.getTime() : deadline;\n    if (deadlineMsecs < minValue) {\n      minValue = deadlineMsecs;\n    }\n  }\n  return minValue;\n}\n\nconst units: Array<[string, number]> = [\n  ['m', 1],\n  ['S', 1000],\n  ['M', 60 * 1000],\n  ['H', 60 * 60 * 1000],\n];\n\nexport function getDeadlineTimeoutString(deadline: Deadline) {\n  const now = new Date().getTime();\n  if (deadline instanceof Date) {\n    deadline = deadline.getTime();\n  }\n  const timeoutMs = Math.max(deadline - now, 0);\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n  throw new Error('Deadline is too far in the future');\n}\n\n/**\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\n * This number of milliseconds is almost 25 days.\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\n/**\n * Get the timeout value that should be passed to setTimeout now for the timer\n * to end at the deadline. For any deadline before now, the timer should end\n * immediately, represented by a value of 0. For any deadline more than\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\n * end at that time, so it is treated as infinitely far in the future.\n * @param deadline\n * @returns\n */\nexport function getRelativeTimeout(deadline: Deadline) {\n  const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\n  const now = new Date().getTime();\n  const timeout = deadlineMs - now;\n  if (timeout < 0) {\n    return 0;\n  } else if (timeout > MAX_TIMEOUT_TIME) {\n    return Infinity;\n  } else {\n    return timeout;\n  }\n}\n\nexport function deadlineToString(deadline: Deadline): string {\n  if (deadline instanceof Date) {\n    return deadline.toISOString();\n  } else {\n    const dateDeadline = new Date(deadline);\n    if (Number.isNaN(dateDeadline.getTime())) {\n      return '' + deadline;\n    } else {\n      return dateDeadline.toISOString();\n    }\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAmBA,SAAgB,YAAY,GAAG,YAAwB;IACrD,IAAI,WAAW;IACf,KAAK,MAAM,YAAY,aAAc;QACnC,MAAM,gBACJ,oBAAoB,OAAO,SAAS,OAAO,KAAK;QAClD,IAAI,gBAAgB,UAAU;YAC5B,WAAW;QACb;IACF;IACA,OAAO;AACT;AAVA,QAAA,WAAA,GAAA;AAYA,MAAM,QAAiC;IACrC;QAAC;QAAK;KAAE;IACR;QAAC;QAAK;KAAK;IACX;QAAC;QAAK,KAAK;KAAK;IAChB;QAAC;QAAK,KAAK,KAAK;KAAK;CACtB;AAED,SAAgB,yBAAyB,QAAkB;IACzD,MAAM,MAAM,IAAI,OAAO,OAAO;IAC9B,IAAI,oBAAoB,MAAM;QAC5B,WAAW,SAAS,OAAO;IAC7B;IACA,MAAM,YAAY,KAAK,GAAG,CAAC,WAAW,KAAK;IAC3C,KAAK,MAAM,CAAC,MAAM,OAAO,IAAI,MAAO;QAClC,MAAM,SAAS,YAAY;QAC3B,IAAI,SAAS,KAAK;YAChB,OAAO,OAAO,KAAK,IAAI,CAAC,WAAW;QACrC;IACF;IACA,MAAM,IAAI,MAAM;AAClB;AAbA,QAAA,wBAAA,GAAA;AAeA;;;;;IAMA,MAAM,mBAAmB;AAEzB;;;;;;;;IASA,SAAgB,mBAAmB,QAAkB;IACnD,MAAM,aAAa,oBAAoB,OAAO,SAAS,OAAO,KAAK;IACnE,MAAM,MAAM,IAAI,OAAO,OAAO;IAC9B,MAAM,UAAU,aAAa;IAC7B,IAAI,UAAU,GAAG;QACf,OAAO;IACT,OAAO,IAAI,UAAU,kBAAkB;QACrC,OAAO;IACT,OAAO;QACL,OAAO;IACT;AACF;AAXA,QAAA,kBAAA,GAAA;AAaA,SAAgB,iBAAiB,QAAkB;IACjD,IAAI,oBAAoB,MAAM;QAC5B,OAAO,SAAS,WAAW;IAC7B,OAAO;QACL,MAAM,eAAe,IAAI,KAAK;QAC9B,IAAI,OAAO,KAAK,CAAC,aAAa,OAAO,KAAK;YACxC,OAAO,KAAK;QACd,OAAO;YACL,OAAO,aAAa,WAAW;QACjC;IACF;AACF;AAXA,QAAA,gBAAA,GAAA"}},
    {"offset": {"line": 6927, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6931, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/control-plane-status.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Status } from './constants';\n\nconst INAPPROPRIATE_CONTROL_PLANE_CODES: Status[] = [\n  Status.OK,\n  Status.INVALID_ARGUMENT,\n  Status.NOT_FOUND,\n  Status.ALREADY_EXISTS,\n  Status.FAILED_PRECONDITION,\n  Status.ABORTED,\n  Status.OUT_OF_RANGE,\n  Status.DATA_LOSS,\n];\n\nexport function restrictControlPlaneStatusCode(\n  code: Status,\n  details: string\n): { code: Status; details: string } {\n  if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n    return {\n      code: Status.INTERNAL,\n      details: `Invalid status from control plane: ${code} ${Status[code]} ${details}`,\n    };\n  } else {\n    return { code, details };\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,MAAA;AAEA,MAAM,oCAA8C;IAClD,YAAA,MAAM,CAAC,EAAE;IACT,YAAA,MAAM,CAAC,gBAAgB;IACvB,YAAA,MAAM,CAAC,SAAS;IAChB,YAAA,MAAM,CAAC,cAAc;IACrB,YAAA,MAAM,CAAC,mBAAmB;IAC1B,YAAA,MAAM,CAAC,OAAO;IACd,YAAA,MAAM,CAAC,YAAY;IACnB,YAAA,MAAM,CAAC,SAAS;CACjB;AAED,SAAgB,+BACd,IAAY,EACZ,OAAe;IAEf,IAAI,kCAAkC,QAAQ,CAAC,OAAO;QACpD,OAAO;YACL,MAAM,YAAA,MAAM,CAAC,QAAQ;YACrB,SAAS,CAAA,mCAAA,EAAsC,KAAI,CAAA,EAAI,YAAA,MAAM,CAAC,KAAK,CAAA,CAAA,EAAI,QAAO,CAAE;;IAEpF,OAAO;QACL,OAAO;YAAE;YAAM;QAAO;IACxB;AACF;AAZA,QAAA,8BAAA,GAAA"}},
    {"offset": {"line": 6976, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6980, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/load-balancing-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from './call-credentials';\nimport {\n  Call,\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n} from './call-interface';\nimport { SubchannelCall } from './subchannel-call';\nimport { ConnectivityState } from './connectivity-state';\nimport { LogVerbosity, Status } from './constants';\nimport { Deadline, getDeadlineTimeoutString } from './deadline';\nimport { InternalChannel } from './internal-channel';\nimport { Metadata } from './metadata';\nimport { PickResultType } from './picker';\nimport { CallConfig } from './resolver';\nimport { splitHostPort } from './uri-parser';\nimport * as logging from './logging';\nimport { restrictControlPlaneStatusCode } from './control-plane-status';\nimport * as http2 from 'http2';\n\nconst TRACER_NAME = 'load_balancing_call';\n\nexport type RpcProgress = 'NOT_STARTED' | 'DROP' | 'REFUSED' | 'PROCESSED';\n\nexport interface StatusObjectWithProgress extends StatusObject {\n  progress: RpcProgress;\n}\n\nexport interface LoadBalancingCallInterceptingListener\n  extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithProgress): void;\n}\n\nexport class LoadBalancingCall implements Call {\n  private child: SubchannelCall | null = null;\n  private readPending = false;\n  private pendingMessage: { context: MessageContext; message: Buffer } | null =\n    null;\n  private pendingHalfClose = false;\n  private ended = false;\n  private serviceUrl: string;\n  private metadata: Metadata | null = null;\n  private listener: InterceptingListener | null = null;\n  private onCallEnded: ((statusCode: Status) => void) | null = null;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host: string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number\n  ) {\n    const splitPath: string[] = this.methodName.split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = splitHostPort(this.host)?.host ?? 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private outputStatus(status: StatusObject, progress: RpcProgress) {\n    if (!this.ended) {\n      this.ended = true;\n      this.trace(\n        'ended with status: code=' +\n          status.code +\n          ' details=\"' +\n          status.details +\n          '\"'\n      );\n      const finalStatus = { ...status, progress };\n      this.listener?.onReceiveStatus(finalStatus);\n      this.onCallEnded?.(finalStatus.code);\n    }\n  }\n\n  doPick() {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata) {\n      throw new Error('doPick called before start');\n    }\n    this.trace('Pick called');\n    const pickResult = this.channel.doPick(\n      this.metadata,\n      this.callConfig.pickInformation\n    );\n    const subchannelString = pickResult.subchannel\n      ? '(' +\n        pickResult.subchannel.getChannelzRef().id +\n        ') ' +\n        pickResult.subchannel.getAddress()\n      : '' + pickResult.subchannel;\n    this.trace(\n      'Pick result: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        subchannelString +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        this.credentials\n          .generateMetadata({ service_url: this.serviceUrl })\n          .then(\n            credsMetadata => {\n              /* If this call was cancelled (e.g. by the deadline) before\n               * metadata generation finished, we shouldn't do anything with\n               * it. */\n              if (this.ended) {\n                this.trace('Credentials metadata generation finished after call ended');\n                return;\n              }\n              const finalMetadata = this.metadata!.clone();\n              finalMetadata.merge(credsMetadata);\n              if (finalMetadata.get('authorization').length > 1) {\n                this.outputStatus(\n                  {\n                    code: Status.INTERNAL,\n                    details:\n                      '\"authorization\" metadata cannot have multiple values',\n                    metadata: new Metadata(),\n                  },\n                  'PROCESSED'\n                );\n              }\n              if (\n                pickResult.subchannel!.getConnectivityState() !==\n                ConnectivityState.READY\n              ) {\n                this.trace(\n                  'Picked subchannel ' +\n                    subchannelString +\n                    ' has state ' +\n                    ConnectivityState[\n                      pickResult.subchannel!.getConnectivityState()\n                    ] +\n                    ' after getting credentials metadata. Retrying pick'\n                );\n                this.doPick();\n                return;\n              }\n\n              if (this.deadline !== Infinity) {\n                finalMetadata.set(\n                  'grpc-timeout',\n                  getDeadlineTimeoutString(this.deadline)\n                );\n              }\n              try {\n                this.child = pickResult\n                  .subchannel!.getRealSubchannel()\n                  .createCall(finalMetadata, this.host, this.methodName, {\n                    onReceiveMetadata: metadata => {\n                      this.trace('Received metadata');\n                      this.listener!.onReceiveMetadata(metadata);\n                    },\n                    onReceiveMessage: message => {\n                      this.trace('Received message');\n                      this.listener!.onReceiveMessage(message);\n                    },\n                    onReceiveStatus: status => {\n                      this.trace('Received status');\n                      if (\n                        status.rstCode ===\n                        http2.constants.NGHTTP2_REFUSED_STREAM\n                      ) {\n                        this.outputStatus(status, 'REFUSED');\n                      } else {\n                        this.outputStatus(status, 'PROCESSED');\n                      }\n                    },\n                  });\n              } catch (error) {\n                this.trace(\n                  'Failed to start call on picked subchannel ' +\n                    subchannelString +\n                    ' with error ' +\n                    (error as Error).message\n                );\n                this.outputStatus(\n                  {\n                    code: Status.INTERNAL,\n                    details:\n                      'Failed to start HTTP/2 stream with error ' +\n                      (error as Error).message,\n                    metadata: new Metadata(),\n                  },\n                  'NOT_STARTED'\n                );\n                return;\n              }\n              this.callConfig.onCommitted?.();\n              pickResult.onCallStarted?.();\n              this.onCallEnded = pickResult.onCallEnded;\n              this.trace(\n                'Created child call [' + this.child.getCallNumber() + ']'\n              );\n              if (this.readPending) {\n                this.child.startRead();\n              }\n              if (this.pendingMessage) {\n                this.child.sendMessageWithContext(\n                  this.pendingMessage.context,\n                  this.pendingMessage.message\n                );\n              }\n              if (this.pendingHalfClose) {\n                this.child.halfClose();\n              }\n            },\n            (error: Error & { code: number }) => {\n              // We assume the error code isn't 0 (Status.OK)\n              const { code, details } = restrictControlPlaneStatusCode(\n                typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n                `Getting metadata from plugin failed with error: ${error.message}`\n              );\n              this.outputStatus(\n                {\n                  code: code,\n                  details: details,\n                  metadata: new Metadata(),\n                },\n                'PROCESSED'\n              );\n            }\n          );\n        break;\n      case PickResultType.DROP:\n        const { code, details } = restrictControlPlaneStatusCode(\n          pickResult.status!.code,\n          pickResult.status!.details\n        );\n        setImmediate(() => {\n          this.outputStatus(\n            { code, details, metadata: pickResult.status!.metadata },\n            'DROP'\n          );\n        });\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (this.metadata.getOptions().waitForReady) {\n          this.channel.queueCallForPick(this);\n        } else {\n          const { code, details } = restrictControlPlaneStatusCode(\n            pickResult.status!.code,\n            pickResult.status!.details\n          );\n          setImmediate(() => {\n            this.outputStatus(\n              { code, details, metadata: pickResult.status!.metadata },\n              'PROCESSED'\n            );\n          });\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.channel.queueCallForPick(this);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.child?.cancelWithStatus(status, details);\n    this.outputStatus(\n      { code: status, details: details, metadata: new Metadata() },\n      'PROCESSED'\n    );\n  }\n  getPeer(): string {\n    return this.child?.getPeer() ?? this.channel.getTarget();\n  }\n  start(\n    metadata: Metadata,\n    listener: LoadBalancingCallInterceptingListener\n  ): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.metadata = metadata;\n    this.doPick();\n  }\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.child.sendMessageWithContext(context, message);\n    } else {\n      this.pendingMessage = { context, message };\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    if (this.child) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials: CallCredentials): void {\n    throw new Error('Method not implemented.');\n  }\n\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7229, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7233, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/resolving-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from './call-credentials';\nimport {\n  Call,\n  CallStreamOptions,\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n} from './call-interface';\nimport { LogVerbosity, Propagate, Status } from './constants';\nimport {\n  Deadline,\n  deadlineToString,\n  getRelativeTimeout,\n  minDeadline,\n} from './deadline';\nimport { FilterStack, FilterStackFactory } from './filter-stack';\nimport { InternalChannel } from './internal-channel';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { restrictControlPlaneStatusCode } from './control-plane-status';\n\nconst TRACER_NAME = 'resolving_call';\n\nexport class ResolvingCall implements Call {\n  private child: Call | null = null;\n  private readPending = false;\n  private pendingMessage: { context: MessageContext; message: Buffer } | null =\n    null;\n  private pendingHalfClose = false;\n  private ended = false;\n  private readFilterPending = false;\n  private writeFilterPending = false;\n  private pendingChildStatus: StatusObject | null = null;\n  private metadata: Metadata | null = null;\n  private listener: InterceptingListener | null = null;\n  private deadline: Deadline;\n  private host: string;\n  private statusWatchers: ((status: StatusObject) => void)[] = [];\n  private deadlineTimer: NodeJS.Timeout = setTimeout(() => {}, 0);\n  private filterStack: FilterStack | null = null;\n\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly method: string,\n    options: CallStreamOptions,\n    private readonly filterStackFactory: FilterStackFactory,\n    private credentials: CallCredentials,\n    private callNumber: number\n  ) {\n    this.deadline = options.deadline;\n    this.host = options.host;\n    if (options.parentCall) {\n      if (options.flags & Propagate.CANCELLATION) {\n        options.parentCall.on('cancelled', () => {\n          this.cancelWithStatus(Status.CANCELLED, 'Cancelled by parent call');\n        });\n      }\n      if (options.flags & Propagate.DEADLINE) {\n        this.trace(\n          'Propagating deadline from parent: ' +\n            options.parentCall.getDeadline()\n        );\n        this.deadline = minDeadline(\n          this.deadline,\n          options.parentCall.getDeadline()\n        );\n      }\n    }\n    this.trace('Created');\n    this.runDeadlineTimer();\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private runDeadlineTimer() {\n    clearTimeout(this.deadlineTimer);\n    this.trace('Deadline: ' + deadlineToString(this.deadline));\n    const timeout = getRelativeTimeout(this.deadline);\n    if (timeout !== Infinity) {\n      this.trace('Deadline will be reached in ' + timeout + 'ms');\n      const handleDeadline = () => {\n        this.cancelWithStatus(Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      };\n      if (timeout <= 0) {\n        process.nextTick(handleDeadline);\n      } else {\n        this.deadlineTimer = setTimeout(handleDeadline, timeout);\n      }\n    }\n  }\n\n  private outputStatus(status: StatusObject) {\n    if (!this.ended) {\n      this.ended = true;\n      if (!this.filterStack) {\n        this.filterStack = this.filterStackFactory.createFilter();\n      }\n      clearTimeout(this.deadlineTimer);\n      const filteredStatus = this.filterStack.receiveTrailers(status);\n      this.trace(\n        'ended with status: code=' +\n          filteredStatus.code +\n          ' details=\"' +\n          filteredStatus.details +\n          '\"'\n      );\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      process.nextTick(() => {\n        this.listener?.onReceiveStatus(filteredStatus);\n      });\n    }\n  }\n\n  private sendMessageOnChild(context: MessageContext, message: Buffer): void {\n    if (!this.child) {\n      throw new Error('sendMessageonChild called with child not populated');\n    }\n    const child = this.child;\n    this.writeFilterPending = true;\n    this.filterStack!.sendMessage(\n      Promise.resolve({ message: message, flags: context.flags })\n    ).then(\n      filteredMessage => {\n        this.writeFilterPending = false;\n        child.sendMessageWithContext(context, filteredMessage.message);\n        if (this.pendingHalfClose) {\n          child.halfClose();\n        }\n      },\n      (status: StatusObject) => {\n        this.cancelWithStatus(status.code, status.details);\n      }\n    );\n  }\n\n  getConfig(): void {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata || !this.listener) {\n      throw new Error('getConfig called before start');\n    }\n    const configResult = this.channel.getConfig(this.method, this.metadata);\n    if (configResult.type === 'NONE') {\n      this.channel.queueCallForConfig(this);\n      return;\n    } else if (configResult.type === 'ERROR') {\n      if (this.metadata.getOptions().waitForReady) {\n        this.channel.queueCallForConfig(this);\n      } else {\n        this.outputStatus(configResult.error);\n      }\n      return;\n    }\n    // configResult.type === 'SUCCESS'\n    const config = configResult.config;\n    if (config.status !== Status.OK) {\n      const { code, details } = restrictControlPlaneStatusCode(\n        config.status,\n        'Failed to route call to method ' + this.method\n      );\n      this.outputStatus({\n        code: code,\n        details: details,\n        metadata: new Metadata(),\n      });\n      return;\n    }\n\n    if (config.methodConfig.timeout) {\n      const configDeadline = new Date();\n      configDeadline.setSeconds(\n        configDeadline.getSeconds() + config.methodConfig.timeout.seconds\n      );\n      configDeadline.setMilliseconds(\n        configDeadline.getMilliseconds() +\n          config.methodConfig.timeout.nanos / 1_000_000\n      );\n      this.deadline = minDeadline(this.deadline, configDeadline);\n      this.runDeadlineTimer();\n    }\n\n    this.filterStackFactory.push(config.dynamicFilterFactories);\n    this.filterStack = this.filterStackFactory.createFilter();\n    this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(\n      filteredMetadata => {\n        this.child = this.channel.createInnerCall(\n          config,\n          this.method,\n          this.host,\n          this.credentials,\n          this.deadline\n        );\n        this.trace('Created child [' + this.child.getCallNumber() + ']');\n        this.child.start(filteredMetadata, {\n          onReceiveMetadata: metadata => {\n            this.trace('Received metadata');\n            this.listener!.onReceiveMetadata(\n              this.filterStack!.receiveMetadata(metadata)\n            );\n          },\n          onReceiveMessage: message => {\n            this.trace('Received message');\n            this.readFilterPending = true;\n            this.filterStack!.receiveMessage(message).then(\n              filteredMesssage => {\n                this.trace('Finished filtering received message');\n                this.readFilterPending = false;\n                this.listener!.onReceiveMessage(filteredMesssage);\n                if (this.pendingChildStatus) {\n                  this.outputStatus(this.pendingChildStatus);\n                }\n              },\n              (status: StatusObject) => {\n                this.cancelWithStatus(status.code, status.details);\n              }\n            );\n          },\n          onReceiveStatus: status => {\n            this.trace('Received status');\n            if (this.readFilterPending) {\n              this.pendingChildStatus = status;\n            } else {\n              this.outputStatus(status);\n            }\n          },\n        });\n        if (this.readPending) {\n          this.child.startRead();\n        }\n        if (this.pendingMessage) {\n          this.sendMessageOnChild(\n            this.pendingMessage.context,\n            this.pendingMessage.message\n          );\n        } else if (this.pendingHalfClose) {\n          this.child.halfClose();\n        }\n      },\n      (status: StatusObject) => {\n        this.outputStatus(status);\n      }\n    );\n  }\n\n  reportResolverError(status: StatusObject) {\n    if (this.metadata?.getOptions().waitForReady) {\n      this.channel.queueCallForConfig(this);\n    } else {\n      this.outputStatus(status);\n    }\n  }\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.child?.cancelWithStatus(status, details);\n    this.outputStatus({\n      code: status,\n      details: details,\n      metadata: new Metadata(),\n    });\n  }\n  getPeer(): string {\n    return this.child?.getPeer() ?? this.channel.getTarget();\n  }\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.metadata = metadata.clone();\n    this.listener = listener;\n    this.getConfig();\n  }\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.sendMessageOnChild(context, message);\n    } else {\n      this.pendingMessage = { context, message };\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    if (this.child && !this.writeFilterPending) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.credentials = this.credentials.compose(credentials);\n  }\n\n  addStatusWatcher(watcher: (status: StatusObject) => void) {\n    this.statusWatchers.push(watcher);\n  }\n\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7497, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7501, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/retrying-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from './call-credentials';\nimport { LogVerbosity, Status } from './constants';\nimport { Deadline } from './deadline';\nimport { Metadata } from './metadata';\nimport { CallConfig } from './resolver';\nimport * as logging from './logging';\nimport {\n  Call,\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n  WriteCallback,\n  WriteObject,\n} from './call-interface';\nimport {\n  LoadBalancingCall,\n  StatusObjectWithProgress,\n} from './load-balancing-call';\nimport { InternalChannel } from './internal-channel';\n\nconst TRACER_NAME = 'retrying_call';\n\nexport class RetryThrottler {\n  private tokens: number;\n  constructor(\n    private readonly maxTokens: number,\n    private readonly tokenRatio: number,\n    previousRetryThrottler?: RetryThrottler\n  ) {\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens =\n        previousRetryThrottler.tokens *\n        (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\n\nexport class MessageBufferTracker {\n  private totalAllocated = 0;\n  private allocatedPerCall: Map<number, number> = new Map<number, number>();\n\n  constructor(private totalLimit: number, private limitPerCall: number) {}\n\n  allocate(size: number, callId: number): boolean {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (\n      this.limitPerCall - currentPerCall < size ||\n      this.totalLimit - this.totalAllocated < size\n    ) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n\n  free(size: number, callId: number) {\n    if (this.totalAllocated < size) {\n      throw new Error(\n        `Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`\n      );\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (currentPerCall < size) {\n      throw new Error(\n        `Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`\n      );\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n\n  freeAll(callId: number) {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(\n        `Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`\n      );\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\n\ntype UnderlyingCallState = 'ACTIVE' | 'COMPLETED';\n\ninterface UnderlyingCall {\n  state: UnderlyingCallState;\n  call: LoadBalancingCall;\n  nextMessageToSend: number;\n}\n\n/**\n * A retrying call can be in one of these states:\n * RETRY: Retries are configured and new attempts may be sent\n * HEDGING: Hedging is configured and new attempts may be sent\n * TRANSPARENT_ONLY: Neither retries nor hedging are configured, and\n * transparent retry attempts may still be sent\n * COMMITTED: One attempt is committed, and no new attempts will be\n * sent\n */\ntype RetryingCallState = 'RETRY' | 'HEDGING' | 'TRANSPARENT_ONLY' | 'COMMITTED';\n\n/**\n * The different types of objects that can be stored in the write buffer, with\n * the following meanings:\n * MESSAGE: This is a message to be sent.\n * HALF_CLOSE: When this entry is reached, the calls should send a half-close.\n * FREED: This slot previously contained a message that has been sent on all\n * child calls and is no longer needed.\n */\ntype WriteBufferEntryType = 'MESSAGE' | 'HALF_CLOSE' | 'FREED';\n\n/**\n * Entry in the buffer of messages to send to the remote end.\n */\ninterface WriteBufferEntry {\n  entryType: WriteBufferEntryType;\n  /**\n   * Message to send.\n   * Only populated if entryType is MESSAGE.\n   */\n  message?: WriteObject;\n  /**\n   * Callback to call after sending the message.\n   * Only populated if entryType is MESSAGE and the call is in the COMMITTED\n   * state.\n   */\n  callback?: WriteCallback;\n  /**\n   * Indicates whether the message is allocated in the buffer tracker. Ignored\n   * if entryType is not MESSAGE. Should be the return value of\n   * bufferTracker.allocate.\n   */\n  allocated: boolean;\n}\n\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\n\nexport class RetryingCall implements Call {\n  private state: RetryingCallState;\n  private listener: InterceptingListener | null = null;\n  private initialMetadata: Metadata | null = null;\n  private underlyingCalls: UnderlyingCall[] = [];\n  private writeBuffer: WriteBufferEntry[] = [];\n  /**\n   * The offset of message indices in the writeBuffer. For example, if\n   * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n   * is in writeBuffer[5].\n   */\n  private writeBufferOffset = 0;\n  /**\n   * Tracks whether a read has been started, so that we know whether to start\n   * reads on new child calls. This only matters for the first read, because\n   * once a message comes in the child call becomes committed and there will\n   * be no new child calls.\n   */\n  private readStarted = false;\n  private transparentRetryUsed = false;\n  /**\n   * Number of attempts so far\n   */\n  private attempts = 0;\n  private hedgingTimer: NodeJS.Timeout | null = null;\n  private committedCallIndex: number | null = null;\n  private initialRetryBackoffSec = 0;\n  private nextRetryBackoffSec = 0;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host: string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number,\n    private readonly bufferTracker: MessageBufferTracker,\n    private readonly retryThrottler?: RetryThrottler\n  ) {\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(\n        retryPolicy.initialBackoff.substring(\n          0,\n          retryPolicy.initialBackoff.length - 1\n        )\n      );\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n    }\n  }\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private reportStatus(statusObject: StatusObject) {\n    this.trace(\n      'ended with status: code=' +\n        statusObject.code +\n        ' details=\"' +\n        statusObject.details +\n        '\"'\n    );\n    this.bufferTracker.freeAll(this.callNumber);\n    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n    this.writeBuffer = [];\n    process.nextTick(() => {\n      // Explicitly construct status object to remove progress field\n      this.listener?.onReceiveStatus({\n        code: statusObject.code,\n        details: statusObject.details,\n        metadata: statusObject.metadata,\n      });\n    });\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.reportStatus({ code: status, details, metadata: new Metadata() });\n    for (const { call } of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer(): string {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n\n  private getBufferEntry(messageIndex: number): WriteBufferEntry {\n    return (\n      this.writeBuffer[messageIndex - this.writeBufferOffset] ?? {\n        entryType: 'FREED',\n        allocated: false,\n      }\n    );\n  }\n\n  private getNextBufferIndex() {\n    return this.writeBufferOffset + this.writeBuffer.length;\n  }\n\n  private clearSentMessages() {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const earliestNeededMessageIndex =\n      this.underlyingCalls[this.committedCallIndex!].nextMessageToSend;\n    for (\n      let messageIndex = this.writeBufferOffset;\n      messageIndex < earliestNeededMessageIndex;\n      messageIndex++\n    ) {\n      const bufferEntry = this.getBufferEntry(messageIndex);\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(\n          bufferEntry.message!.message.length,\n          this.callNumber\n        );\n      }\n    }\n    this.writeBuffer = this.writeBuffer.slice(\n      earliestNeededMessageIndex - this.writeBufferOffset\n    );\n    this.writeBufferOffset = earliestNeededMessageIndex;\n  }\n\n  private commitCall(index: number) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace(\n      'Committing call [' +\n        this.underlyingCalls[index].call.getCallNumber() +\n        '] at index ' +\n        index\n    );\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(\n        Status.CANCELLED,\n        'Discarded in favor of other hedged attempt'\n      );\n    }\n    this.clearSentMessages();\n  }\n\n  private commitCallWithMostMessages() {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (\n        childCall.state === 'ACTIVE' &&\n        childCall.nextMessageToSend > mostMessages\n      ) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    if (callWithMostMessages === -1) {\n      /* There are no active calls, disable retries to force the next call that\n       * is started to be committed. */\n      this.state = 'TRANSPARENT_ONLY';\n    } else {\n      this.commitCall(callWithMostMessages);\n    }\n  }\n\n  private isStatusCodeInList(list: (Status | string)[], code: Status) {\n    return list.some(\n      value =>\n        value === code ||\n        value.toString().toLowerCase() === Status[code].toLowerCase()\n    );\n  }\n\n  private getNextRetryBackoffMs() {\n    const retryPolicy = this.callConfig?.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(\n      retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1)\n    );\n    this.nextRetryBackoffSec = Math.min(\n      this.nextRetryBackoffSec * retryPolicy.backoffMultiplier,\n      maxBackoffSec\n    );\n    return nextBackoffMs;\n  }\n\n  private maybeRetryCall(\n    pushback: number | null,\n    callback: (retried: boolean) => void\n  ) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    const retryPolicy = this.callConfig!.methodConfig.retryPolicy!;\n    if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs: number;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if (this.retryThrottler?.canRetryCall() ?? true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n\n  private countActiveCalls(): number {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  private handleProcessedStatus(\n    status: StatusObject,\n    callIndex: number,\n    pushback: number | null\n  ) {\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (\n          this.isStatusCodeInList(\n            this.callConfig!.methodConfig.hedgingPolicy!.nonFatalStatusCodes ??\n              [],\n            status.code\n          )\n        ) {\n          this.retryThrottler?.addCallFailed();\n          let delayMs: number;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (\n          this.isStatusCodeInList(\n            this.callConfig!.methodConfig.retryPolicy!.retryableStatusCodes,\n            status.code\n          )\n        ) {\n          this.retryThrottler?.addCallFailed();\n          this.maybeRetryCall(pushback, retried => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n\n  private getPushback(metadata: Metadata): number | null {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0] as string);\n    } catch (e) {\n      return -1;\n    }\n  }\n\n  private handleChildStatus(\n    status: StatusObjectWithProgress,\n    callIndex: number\n  ) {\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace(\n      'state=' +\n        this.state +\n        ' handling status with progress ' +\n        status.progress +\n        ' from child [' +\n        this.underlyingCalls[callIndex].call.getCallNumber() +\n        '] in state ' +\n        this.underlyingCalls[callIndex].state\n    );\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === Status.OK) {\n      this.retryThrottler?.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        }\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n\n  private maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private maybeStartHedgingTimer() {\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    const hedgingDelayString = hedgingPolicy.hedgingDelay ?? '0s';\n    const hedgingDelaySec = Number(\n      hedgingDelayString.substring(0, hedgingDelayString.length - 1)\n    );\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    this.hedgingTimer.unref?.();\n  }\n\n  private startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(\n      this.callConfig,\n      this.methodName,\n      this.host,\n      this.credentials,\n      this.deadline\n    );\n    this.trace(\n      'Created child call [' +\n        child.getCallNumber() +\n        '] for attempt ' +\n        this.attempts\n    );\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({\n      state: 'ACTIVE',\n      call: child,\n      nextMessageToSend: 0,\n    });\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata!.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(\n        PREVIONS_RPC_ATTEMPTS_METADATA_KEY,\n        `${previousAttempts}`\n      );\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace(\n          'Received metadata from child [' + child.getCallNumber() + ']'\n        );\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(\n            PREVIONS_RPC_ATTEMPTS_METADATA_KEY,\n            `${previousAttempts}`\n          );\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace(\n          'Received message from child [' + child.getCallNumber() + ']'\n        );\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace(\n          'Received status from child [' + child.getCallNumber() + ']'\n        );\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(\n            PREVIONS_RPC_ATTEMPTS_METADATA_KEY,\n            `${previousAttempts}`\n          );\n        }\n        this.handleChildStatus(status, index);\n      },\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private handleChildWriteCompleted(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    this.getBufferEntry(messageIndex).callback?.();\n    this.clearSentMessages();\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n\n  private sendNextChildMessage(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.getBufferEntry(childCall.nextMessageToSend)) {\n      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext(\n            {\n              callback: error => {\n                // Ignore error\n                this.handleChildWriteCompleted(childIndex);\n              },\n            },\n            bufferEntry.message!.message\n          );\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj: WriteObject = {\n      message,\n      flags: context.flags,\n    };\n    const messageIndex = this.getNextBufferIndex();\n    const bufferEntry: WriteBufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber),\n    };\n    this.writeBuffer.push(bufferEntry);\n    if (bufferEntry.allocated) {\n      context.callback?.();\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (\n          call.state === 'ACTIVE' &&\n          call.nextMessageToSend === messageIndex\n        ) {\n          call.call.sendMessageWithContext(\n            {\n              callback: error => {\n                // Ignore error\n                this.handleChildWriteCompleted(callIndex);\n              },\n            },\n            message\n          );\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      // commitCallWithMostMessages can fail if we are between ping attempts\n      if (this.committedCallIndex === null) {\n        return;\n      }\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback;\n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext(\n          {\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(this.committedCallIndex!);\n            },\n          },\n          message\n        );\n      }\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if (underlyingCall?.state === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.getNextBufferIndex();\n    this.writeBuffer.push({\n      entryType: 'HALF_CLOSE',\n      allocated: false,\n    });\n    for (const call of this.underlyingCalls) {\n      if (\n        call?.state === 'ACTIVE' &&\n        call.nextMessageToSend === halfCloseIndex\n      ) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials: CallCredentials): void {\n    throw new Error('Method not implemented.');\n  }\n  getMethod(): string {\n    return this.methodName;\n  }\n  getHost(): string {\n    return this.host;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8100, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8104, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/subchannel-interface.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { SubchannelRef } from './channelz';\nimport { ConnectivityState } from './connectivity-state';\nimport { Subchannel } from './subchannel';\n\nexport type ConnectivityStateListener = (\n  subchannel: SubchannelInterface,\n  previousState: ConnectivityState,\n  newState: ConnectivityState,\n  keepaliveTime: number,\n  errorMessage?: string\n) => void;\n\n/**\n * This is an interface for load balancing policies to use to interact with\n * subchannels. This allows load balancing policies to wrap and unwrap\n * subchannels.\n *\n * Any load balancing policy that wraps subchannels must unwrap the subchannel\n * in the picker, so that other load balancing policies consistently have\n * access to their own wrapper objects.\n */\nexport interface SubchannelInterface {\n  getConnectivityState(): ConnectivityState;\n  addConnectivityStateListener(listener: ConnectivityStateListener): void;\n  removeConnectivityStateListener(listener: ConnectivityStateListener): void;\n  startConnecting(): void;\n  getAddress(): string;\n  throttleKeepalive(newKeepaliveTime: number): void;\n  ref(): void;\n  unref(): void;\n  getChannelzRef(): SubchannelRef;\n  /**\n   * If this is a wrapper, return the wrapped subchannel, otherwise return this\n   */\n  getRealSubchannel(): Subchannel;\n  /**\n   * Returns true if this and other both proxy the same underlying subchannel.\n   * Can be used instead of directly accessing getRealSubchannel to allow mocks\n   * to avoid implementing getRealSubchannel\n   */\n  realSubchannelEquals(other: SubchannelInterface): boolean;\n}\n\nexport abstract class BaseSubchannelWrapper implements SubchannelInterface {\n  constructor(protected child: SubchannelInterface) {}\n\n  getConnectivityState(): ConnectivityState {\n    return this.child.getConnectivityState();\n  }\n  addConnectivityStateListener(listener: ConnectivityStateListener): void {\n    this.child.addConnectivityStateListener(listener);\n  }\n  removeConnectivityStateListener(listener: ConnectivityStateListener): void {\n    this.child.removeConnectivityStateListener(listener);\n  }\n  startConnecting(): void {\n    this.child.startConnecting();\n  }\n  getAddress(): string {\n    return this.child.getAddress();\n  }\n  throttleKeepalive(newKeepaliveTime: number): void {\n    this.child.throttleKeepalive(newKeepaliveTime);\n  }\n  ref(): void {\n    this.child.ref();\n  }\n  unref(): void {\n    this.child.unref();\n  }\n  getChannelzRef(): SubchannelRef {\n    return this.child.getChannelzRef();\n  }\n  getRealSubchannel(): Subchannel {\n    return this.child.getRealSubchannel();\n  }\n  realSubchannelEquals(other: SubchannelInterface): boolean {\n    return this.getRealSubchannel() === other.getRealSubchannel();\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AA4DA,MAAsB;IACpB,YAAsB,KAA0B,CAAA;QAA1B,IAAA,CAAA,KAAK,GAAL;IAA6B;IAEnD,uBAAoB;QAClB,OAAO,IAAI,CAAC,KAAK,CAAC,oBAAoB;IACxC;IACA,6BAA6B,QAAmC,EAAA;QAC9D,IAAI,CAAC,KAAK,CAAC,4BAA4B,CAAC;IAC1C;IACA,gCAAgC,QAAmC,EAAA;QACjE,IAAI,CAAC,KAAK,CAAC,+BAA+B,CAAC;IAC7C;IACA,kBAAe;QACb,IAAI,CAAC,KAAK,CAAC,eAAe;IAC5B;IACA,aAAU;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU;IAC9B;IACA,kBAAkB,gBAAwB,EAAA;QACxC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC;IAC/B;IACA,MAAG;QACD,IAAI,CAAC,KAAK,CAAC,GAAG;IAChB;IACA,QAAK;QACH,IAAI,CAAC,KAAK,CAAC,KAAK;IAClB;IACA,iBAAc;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc;IAClC;IACA,oBAAiB;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,iBAAiB;IACrC;IACA,qBAAqB,KAA0B,EAAA;QAC7C,OAAO,IAAI,CAAC,iBAAiB,OAAO,MAAM,iBAAiB;IAC7D;;AAnCF,QAAA,qBAAA,GAAA"}},
    {"offset": {"line": 8163, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8167, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/internal-channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ResolvingLoadBalancer } from './resolving-load-balancer';\nimport { SubchannelPool, getSubchannelPool } from './subchannel-pool';\nimport { ChannelControlHelper } from './load-balancer';\nimport { UnavailablePicker, Picker, QueuePicker } from './picker';\nimport { Metadata } from './metadata';\nimport { Status, LogVerbosity, Propagate } from './constants';\nimport { FilterStackFactory } from './filter-stack';\nimport { CompressionFilterFactory } from './compression-filter';\nimport {\n  CallConfig,\n  ConfigSelector,\n  getDefaultAuthority,\n  mapUriDefaultScheme,\n} from './resolver';\nimport { trace } from './logging';\nimport { SubchannelAddress } from './subchannel-address';\nimport { mapProxyName } from './http_proxy';\nimport { GrpcUri, parseUri, uriToString } from './uri-parser';\nimport { ServerSurfaceCall } from './server-call';\n\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  ChannelInfo,\n  ChannelRef,\n  ChannelzCallTracker,\n  ChannelzChildrenTracker,\n  ChannelzTrace,\n  registerChannelzChannel,\n  SubchannelRef,\n  unregisterChannelzRef,\n} from './channelz';\nimport { LoadBalancingCall } from './load-balancing-call';\nimport { CallCredentials } from './call-credentials';\nimport { Call, CallStreamOptions, StatusObject } from './call-interface';\nimport { Deadline, deadlineToString } from './deadline';\nimport { ResolvingCall } from './resolving-call';\nimport { getNextCallNumber } from './call-number';\nimport { restrictControlPlaneStatusCode } from './control-plane-status';\nimport {\n  MessageBufferTracker,\n  RetryingCall,\n  RetryThrottler,\n} from './retrying-call';\nimport {\n  BaseSubchannelWrapper,\n  ConnectivityStateListener,\n  SubchannelInterface,\n} from './subchannel-interface';\n\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\n\ninterface ConnectivityStateWatcher {\n  currentState: ConnectivityState;\n  timer: NodeJS.Timeout | null;\n  callback: (error?: Error) => void;\n}\n\ninterface NoneConfigResult {\n  type: 'NONE';\n}\n\ninterface SuccessConfigResult {\n  type: 'SUCCESS';\n  config: CallConfig;\n}\n\ninterface ErrorConfigResult {\n  type: 'ERROR';\n  error: StatusObject;\n}\n\ntype GetConfigResult =\n  | NoneConfigResult\n  | SuccessConfigResult\n  | ErrorConfigResult;\n\nconst RETRY_THROTTLER_MAP: Map<string, RetryThrottler> = new Map();\n\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\n\nclass ChannelSubchannelWrapper\n  extends BaseSubchannelWrapper\n  implements SubchannelInterface\n{\n  private refCount = 0;\n  private subchannelStateListener: ConnectivityStateListener;\n  constructor(\n    childSubchannel: SubchannelInterface,\n    private channel: InternalChannel\n  ) {\n    super(childSubchannel);\n    this.subchannelStateListener = (\n      subchannel,\n      previousState,\n      newState,\n      keepaliveTime\n    ) => {\n      channel.throttleKeepalive(keepaliveTime);\n    };\n    childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\n  }\n\n  ref(): void {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref(): void {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      this.child.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channel.removeWrappedSubchannel(this);\n    }\n  }\n}\n\nexport class InternalChannel {\n  private readonly resolvingLoadBalancer: ResolvingLoadBalancer;\n  private readonly subchannelPool: SubchannelPool;\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  private currentPicker: Picker = new UnavailablePicker();\n  /**\n   * Calls queued up to get a call config. Should only be populated before the\n   * first time the resolver returns a result, which includes the ConfigSelector.\n   */\n  private configSelectionQueue: ResolvingCall[] = [];\n  private pickQueue: LoadBalancingCall[] = [];\n  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];\n  private readonly defaultAuthority: string;\n  private readonly filterStackFactory: FilterStackFactory;\n  private readonly target: GrpcUri;\n  /**\n   * This timer does not do anything on its own. Its purpose is to hold the\n   * event loop open while there are any pending calls for the channel that\n   * have not yet been assigned to specific subchannels. In other words,\n   * the invariant is that callRefTimer is reffed if and only if pickQueue\n   * is non-empty.\n   */\n  private readonly callRefTimer: NodeJS.Timeout;\n  private configSelector: ConfigSelector | null = null;\n  /**\n   * This is the error from the name resolver if it failed most recently. It\n   * is only used to end calls that start while there is no config selector\n   * and the name resolver is in backoff, so it should be nulled if\n   * configSelector becomes set or the channel state becomes anything other\n   * than TRANSIENT_FAILURE.\n   */\n  private currentResolutionError: StatusObject | null = null;\n  private readonly retryBufferTracker: MessageBufferTracker;\n  private keepaliveTime: number;\n  private readonly wrappedSubchannels: Set<ChannelSubchannelWrapper> =\n    new Set();\n\n  private callCount = 0;\n  private idleTimer: NodeJS.Timeout | null = null;\n  private readonly idleTimeoutMs: number;\n  private lastActivityTimestamp: Date;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private readonly originalTarget: string;\n  private readonly channelzRef: ChannelRef;\n  private readonly channelzTrace: ChannelzTrace;\n  private readonly callTracker = new ChannelzCallTracker();\n  private readonly childrenTracker = new ChannelzChildrenTracker();\n\n  constructor(\n    target: string,\n    private readonly credentials: ChannelCredentials,\n    private readonly options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\n        `Could not find a default scheme for target name \"${target}\"`\n      );\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    this.callRefTimer.unref?.();\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzChannel(\n      target,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'] as string;\n    } else {\n      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = getSubchannelPool(\n      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0\n    );\n    this.retryBufferTracker = new MessageBufferTracker(\n      options['grpc.retry_buffer_size'] ?? DEFAULT_RETRY_BUFFER_SIZE_BYTES,\n      options['grpc.per_rpc_retry_buffer_size'] ??\n        DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES\n    );\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n    this.idleTimeoutMs = Math.max(\n      options['grpc.client_idle_timeout_ms'] ?? DEFAULT_IDLE_TIMEOUT_MS,\n      MIN_IDLE_TIMEOUT_MS\n    );\n    const channelControlHelper: ChannelControlHelper = {\n      createSubchannel: (\n        subchannelAddress: SubchannelAddress,\n        subchannelArgs: ChannelOptions\n      ) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(\n          this.target,\n          subchannelAddress,\n          Object.assign({}, this.options, subchannelArgs),\n          this.credentials\n        );\n        subchannel.throttleKeepalive(this.keepaliveTime);\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Created subchannel or used existing subchannel',\n            subchannel.getChannelzRef()\n          );\n        }\n        const wrappedSubchannel = new ChannelSubchannelWrapper(\n          subchannel,\n          this\n        );\n        this.wrappedSubchannels.add(wrappedSubchannel);\n        return wrappedSubchannel;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        if (queueCopy.length > 0) {\n          this.callRefTimerUnref();\n        }\n        for (const call of queueCopy) {\n          call.doPick();\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error(\n          'Resolving load balancer should never call requestReresolution'\n        );\n      },\n      addChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      },\n    };\n    this.resolvingLoadBalancer = new ResolvingLoadBalancer(\n      this.target,\n      channelControlHelper,\n      options,\n      (serviceConfig, configSelector) => {\n        if (serviceConfig.retryThrottling) {\n          RETRY_THROTTLER_MAP.set(\n            this.getTarget(),\n            new RetryThrottler(\n              serviceConfig.retryThrottling.maxTokens,\n              serviceConfig.retryThrottling.tokenRatio,\n              RETRY_THROTTLER_MAP.get(this.getTarget())\n            )\n          );\n        } else {\n          RETRY_THROTTLER_MAP.delete(this.getTarget());\n        }\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Address resolution succeeded'\n          );\n        }\n        this.configSelector = configSelector;\n        this.currentResolutionError = null;\n        /* We process the queue asynchronously to ensure that the corresponding\n         * load balancer update has completed. */\n        process.nextTick(() => {\n          const localQueue = this.configSelectionQueue;\n          this.configSelectionQueue = [];\n          if (localQueue.length > 0) {\n            this.callRefTimerUnref();\n          }\n          for (const call of localQueue) {\n            call.getConfig();\n          }\n        });\n      },\n      status => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace(\n            'CT_WARNING',\n            'Address resolution failed with code ' +\n              status.code +\n              ' and details \"' +\n              status.details +\n              '\"'\n          );\n        }\n        if (this.configSelectionQueue.length > 0) {\n          this.trace(\n            'Name resolution failed with calls queued for config selection'\n          );\n        }\n        if (this.configSelector === null) {\n          this.currentResolutionError = {\n            ...restrictControlPlaneStatusCode(status.code, status.details),\n            metadata: status.metadata,\n          };\n        }\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        if (localQueue.length > 0) {\n          this.callRefTimerUnref();\n        }\n        for (const call of localQueue) {\n          call.reportResolverError(status);\n        }\n      }\n    );\n    this.filterStackFactory = new FilterStackFactory([\n      new CompressionFilterFactory(this, this.options),\n    ]);\n    this.trace(\n      'Channel constructed with options ' +\n        JSON.stringify(options, undefined, 2)\n    );\n    const error = new Error();\n    trace(\n      LogVerbosity.DEBUG,\n      'channel_stacktrace',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        'Channel constructed \\n' +\n        error.stack?.substring(error.stack.indexOf('\\n') + 1)\n    );\n    this.lastActivityTimestamp = new Date();\n  }\n\n  private getChannelzInfo(): ChannelInfo {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n    };\n  }\n\n  private trace(text: string, verbosityOverride?: LogVerbosity) {\n    trace(\n      verbosityOverride ?? LogVerbosity.DEBUG,\n      'channel',\n      '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text\n    );\n  }\n\n  private callRefTimerRef() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef?.()) {\n      this.trace(\n        'callRefTimer.ref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.ref?.();\n    }\n  }\n\n  private callRefTimerUnref() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace(\n        'callRefTimer.unref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.unref?.();\n    }\n  }\n\n  private removeConnectivityStateWatcher(\n    watcherObject: ConnectivityStateWatcher\n  ) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(\n      value => value === watcherObject\n    );\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  private updateState(newState: ConnectivityState): void {\n    trace(\n      LogVerbosity.DEBUG,\n      'connectivity_state',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace(\n        'CT_INFO',\n        'Connectivity state change to ' + ConnectivityState[newState]\n      );\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n      for (const wrappedSubchannel of this.wrappedSubchannels) {\n        wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n      }\n    }\n  }\n\n  removeWrappedSubchannel(wrappedSubchannel: ChannelSubchannelWrapper) {\n    this.wrappedSubchannels.delete(wrappedSubchannel);\n  }\n\n  doPick(metadata: Metadata, extraPickInfo: { [key: string]: string }) {\n    return this.currentPicker.pick({\n      metadata: metadata,\n      extraPickInfo: extraPickInfo,\n    });\n  }\n\n  queueCallForPick(call: LoadBalancingCall) {\n    this.pickQueue.push(call);\n    this.callRefTimerRef();\n  }\n\n  getConfig(method: string, metadata: Metadata): GetConfigResult {\n    this.resolvingLoadBalancer.exitIdle();\n    if (this.configSelector) {\n      return {\n        type: 'SUCCESS',\n        config: this.configSelector(method, metadata),\n      };\n    } else {\n      if (this.currentResolutionError) {\n        return {\n          type: 'ERROR',\n          error: this.currentResolutionError,\n        };\n      } else {\n        return {\n          type: 'NONE',\n        };\n      }\n    }\n  }\n\n  queueCallForConfig(call: ResolvingCall) {\n    this.configSelectionQueue.push(call);\n    this.callRefTimerRef();\n  }\n\n  private enterIdle() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.IDLE);\n    this.currentPicker = new QueuePicker(this.resolvingLoadBalancer);\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n      this.idleTimer = null;\n    }\n  }\n\n  private startIdleTimeout(timeoutMs: number) {\n    this.idleTimer = setTimeout(() => {\n      if (this.callCount > 0) {\n        /* If there is currently a call, the channel will not go idle for a\n         * period of at least idleTimeoutMs, so check again after that time.\n         */\n        this.startIdleTimeout(this.idleTimeoutMs);\n        return;\n      }\n      const now = new Date();\n      const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\n      if (timeSinceLastActivity >= this.idleTimeoutMs) {\n        this.trace(\n          'Idle timer triggered after ' +\n            this.idleTimeoutMs +\n            'ms of inactivity'\n        );\n        this.enterIdle();\n      } else {\n        /* Whenever the timer fires with the latest activity being too recent,\n         * set the timer again for the time when the time since the last\n         * activity is equal to the timeout. This should result in the timer\n         * firing no more than once every idleTimeoutMs/2 on average. */\n        this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\n      }\n    }, timeoutMs);\n    this.idleTimer.unref?.();\n  }\n\n  private maybeStartIdleTimer() {\n    if (this.connectivityState !== ConnectivityState.SHUTDOWN && !this.idleTimer) {\n      this.startIdleTimeout(this.idleTimeoutMs);\n    }\n  }\n\n  private onCallStart() {\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n    }\n    this.callCount += 1;\n  }\n\n  private onCallEnd(status: StatusObject) {\n    if (this.channelzEnabled) {\n      if (status.code === Status.OK) {\n        this.callTracker.addCallSucceeded();\n      } else {\n        this.callTracker.addCallFailed();\n      }\n    }\n    this.callCount -= 1;\n    this.lastActivityTimestamp = new Date();\n    this.maybeStartIdleTimer();\n  }\n\n  createLoadBalancingCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): LoadBalancingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"'\n    );\n    return new LoadBalancingCall(\n      this,\n      callConfig,\n      method,\n      host,\n      credentials,\n      deadline,\n      callNumber\n    );\n  }\n\n  createRetryingCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): RetryingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createRetryingCall [' + callNumber + '] method=\"' + method + '\"'\n    );\n    return new RetryingCall(\n      this,\n      callConfig,\n      method,\n      host,\n      credentials,\n      deadline,\n      callNumber,\n      this.retryBufferTracker,\n      RETRY_THROTTLER_MAP.get(this.getTarget())\n    );\n  }\n\n  createInnerCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): Call {\n    // Create a RetryingCall if retries are enabled\n    if (this.options['grpc.enable_retries'] === 0) {\n      return this.createLoadBalancingCall(\n        callConfig,\n        method,\n        host,\n        credentials,\n        deadline\n      );\n    } else {\n      return this.createRetryingCall(\n        callConfig,\n        method,\n        host,\n        credentials,\n        deadline\n      );\n    }\n  }\n\n  createResolvingCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): ResolvingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createResolvingCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\", deadline=' +\n        deadlineToString(deadline)\n    );\n    const finalOptions: CallStreamOptions = {\n      deadline: deadline,\n      flags: propagateFlags ?? Propagate.DEFAULTS,\n      host: host ?? this.defaultAuthority,\n      parentCall: parentCall,\n    };\n\n    const call = new ResolvingCall(\n      this,\n      method,\n      finalOptions,\n      this.filterStackFactory.clone(),\n      this.credentials._getCallCredentials(),\n      callNumber\n    );\n\n    this.onCallStart();\n    call.addStatusWatcher(status => {\n      this.onCallEnd(status);\n    });\n    return call;\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n    }\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n      this.lastActivityTimestamp = new Date();\n      this.maybeStartIdleTimer();\n    }\n    return connectivityState;\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate: Date =\n        deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(\n          callback,\n          new Error('Deadline passed without connectivity state change')\n        );\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(\n          new Error('Deadline passed without connectivity state change')\n        );\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer,\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    return this.createResolvingCall(\n      method,\n      deadline,\n      host,\n      parentCall,\n      propagateFlags\n    );\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8657, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8661, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ServerSurfaceCall } from './server-call';\n\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelRef } from './channelz';\nimport { Call } from './call-interface';\nimport { InternalChannel } from './internal-channel';\nimport { Deadline } from './deadline';\n\n/**\n * An interface that represents a communication channel to a server specified\n * by a given address.\n */\nexport interface Channel {\n  /**\n   * Close the channel. This has the same functionality as the existing\n   * grpc.Client.prototype.close\n   */\n  close(): void;\n  /**\n   * Return the target that this channel connects to\n   */\n  getTarget(): string;\n  /**\n   * Get the channel's current connectivity state. This method is here mainly\n   * because it is in the existing internal Channel class, and there isn't\n   * another good place to put it.\n   * @param tryToConnect If true, the channel will start connecting if it is\n   *     idle. Otherwise, idle channels will only start connecting when a\n   *     call starts.\n   */\n  getConnectivityState(tryToConnect: boolean): ConnectivityState;\n  /**\n   * Watch for connectivity state changes. This is also here mainly because\n   * it is in the existing external Channel class.\n   * @param currentState The state to watch for transitions from. This should\n   *     always be populated by calling getConnectivityState immediately\n   *     before.\n   * @param deadline A deadline for waiting for a state change\n   * @param callback Called with no error when a state change, or with an\n   *     error if the deadline passes without a state change.\n   */\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void;\n  /**\n   * Get the channelz reference object for this channel. A request to the\n   * channelz service for the id in this object will provide information\n   * about this channel.\n   */\n  getChannelzRef(): ChannelRef;\n  /**\n   * Create a call object. Call is an opaque type that is used by the Client\n   * class. This function is called by the gRPC library when starting a\n   * request. Implementers should return an instance of Call that is returned\n   * from calling createCall on an instance of the provided Channel class.\n   * @param method The full method string to request.\n   * @param deadline The call deadline\n   * @param host A host string override for making the request\n   * @param parentCall A server call to propagate some information from\n   * @param propagateFlags A bitwise combination of elements of grpc.propagate\n   *     that indicates what information to propagate from parentCall.\n   */\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call;\n}\n\nexport class ChannelImplementation implements Channel {\n  private internalChannel: InternalChannel;\n\n  constructor(\n    target: string,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n\n    this.internalChannel = new InternalChannel(target, credentials, options);\n  }\n\n  close() {\n    this.internalChannel.close();\n  }\n\n  getTarget() {\n    return this.internalChannel.getTarget();\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    return this.internalChannel.getConnectivityState(tryToConnect);\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    this.internalChannel.watchConnectivityState(\n      currentState,\n      deadline,\n      callback\n    );\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.internalChannel.getChannelzRef();\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    return this.internalChannel.createCall(\n      method,\n      deadline,\n      host,\n      parentCall,\n      propagateFlags\n    );\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAiBA,MAAA;AAOA,MAAA;AAoEA,MAAa;IAGX,YACE,MAAc,EACd,WAA+B,EAC/B,OAAuB,CAAA;QAEvB,IAAI,OAAO,WAAW,UAAU;YAC9B,MAAM,IAAI,UAAU;QACtB;QACA,IAAI,CAAC,CAAC,uBAAuB,sBAAA,kBAAkB,GAAG;YAChD,MAAM,IAAI,UACR;QAEJ;QACA,IAAI,SAAS;YACX,IAAI,OAAO,YAAY,UAAU;gBAC/B,MAAM,IAAI,UAAU;YACtB;QACF;QAEA,IAAI,CAAC,eAAe,GAAG,IAAI,mBAAA,eAAe,CAAC,QAAQ,aAAa;IAClE;IAEA,QAAK;QACH,IAAI,CAAC,eAAe,CAAC,KAAK;IAC5B;IAEA,YAAS;QACP,OAAO,IAAI,CAAC,eAAe,CAAC,SAAS;IACvC;IAEA,qBAAqB,YAAqB,EAAA;QACxC,OAAO,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC;IACnD;IAEA,uBACE,YAA+B,EAC/B,QAAuB,EACvB,QAAiC,EAAA;QAEjC,IAAI,CAAC,eAAe,CAAC,sBAAsB,CACzC,cACA,UACA;IAEJ;IAEA;;;;QAKA,iBAAc;QACZ,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc;IAC5C;IAEA,WACE,MAAc,EACd,QAAkB,EAClB,IAA+B,EAC/B,UAAoC,EACpC,cAAyC,EAAA;QAEzC,IAAI,OAAO,WAAW,UAAU;YAC9B,MAAM,IAAI,UAAU;QACtB;QACA,IAAI,CAAC,CAAC,OAAO,aAAa,YAAY,oBAAoB,IAAI,GAAG;YAC/D,MAAM,IAAI,UACR;QAEJ;QACA,OAAO,IAAI,CAAC,eAAe,CAAC,UAAU,CACpC,QACA,UACA,MACA,YACA;IAEJ;;AAhFF,QAAA,qBAAA,GAAA"}},
    {"offset": {"line": 8728, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8732, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/server-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { EventEmitter } from 'events';\nimport * as http2 from 'http2';\nimport { Duplex, Readable, Writable } from 'stream';\nimport * as zlib from 'zlib';\n\nimport {\n  Status,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n  LogVerbosity,\n} from './constants';\nimport { Deserialize, Serialize } from './make-client';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport { ObjectReadable, ObjectWritable } from './object-stream';\nimport { ChannelOptions } from './channel-options';\nimport * as logging from './logging';\nimport { StatusObject, PartialStatusObject } from './call-interface';\nimport { Deadline } from './deadline';\nimport { getErrorCode, getErrorMessage } from './error';\n\nconst TRACER_NAME = 'server_call';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface DeadlineUnitIndexSignature {\n  [name: string]: number;\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs: DeadlineUnitIndexSignature = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001,\n};\nconst defaultCompressionHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n};\nconst defaultResponseHeaders = {\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true,\n} as http2.ServerStreamResponseOptions;\n\nexport type ServerStatusResponse = Partial<StatusObject>;\n\nexport type ServerErrorResponse = ServerStatusResponse & Error;\n\nexport type ServerSurfaceCall = {\n  cancelled: boolean;\n  readonly metadata: Metadata;\n  getPeer(): string;\n  sendMetadata(responseMetadata: Metadata): void;\n  getDeadline(): Deadline;\n  getPath(): string;\n} & EventEmitter;\n\nexport type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & {\n  request: RequestType;\n};\nexport type ServerReadableStream<RequestType, ResponseType> =\n  ServerSurfaceCall & ObjectReadable<RequestType>;\nexport type ServerWritableStream<RequestType, ResponseType> =\n  ServerSurfaceCall &\n    ObjectWritable<ResponseType> & {\n      request: RequestType;\n      end: (metadata?: Metadata) => void;\n    };\nexport type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall &\n  ObjectReadable<RequestType> &\n  ObjectWritable<ResponseType> & { end: (metadata?: Metadata) => void };\n\nexport class ServerUnaryCallImpl<RequestType, ResponseType>\n  extends EventEmitter\n  implements ServerUnaryCall<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public request: RequestType\n  ) {\n    super();\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerReadableStreamImpl<RequestType, ResponseType>\n  extends Readable\n  implements ServerReadableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n\n  _read(size: number) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerWritableStreamImpl<RequestType, ResponseType>\n  extends Writable\n  implements ServerWritableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public request: RequestType\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  _write(\n    chunk: ResponseType,\n    encoding: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (...args: any[]) => void\n  ) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      this.emit('error', {\n        details: getErrorMessage(err),\n        code: Status.INTERNAL,\n      });\n    }\n\n    callback();\n  }\n\n  _final(callback: Function): void {\n    this.call.sendStatus({\n      code: Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata,\n    });\n    callback(null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nexport class ServerDuplexStreamImpl<RequestType, ResponseType>\n  extends Duplex\n  implements ServerDuplexStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  /* This field appears to be unsued, but it is actually used in _final, which is assiged from\n   * ServerWritableStreamImpl.prototype._final below. */\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore noUnusedLocals\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nServerDuplexStreamImpl.prototype._read =\n  ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n  ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n  ServerWritableStreamImpl.prototype._final;\n\n// Unary response callback signature.\nexport type sendUnaryData<ResponseType> = (\n  error: ServerErrorResponse | ServerStatusResponse | null,\n  value?: ResponseType | null,\n  trailer?: Metadata,\n  flags?: number\n) => void;\n\n// User provided handler for unary calls.\nexport type handleUnaryCall<RequestType, ResponseType> = (\n  call: ServerUnaryCall<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for client streaming calls.\nexport type handleClientStreamingCall<RequestType, ResponseType> = (\n  call: ServerReadableStream<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for server streaming calls.\nexport type handleServerStreamingCall<RequestType, ResponseType> = (\n  call: ServerWritableStream<RequestType, ResponseType>\n) => void;\n\n// User provided handler for bidirectional streaming calls.\nexport type handleBidiStreamingCall<RequestType, ResponseType> = (\n  call: ServerDuplexStream<RequestType, ResponseType>\n) => void;\n\nexport type HandleCall<RequestType, ResponseType> =\n  | handleUnaryCall<RequestType, ResponseType>\n  | handleClientStreamingCall<RequestType, ResponseType>\n  | handleServerStreamingCall<RequestType, ResponseType>\n  | handleBidiStreamingCall<RequestType, ResponseType>;\n\nexport interface UnaryHandler<RequestType, ResponseType> {\n  func: handleUnaryCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ClientStreamingHandler<RequestType, ResponseType> {\n  func: handleClientStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ServerStreamingHandler<RequestType, ResponseType> {\n  func: handleServerStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface BidiStreamingHandler<RequestType, ResponseType> {\n  func: handleBidiStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport type Handler<RequestType, ResponseType> =\n  | UnaryHandler<RequestType, ResponseType>\n  | ClientStreamingHandler<RequestType, ResponseType>\n  | ServerStreamingHandler<RequestType, ResponseType>\n  | BidiStreamingHandler<RequestType, ResponseType>;\n\nexport type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';\n\n// Internal class that wraps the HTTP2 request.\nexport class Http2ServerCallStream<\n  RequestType,\n  ResponseType\n> extends EventEmitter {\n  cancelled = false;\n  deadlineTimer: NodeJS.Timeout | null = null;\n  private statusSent = false;\n  private deadline: Deadline = Infinity;\n  private wantTrailers = false;\n  private metadataSent = false;\n  private canPush = false;\n  private isPushPending = false;\n  private bufferedMessages: Array<Buffer | null> = [];\n  private messagesToPush: Array<RequestType | null> = [];\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n  constructor(\n    private stream: http2.ServerHttp2Stream,\n    private handler: Handler<RequestType, ResponseType>,\n    options: ChannelOptions\n  ) {\n    super();\n\n    this.stream.once('error', (err: ServerErrorResponse) => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n\n    this.stream.once('close', () => {\n      trace(\n        'Request to method ' +\n          this.handler?.path +\n          ' stream closed with rstCode ' +\n          this.stream.rstCode\n      );\n\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null,\n        });\n        if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n      }\n    });\n\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n  }\n\n  private checkCancelled(): boolean {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n\n  private getDecompressedMessage(\n    message: Buffer,\n    encoding: string\n  ): Buffer | Promise<Buffer> {    const messageContents = message.subarray(5);\n    if (encoding === 'identity') {\n      return messageContents;\n    } else if (encoding === 'deflate' || encoding === 'gzip') {\n      let decompresser: zlib.Gunzip | zlib.Deflate;\n      if (encoding === 'deflate') {\n        decompresser = zlib.createInflate();\n      } else {\n        decompresser = zlib.createGunzip();\n      }\n      return new Promise((resolve, reject) => {\n        let totalLength = 0\n        const messageParts: Buffer[] = [];\n        decompresser.on('data', (chunk: Buffer) => {\n          messageParts.push(chunk);\n          totalLength += chunk.byteLength;\n          if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\n            decompresser.destroy();\n            reject({\n              code: Status.RESOURCE_EXHAUSTED,\n              details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\n            });\n          }\n        });\n        decompresser.on('end', () => {\n          resolve(Buffer.concat(messageParts));\n        });\n        decompresser.write(messageContents);\n        decompresser.end();\n      });\n    } else {\n      return Promise.reject({\n        code: Status.UNIMPLEMENTED,\n        details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n      });\n    }\n  }\n\n  sendMetadata(customMetadata?: Metadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = {\n      ...defaultResponseHeaders,\n      ...defaultCompressionHeaders,\n      ...custom,\n    };\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers: http2.IncomingHttpHeaders) {\n    const metadata = Metadata.fromHttp2Headers(headers);\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace(\n        'Request to ' +\n          this.handler.path +\n          ' received headers ' +\n          JSON.stringify(metadata.toJSON())\n      );\n    }\n\n    // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline') as ServerErrorResponse;\n        err.code = Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n\n      const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n\n    return metadata;\n  }\n\n  receiveUnaryMessage(encoding: string): Promise<RequestType> {\n    return new Promise((resolve, reject) => {\n      const { stream } = this;\n\n      let receivedLength = 0;\n\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const call = this;\n      const body: Buffer[] = [];\n      const limit = this.maxReceiveMessageSize;\n\n      this.stream.on('data', onData);\n      this.stream.on('end', onEnd);\n      this.stream.on('error', onEnd);\n\n      function onData(chunk: Buffer) {\n        receivedLength += chunk.byteLength;\n\n        if (limit !== -1 && receivedLength > limit) {\n          stream.removeListener('data', onData);\n          stream.removeListener('end', onEnd);\n          stream.removeListener('error', onEnd);\n\n          reject({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n          });\n          return;\n        }\n\n        body.push(chunk);\n      }\n\n      function onEnd(err?: Error) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n\n        if (err !== undefined) {\n          reject({ code: Status.INTERNAL, details: err.message });\n          return;\n        }\n\n        if (receivedLength === 0) {\n          reject({\n            code: Status.INTERNAL,\n            details: 'received empty unary message',\n          });\n          return;\n        }\n\n        call.emit('receiveMessage');\n\n        const requestBytes = Buffer.concat(body, receivedLength);\n        const compressed = requestBytes.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = call.getDecompressedMessage(\n          requestBytes,\n          compressedMessageEncoding\n        );\n\n        if (Buffer.isBuffer(decompressedMessage)) {\n          resolve(\n            call.deserializeMessageWithInternalError(decompressedMessage)\n          );\n          return;\n        }\n\n        decompressedMessage.then(\n          decompressed =>\n            resolve(call.deserializeMessageWithInternalError(decompressed)),\n          (err: any) =>\n            reject(\n              err.code\n                ? err\n                : {\n                    code: Status.INTERNAL,\n                    details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n                  }\n            )\n        );\n      }\n    });\n  }\n\n  private async deserializeMessageWithInternalError(buffer: Buffer) {\n    try {\n      return this.deserializeMessage(buffer);\n    } catch (err) {\n      throw {\n        details: getErrorMessage(err),\n        code: Status.INTERNAL,\n      };\n    }\n  }\n\n  serializeMessage(value: ResponseType) {\n    const messageBuffer = this.handler.serialize(value);\n\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes: Buffer) {\n    return this.handler.deserialize(bytes);\n  }\n\n  async sendUnaryMessage(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    metadata?: Metadata | null,\n    flags?: number\n  ) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (metadata === undefined) {\n      metadata = null;\n    }\n\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n\n    try {\n      const response = this.serializeMessage(value!);\n\n      this.write(response);\n      this.sendStatus({ code: Status.OK, details: 'OK', metadata });\n    } catch (err) {\n      this.sendError({\n        details: getErrorMessage(err),\n        code: Status.INTERNAL,\n      });\n    }\n  }\n\n  sendStatus(statusObj: PartialStatusObject) {\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace(\n      'Request to method ' +\n        this.handler?.path +\n        ' ended with status code: ' +\n        Status[statusObj.code] +\n        ' details: ' +\n        statusObj.details\n    );\n\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n\n    if (this.stream.headersSent) {\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', () => {\n          const trailersToSend = {\n            [GRPC_STATUS_HEADER]: statusObj.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n            ...statusObj.metadata?.toHttp2Headers(),\n          };\n\n          this.stream.sendTrailers(trailersToSend);\n          this.statusSent = true;\n        });\n        this.stream.end();\n      }\n    } else {\n      // Trailers-only response\n      const trailersToSend = {\n        [GRPC_STATUS_HEADER]: statusObj.code,\n        [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n        ...defaultResponseHeaders,\n        ...statusObj.metadata?.toHttp2Headers(),\n      };\n      this.stream.respond(trailersToSend, { endStream: true });\n      this.statusSent = true;\n    }\n  }\n\n  sendError(error: ServerErrorResponse | ServerStatusResponse) {\n    const status: PartialStatusObject = {\n      code: Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata:\n        'metadata' in error && error.metadata !== undefined\n          ? error.metadata\n          : null,\n    };\n\n    if (\n      'code' in error &&\n      typeof error.code === 'number' &&\n      Number.isInteger(error.code)\n    ) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details!;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk: Buffer) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (\n      this.maxSendMessageSize !== -1 &&\n      chunk.length > this.maxSendMessageSize\n    ) {\n      this.sendError({\n        code: Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call: ServerSurfaceCall) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n\n    this.once('callEnd', status => call.emit('callEnd', status));\n  }\n\n  setupReadable(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    encoding: string\n  ) {\n    const decoder = new StreamDecoder(this.maxReceiveMessageSize);\n\n    let readsDone = false;\n\n    let pendingMessageProcessing = false;\n\n    let pushedEnd = false;\n\n    const maybePushEnd = async () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        await this.pushOrBufferMessage(readable, null);\n      }\n    };\n\n    this.stream.on('data', async (data: Buffer) => {\n      let messages: Buffer[];\n      try {\n        messages = decoder.write(data);\n      } catch (e) {\n        this.sendError({\n          code: Status.RESOURCE_EXHAUSTED,\n          details: (e as Error).message\n        });\n        return;\n      }\n\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        this.emit('receiveMessage');\n\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        let decompressedMessage: Buffer;\n        try {\n          decompressedMessage = await this.getDecompressedMessage(\n            message,\n            compressedMessageEncoding\n          );\n        } catch (e) {\n          this.sendError(e as Partial<StatusObject>);\n          return;\n        }\n\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n\n        await this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      await maybePushEnd();\n    });\n\n    this.stream.once('end', async () => {\n      readsDone = true;\n      await maybePushEnd();\n    });\n  }\n\n  consumeUnpushedMessages(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>\n  ): boolean {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  private async pushOrBufferMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ): Promise<void> {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      await this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  private async pushMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n\n      return;\n    }\n\n    trace('Received message of length ' + messageBytes.length);\n\n    this.isPushPending = true;\n\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n      let code = getErrorCode(error);\n      if (code === null || code < Status.OK || code > Status.UNAUTHENTICATED) {\n        code = Status.INTERNAL;\n      }\n\n      readable.emit('error', {\n        details: getErrorMessage(error),\n        code: code,\n      });\n    }\n\n    this.isPushPending = false;\n\n    if (this.bufferedMessages.length > 0) {\n      await this.pushMessage(\n        readable,\n        this.bufferedMessages.shift() as Buffer | null\n      );\n    }\n  }\n\n  getPeer(): string {\n    const socket = this.stream.session?.socket;\n    if (socket?.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline(): Deadline {\n    return this.deadline;\n  }\n\n  getPath(): string {\n    return this.handler.path;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedServerCall = Http2ServerCallStream<any, any>;\n\nfunction handleExpiredDeadline(call: UntypedServerCall) {\n  const err = new Error('Deadline exceeded') as ServerErrorResponse;\n  err.code = Status.DEADLINE_EXCEEDED;\n\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9406, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9410, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/server-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { SecureServerOptions } from 'http2';\nimport { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';\n\nexport interface KeyCertPair {\n  private_key: Buffer;\n  cert_chain: Buffer;\n}\n\nexport abstract class ServerCredentials {\n  abstract _isSecure(): boolean;\n  abstract _getSettings(): SecureServerOptions | null;\n\n  static createInsecure(): ServerCredentials {\n    return new InsecureServerCredentials();\n  }\n\n  static createSsl(\n    rootCerts: Buffer | null,\n    keyCertPairs: KeyCertPair[],\n    checkClientCertificate = false\n  ): ServerCredentials {\n    if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n      throw new TypeError('rootCerts must be null or a Buffer');\n    }\n\n    if (!Array.isArray(keyCertPairs)) {\n      throw new TypeError('keyCertPairs must be an array');\n    }\n\n    if (typeof checkClientCertificate !== 'boolean') {\n      throw new TypeError('checkClientCertificate must be a boolean');\n    }\n\n    const cert = [];\n    const key = [];\n\n    for (let i = 0; i < keyCertPairs.length; i++) {\n      const pair = keyCertPairs[i];\n\n      if (pair === null || typeof pair !== 'object') {\n        throw new TypeError(`keyCertPair[${i}] must be an object`);\n      }\n\n      if (!Buffer.isBuffer(pair.private_key)) {\n        throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n      }\n\n      if (!Buffer.isBuffer(pair.cert_chain)) {\n        throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n      }\n\n      cert.push(pair.cert_chain);\n      key.push(pair.private_key);\n    }\n\n    return new SecureServerCredentials({\n      ca: rootCerts || getDefaultRootsData() || undefined,\n      cert,\n      key,\n      requestCert: checkClientCertificate,\n      ciphers: CIPHER_SUITES,\n    });\n  }\n}\n\nclass InsecureServerCredentials extends ServerCredentials {\n  _isSecure(): boolean {\n    return false;\n  }\n\n  _getSettings(): null {\n    return null;\n  }\n}\n\nclass SecureServerCredentials extends ServerCredentials {\n  private options: SecureServerOptions;\n\n  constructor(options: SecureServerOptions) {\n    super();\n    this.options = options;\n  }\n\n  _isSecure(): boolean {\n    return true;\n  }\n\n  _getSettings(): SecureServerOptions {\n    return this.options;\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAkBA,MAAA;AAOA,MAAsB;IAIpB,OAAO,iBAAc;QACnB,OAAO,IAAI;IACb;IAEA,OAAO,UACL,SAAwB,EACxB,YAA2B,EAC3B,yBAAyB,KAAK,EAAA;QAE9B,IAAI,cAAc,QAAQ,CAAC,OAAO,QAAQ,CAAC,YAAY;YACrD,MAAM,IAAI,UAAU;QACtB;QAEA,IAAI,CAAC,MAAM,OAAO,CAAC,eAAe;YAChC,MAAM,IAAI,UAAU;QACtB;QAEA,IAAI,OAAO,2BAA2B,WAAW;YAC/C,MAAM,IAAI,UAAU;QACtB;QAEA,MAAM,OAAO,EAAE;QACf,MAAM,MAAM,EAAE;QAEd,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,MAAM,EAAE,IAAK;YAC5C,MAAM,OAAO,YAAY,CAAC,EAAE;YAE5B,IAAI,SAAS,QAAQ,OAAO,SAAS,UAAU;gBAC7C,MAAM,IAAI,UAAU,CAAA,YAAA,EAAe,EAAC,mBAAA,CAAqB;YAC3D;YAEA,IAAI,CAAC,OAAO,QAAQ,CAAC,KAAK,WAAW,GAAG;gBACtC,MAAM,IAAI,UAAU,CAAA,YAAA,EAAe,EAAC,8BAAA,CAAgC;YACtE;YAEA,IAAI,CAAC,OAAO,QAAQ,CAAC,KAAK,UAAU,GAAG;gBACrC,MAAM,IAAI,UAAU,CAAA,YAAA,EAAe,EAAC,6BAAA,CAA+B;YACrE;YAEA,KAAK,IAAI,CAAC,KAAK,UAAU;YACzB,IAAI,IAAI,CAAC,KAAK,WAAW;QAC3B;QAEA,OAAO,IAAI,wBAAwB;YACjC,IAAI,aAAa,CAAA,GAAA,cAAA,mBAAmB,OAAM;YAC1C;YACA;YACA,aAAa;YACb,SAAS,cAAA,aAAa;;IAE1B;;AAtDF,QAAA,iBAAA,GAAA;AAyDA,MAAM,kCAAkC;IACtC,YAAS;QACP,OAAO;IACT;IAEA,eAAY;QACV,OAAO;IACT;;AAGF,MAAM,gCAAgC;IAGpC,YAAY,OAA4B,CAAA;QACtC,KAAK;QACL,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,YAAS;QACP,OAAO;IACT;IAEA,eAAY;QACV,OAAO,IAAI,CAAC,OAAO;IACrB"}},
    {"offset": {"line": 9491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9495, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/server.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { AddressInfo } from 'net';\n\nimport { ServiceError } from './call';\nimport { Status, LogVerbosity } from './constants';\nimport { Deserialize, Serialize, ServiceDefinition } from './make-client';\nimport { Metadata } from './metadata';\nimport {\n  BidiStreamingHandler,\n  ClientStreamingHandler,\n  HandleCall,\n  Handler,\n  HandlerType,\n  Http2ServerCallStream,\n  sendUnaryData,\n  ServerDuplexStream,\n  ServerDuplexStreamImpl,\n  ServerReadableStream,\n  ServerReadableStreamImpl,\n  ServerStreamingHandler,\n  ServerUnaryCall,\n  ServerUnaryCallImpl,\n  ServerWritableStream,\n  ServerWritableStreamImpl,\n  UnaryHandler,\n  ServerErrorResponse,\n  ServerStatusResponse,\n} from './server-call';\nimport { ServerCredentials } from './server-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  createResolver,\n  ResolverListener,\n  mapUriDefaultScheme,\n} from './resolver';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  TcpSubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n  stringToSubchannelAddress,\n} from './subchannel-address';\nimport { parseUri } from './uri-parser';\nimport {\n  ChannelzCallTracker,\n  ChannelzChildrenTracker,\n  ChannelzTrace,\n  registerChannelzServer,\n  registerChannelzSocket,\n  ServerInfo,\n  ServerRef,\n  SocketInfo,\n  SocketRef,\n  TlsInfo,\n  unregisterChannelzRef,\n} from './channelz';\nimport { CipherNameAndProtocol, TLSSocket } from 'tls';\n\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nconst { HTTP2_HEADER_PATH } = http2.constants;\n\nconst TRACER_NAME = 'server';\n\ninterface BindResult {\n  port: number;\n  count: number;\n}\n\nfunction noop(): void {}\n\nfunction getUnimplementedStatusResponse(\n  methodName: string\n): Partial<ServiceError> {\n  return {\n    code: Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedUnaryHandler = UnaryHandler<any, any>;\ntype UntypedClientStreamingHandler = ClientStreamingHandler<any, any>;\ntype UntypedServerStreamingHandler = ServerStreamingHandler<any, any>;\ntype UntypedBidiStreamingHandler = BidiStreamingHandler<any, any>;\nexport type UntypedHandleCall = HandleCall<any, any>;\ntype UntypedHandler = Handler<any, any>;\nexport interface UntypedServiceImplementation {\n  [name: string]: UntypedHandleCall;\n}\n\nfunction getDefaultHandler(handlerType: HandlerType, methodName: string) {\n  const unimplementedStatusResponse =\n    getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (\n        call: ServerUnaryCall<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'clientStream':\n      return (\n        call: ServerReadableStream<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'serverStream':\n      return (call: ServerWritableStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return (call: ServerDuplexStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\ninterface ChannelzSessionInfo {\n  ref: SocketRef;\n  streamTracker: ChannelzCallTracker;\n  messagesSent: number;\n  messagesReceived: number;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n}\n\nexport class Server {\n  private http2ServerList: {\n    server: http2.Http2Server | http2.Http2SecureServer;\n    channelzRef: SocketRef;\n  }[] = [];\n\n  private handlers: Map<string, UntypedHandler> = new Map<\n    string,\n    UntypedHandler\n  >();\n  private sessions = new Map<http2.ServerHttp2Session, ChannelzSessionInfo>();\n  private started = false;\n  private shutdown = false;\n  private options: ChannelOptions;\n  private serverAddressString = 'null';\n\n  // Channelz Info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: ServerRef;\n  private channelzTrace = new ChannelzTrace();\n  private callTracker = new ChannelzCallTracker();\n  private listenerChildrenTracker = new ChannelzChildrenTracker();\n  private sessionChildrenTracker = new ChannelzChildrenTracker();\n\n  private readonly maxConnectionAgeMs: number;\n  private readonly maxConnectionAgeGraceMs: number;\n\n  private readonly keepaliveTimeMs: number;\n  private readonly keepaliveTimeoutMs: number;\n\n  constructor(options?: ChannelOptions) {\n    this.options = options ?? {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = registerChannelzServer(\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n    }\n    this.maxConnectionAgeMs =\n      this.options['grpc.max_connection_age_ms'] ?? UNLIMITED_CONNECTION_AGE_MS;\n    this.maxConnectionAgeGraceMs =\n      this.options['grpc.max_connection_age_grace_ms'] ??\n      UNLIMITED_CONNECTION_AGE_MS;\n    this.keepaliveTimeMs =\n      this.options['grpc.keepalive_time_ms'] ?? KEEPALIVE_MAX_TIME_MS;\n    this.keepaliveTimeoutMs =\n      this.options['grpc.keepalive_timeout_ms'] ?? KEEPALIVE_TIMEOUT_MS;\n    this.trace('Server constructed');\n  }\n\n  private getChannelzInfo(): ServerInfo {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists(),\n    };\n  }\n\n  private getChannelzSessionInfoGetter(\n    session: http2.ServerHttp2Session\n  ): () => SocketInfo {\n    return () => {\n      const sessionInfo = this.sessions.get(session)!;\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress\n        ? stringToSubchannelAddress(\n            sessionSocket.remoteAddress,\n            sessionSocket.remotePort\n          )\n        : null;\n      const localAddress = sessionSocket.localAddress\n        ? stringToSubchannelAddress(\n            sessionSocket.localAddress!,\n            sessionSocket.localPort\n          )\n        : null;\n      let tlsInfo: TlsInfo | null;\n      if (session.encrypted) {\n        const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n        const cipherInfo: CipherNameAndProtocol & { standardName?: string } =\n          tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: cipherInfo.standardName ?? null,\n          cipherSuiteOtherName: cipherInfo.standardName\n            ? null\n            : cipherInfo.name,\n          localCertificate:\n            certificate && 'raw' in certificate ? certificate.raw : null,\n          remoteCertificate:\n            peerCertificate && 'raw' in peerCertificate\n              ? peerCertificate.raw\n              : null,\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo: SocketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: 0,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp:\n          sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: session.state.localWindowSize ?? null,\n        remoteFlowControlWindow: session.state.remoteWindowSize ?? null,\n      };\n      return socketInfo;\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' + this.channelzRef.id + ') ' + text\n    );\n  }\n\n  addProtoService(): never {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(\n    service: ServiceDefinition,\n    implementation: UntypedServiceImplementation\n  ): void {\n    if (\n      service === null ||\n      typeof service !== 'object' ||\n      implementation === null ||\n      typeof implementation !== 'object'\n    ) {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType: HandlerType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(\n        attrs.path,\n        impl as UntypedHandleCall,\n        attrs.responseSerialize,\n        attrs.requestDeserialize,\n        methodType\n      );\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service: ServiceDefinition): void {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port: string, creds: ServerCredentials): never {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(\n    port: string,\n    creds: ServerCredentials,\n    callback: (error: Error | null, port: number) => void\n  ): void {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (this.shutdown) {\n      throw new Error('bindAsync called after shutdown');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || !(creds instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const initialPortUri = parseUri(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = mapUriDefaultScheme(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n\n    const serverOptions: http2.ServerOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory =\n        this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n      };\n    }\n\n    const deferredCallback = (error: Error | null, port: number) => {\n      process.nextTick(() => callback(error, port));\n    };\n\n    const setupServer = (): http2.Http2Server | http2.Http2SecureServer => {\n      let http2Server: http2.Http2Server | http2.Http2SecureServer;\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(\n          serverOptions,\n          creds._getSettings()!\n        );\n        secureServerOptions.enableTrace =\n          this.options['grpc-node.tls_enable_trace'] === 1;\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('secureConnection', (socket: TLSSocket) => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', (e: Error) => {\n            this.trace(\n              'An incoming TLS connection closed with error: ' + e.message\n            );\n          });\n        });\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server);\n      return http2Server;\n    };\n\n    const bindSpecificPort = (\n      addressList: SubchannelAddress[],\n      portNum: number,\n      previousCount: number\n    ): Promise<BindResult> => {\n      if (addressList.length === 0) {\n        return Promise.resolve({ port: portNum, count: previousCount });\n      }\n      return Promise.all(\n        addressList.map(address => {\n          this.trace(\n            'Attempting to bind ' + subchannelAddressToString(address)\n          );\n          let addr: SubchannelAddress;\n          if (isTcpSubchannelAddress(address)) {\n            addr = {\n              host: (address as TcpSubchannelAddress).host,\n              port: portNum,\n            };\n          } else {\n            addr = address;\n          }\n\n          const http2Server = setupServer();\n          return new Promise<number | Error>((resolve, reject) => {\n            const onError = (err: Error) => {\n              this.trace(\n                'Failed to bind ' +\n                  subchannelAddressToString(address) +\n                  ' with error ' +\n                  err.message\n              );\n              resolve(err);\n            };\n\n            http2Server.once('error', onError);\n\n            http2Server.listen(addr, () => {\n              if (this.shutdown) {\n                http2Server.close();\n                resolve(new Error('bindAsync failed because server is shutdown'));\n                return;\n              }\n              const boundAddress = http2Server.address()!;\n              let boundSubchannelAddress: SubchannelAddress;\n              if (typeof boundAddress === 'string') {\n                boundSubchannelAddress = {\n                  path: boundAddress,\n                };\n              } else {\n                boundSubchannelAddress = {\n                  host: boundAddress.address,\n                  port: boundAddress.port,\n                };\n              }\n\n              const channelzRef = registerChannelzSocket(\n                subchannelAddressToString(boundSubchannelAddress),\n                () => {\n                  return {\n                    localAddress: boundSubchannelAddress,\n                    remoteAddress: null,\n                    security: null,\n                    remoteName: null,\n                    streamsStarted: 0,\n                    streamsSucceeded: 0,\n                    streamsFailed: 0,\n                    messagesSent: 0,\n                    messagesReceived: 0,\n                    keepAlivesSent: 0,\n                    lastLocalStreamCreatedTimestamp: null,\n                    lastRemoteStreamCreatedTimestamp: null,\n                    lastMessageSentTimestamp: null,\n                    lastMessageReceivedTimestamp: null,\n                    localFlowControlWindow: null,\n                    remoteFlowControlWindow: null,\n                  };\n                },\n                this.channelzEnabled\n              );\n              if (this.channelzEnabled) {\n                this.listenerChildrenTracker.refChild(channelzRef);\n              }\n              this.http2ServerList.push({\n                server: http2Server,\n                channelzRef: channelzRef,\n              });\n              this.trace(\n                'Successfully bound ' +\n                  subchannelAddressToString(boundSubchannelAddress)\n              );\n              resolve(\n                'port' in boundSubchannelAddress\n                  ? boundSubchannelAddress.port\n                  : portNum\n              );\n              http2Server.removeListener('error', onError);\n            });\n          });\n        })\n      ).then(results => {\n        let count = 0;\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n            if (result !== portNum) {\n              throw new Error(\n                'Invalid state: multiple port numbers added from single address'\n              );\n            }\n          }\n        }\n        return {\n          port: portNum,\n          count: count + previousCount,\n        };\n      });\n    };\n\n    const bindWildcardPort = (\n      addressList: SubchannelAddress[]\n    ): Promise<BindResult> => {\n      if (addressList.length === 0) {\n        return Promise.resolve<BindResult>({ port: 0, count: 0 });\n      }\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise<BindResult>((resolve, reject) => {\n        const onError = (err: Error) => {\n          this.trace(\n            'Failed to bind ' +\n              subchannelAddressToString(address) +\n              ' with error ' +\n              err.message\n          );\n          resolve(bindWildcardPort(addressList.slice(1)));\n        };\n\n        http2Server.once('error', onError);\n\n        http2Server.listen(address, () => {\n          if (this.shutdown) {\n            http2Server.close();\n            resolve({port: 0, count: 0});\n            return;\n          }\n          const boundAddress = http2Server.address() as AddressInfo;\n          const boundSubchannelAddress: SubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port,\n          };\n          const channelzRef = registerChannelzSocket(\n            subchannelAddressToString(boundSubchannelAddress),\n            () => {\n              return {\n                localAddress: boundSubchannelAddress,\n                remoteAddress: null,\n                security: null,\n                remoteName: null,\n                streamsStarted: 0,\n                streamsSucceeded: 0,\n                streamsFailed: 0,\n                messagesSent: 0,\n                messagesReceived: 0,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: null,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null,\n                localFlowControlWindow: null,\n                remoteFlowControlWindow: null,\n              };\n            },\n            this.channelzEnabled\n          );\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.refChild(channelzRef);\n          }\n          this.http2ServerList.push({\n            server: http2Server,\n            channelzRef: channelzRef,\n          });\n          this.trace(\n            'Successfully bound ' +\n              subchannelAddressToString(boundSubchannelAddress)\n          );\n          resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n\n    const resolverListener: ResolverListener = {\n      onSuccessfulResolution: (\n        addressList,\n        serviceConfig,\n        serviceConfigError\n      ) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n        if (this.shutdown) {\n          deferredCallback(\n            new Error(`bindAsync failed because server is shutdown`),\n            0\n          );\n        }\n        if (addressList.length === 0) {\n          deferredCallback(\n            new Error(`No addresses resolved for port ${port}`),\n            0\n          );\n          return;\n        }\n        let bindResultPromise: Promise<BindResult>;\n        if (isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(\n              addressList,\n              addressList[0].port,\n              0\n            );\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n        bindResultPromise.then(\n          bindResult => {\n            if (bindResult.count === 0) {\n              const errorString = `No address added out of total ${addressList.length} resolved`;\n              logging.log(LogVerbosity.ERROR, errorString);\n              deferredCallback(new Error(errorString), 0);\n            } else {\n              if (bindResult.count < addressList.length) {\n                logging.log(\n                  LogVerbosity.INFO,\n                  `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`\n                );\n              }\n              deferredCallback(null, bindResult.port);\n            }\n          },\n          error => {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(LogVerbosity.ERROR, errorString);\n            deferredCallback(new Error(errorString), 0);\n          }\n        );\n      },\n      onError: error => {\n        deferredCallback(new Error(error.details), 0);\n      },\n    };\n\n    const resolver = createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n\n  forceShutdown(): void {\n    // Close the server if it is still running.\n\n    for (const { server: http2Server, channelzRef: ref } of this\n      .http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            unregisterChannelzRef(ref);\n          }\n        });\n      }\n    }\n\n    this.started = false;\n    this.shutdown = true;\n\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n    });\n    this.sessions.clear();\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n  }\n\n  register<RequestType, ResponseType>(\n    name: string,\n    handler: HandleCall<RequestType, ResponseType>,\n    serialize: Serialize<ResponseType>,\n    deserialize: Deserialize<RequestType>,\n    type: string\n  ): boolean {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name,\n    } as UntypedHandler);\n    return true;\n  }\n\n  unregister(name: string): boolean {\n    return this.handlers.delete(name);\n  }\n\n  start(): void {\n    if (\n      this.http2ServerList.length === 0 ||\n      this.http2ServerList.every(\n        ({ server: http2Server }) => http2Server.listening !== true\n      )\n    ) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Starting');\n    }\n    this.started = true;\n  }\n\n  tryShutdown(callback: (error?: Error) => void): void {\n    const wrappedCallback = (error?: Error) => {\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n      callback(error);\n    };\n    let pendingChecks = 0;\n\n    function maybeCallback(): void {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n\n    // Close the server if necessary.\n    this.started = false;\n    this.shutdown = true;\n\n    for (const { server: http2Server, channelzRef: ref } of this\n      .http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            unregisterChannelzRef(ref);\n          }\n          maybeCallback();\n        });\n      }\n    }\n\n    this.sessions.forEach((channelzInfo, session) => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n\n  addHttp2Port(): never {\n    throw new Error('Not yet implemented');\n  }\n\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  private _verifyContentType(\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ): boolean {\n    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n    if (\n      typeof contentType !== 'string' ||\n      !contentType.startsWith('application/grpc')\n    ) {\n      stream.respond(\n        {\n          [http2.constants.HTTP2_HEADER_STATUS]:\n            http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n        },\n        { endStream: true }\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  private _retrieveHandler(path: string): Handler<any, any> | null {\n    this.trace(\n      'Received call to method ' +\n        path +\n        ' at address ' +\n        this.serverAddressString\n    );\n\n    const handler = this.handlers.get(path);\n\n    if (handler === undefined) {\n      this.trace(\n        'No handler registered for method ' +\n          path +\n          '. Sending UNIMPLEMENTED status.'\n      );\n      return null;\n    }\n\n    return handler;\n  }\n\n  private _respondWithError<T extends Partial<ServiceError>>(\n    err: T,\n    stream: http2.ServerHttp2Stream,\n    channelzSessionInfo: ChannelzSessionInfo | null = null\n  ) {\n    const call = new Http2ServerCallStream(stream, null!, this.options);\n\n    if (err.code === undefined) {\n      err.code = Status.INTERNAL;\n    }\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n    }\n\n    call.sendError(err);\n  }\n\n  private _channelzHandler(\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ) {\n    const channelzSessionInfo = this.sessions.get(\n      stream.session as http2.ServerHttp2Session\n    );\n\n    this.callTracker.addCallStarted();\n    channelzSessionInfo?.streamTracker.addCallStarted();\n\n    if (!this._verifyContentType(stream, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n      return;\n    }\n\n    const path = headers[HTTP2_HEADER_PATH] as string;\n\n    const handler = this._retrieveHandler(path);\n    if (!handler) {\n      this._respondWithError(\n        getUnimplementedStatusResponse(path),\n        stream,\n        channelzSessionInfo\n      );\n      return;\n    }\n\n    const call = new Http2ServerCallStream(stream, handler, this.options);\n\n    call.once('callEnd', (code: Status) => {\n      if (code === Status.OK) {\n        this.callTracker.addCallSucceeded();\n      } else {\n        this.callTracker.addCallFailed();\n      }\n    });\n\n    if (channelzSessionInfo) {\n      call.once('streamEnd', (success: boolean) => {\n        if (success) {\n          channelzSessionInfo.streamTracker.addCallSucceeded();\n        } else {\n          channelzSessionInfo.streamTracker.addCallFailed();\n        }\n      });\n      call.on('sendMessage', () => {\n        channelzSessionInfo.messagesSent += 1;\n        channelzSessionInfo.lastMessageSentTimestamp = new Date();\n      });\n      call.on('receiveMessage', () => {\n        channelzSessionInfo.messagesReceived += 1;\n        channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n      });\n    }\n\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n\n      call.sendError({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`,\n      });\n    }\n  }\n\n  private _streamHandler(\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ) {\n    if (this._verifyContentType(stream, headers) !== true) {\n      return;\n    }\n\n    const path = headers[HTTP2_HEADER_PATH] as string;\n\n    const handler = this._retrieveHandler(path);\n    if (!handler) {\n      this._respondWithError(\n        getUnimplementedStatusResponse(path),\n        stream,\n        null\n      );\n      return;\n    }\n\n    const call = new Http2ServerCallStream(stream, handler, this.options);\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      call.sendError({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`,\n      });\n    }\n  }\n\n  private _runHandlerForCall(\n    call: Http2ServerCallStream<any, any>,\n    handler: Handler<any, any>,\n    headers: http2.IncomingHttpHeaders\n  ): boolean {\n    const metadata = call.receiveMetadata(headers);\n    const encoding =\n      (metadata.get('grpc-encoding')[0] as string | undefined) ?? 'identity';\n    metadata.remove('grpc-encoding');\n\n    const { type } = handler;\n    if (type === 'unary') {\n      handleUnary(call, handler as UntypedUnaryHandler, metadata, encoding);\n    } else if (type === 'clientStream') {\n      handleClientStreaming(\n        call,\n        handler as UntypedClientStreamingHandler,\n        metadata,\n        encoding\n      );\n    } else if (type === 'serverStream') {\n      handleServerStreaming(\n        call,\n        handler as UntypedServerStreamingHandler,\n        metadata,\n        encoding\n      );\n    } else if (type === 'bidi') {\n      handleBidiStreaming(\n        call,\n        handler as UntypedBidiStreamingHandler,\n        metadata,\n        encoding\n      );\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _setupHandlers(\n    http2Server: http2.Http2Server | http2.Http2SecureServer\n  ): void {\n    if (http2Server === null) {\n      return;\n    }\n\n    const serverAddress = http2Server.address();\n    let serverAddressString = 'null';\n    if (serverAddress) {\n      if (typeof serverAddress === 'string') {\n        serverAddressString = serverAddress;\n      } else {\n        serverAddressString = serverAddress.address + ':' + serverAddress.port;\n      }\n    }\n    this.serverAddressString = serverAddressString;\n\n    const handler = this.channelzEnabled\n      ? this._channelzHandler\n      : this._streamHandler;\n\n    http2Server.on('stream', handler.bind(this));\n    http2Server.on('session', session => {\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      const channelzRef = registerChannelzSocket(\n        session.socket.remoteAddress ?? 'unknown',\n        this.getChannelzSessionInfoGetter(session),\n        this.channelzEnabled\n      );\n\n      const channelzSessionInfo: ChannelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null,\n      };\n\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = session.socket.remoteAddress;\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace(\n          'CT_INFO',\n          'Connection established by client ' + clientAddress\n        );\n        this.sessionChildrenTracker.refChild(channelzRef);\n      }\n      let connectionAgeTimer: NodeJS.Timeout | null = null;\n      let connectionAgeGraceTimer: NodeJS.Timeout | null = null;\n      let sessionClosedByServer = false;\n      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n        // Apply a random jitter within a +/-10% range\n        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n        connectionAgeTimer = setTimeout(() => {\n          sessionClosedByServer = true;\n          if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\n              'CT_INFO',\n              'Connection dropped by max connection age from ' + clientAddress\n            );\n          }\n          try {\n            session.goaway(\n              http2.constants.NGHTTP2_NO_ERROR,\n              ~(1 << 31),\n              Buffer.from('max_age')\n            );\n          } catch (e) {\n            // The goaway can't be sent because the session is already closed\n            session.destroy();\n            return;\n          }\n          session.close();\n          /* Allow a grace period after sending the GOAWAY before forcibly\n           * closing the connection. */\n          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n            connectionAgeGraceTimer = setTimeout(() => {\n              session.destroy();\n            }, this.maxConnectionAgeGraceMs).unref?.();\n          }\n        }, this.maxConnectionAgeMs + jitter).unref?.();\n      }\n      const keeapliveTimeTimer: NodeJS.Timeout | null = setInterval(() => {\n        const timeoutTImer = setTimeout(() => {\n          sessionClosedByServer = true;\n          if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\n              'CT_INFO',\n              'Connection dropped by keepalive timeout from ' + clientAddress\n            );\n          }\n          session.close();\n        }, this.keepaliveTimeoutMs).unref?.();\n        try {\n          session.ping(\n            (err: Error | null, duration: number, payload: Buffer) => {\n              clearTimeout(timeoutTImer);\n            }\n          );\n        } catch (e) {\n          // The ping can't be sent because the session is already closed\n          session.destroy();\n        }\n      }, this.keepaliveTimeMs).unref?.();\n      session.on('close', () => {\n        if (this.channelzEnabled) {\n          if (!sessionClosedByServer) {\n            this.channelzTrace.addTrace(\n              'CT_INFO',\n              'Connection dropped by client ' + clientAddress\n            );\n          }\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          unregisterChannelzRef(channelzRef);\n        }\n        if (connectionAgeTimer) {\n          clearTimeout(connectionAgeTimer);\n        }\n        if (connectionAgeGraceTimer) {\n          clearTimeout(connectionAgeGraceTimer);\n        }\n        if (keeapliveTimeTimer) {\n          clearTimeout(keeapliveTimeTimer);\n        }\n        this.sessions.delete(session);\n      });\n    });\n  }\n}\n\nasync function handleUnary<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: UnaryHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): Promise<void> {\n  try {\n    const request = await call.receiveUnaryMessage(encoding);\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const emitter = new ServerUnaryCallImpl<RequestType, ResponseType>(\n      call,\n      metadata,\n      request\n    );\n\n    handler.func(\n      emitter,\n      (\n        err: ServerErrorResponse | ServerStatusResponse | null,\n        value?: ResponseType | null,\n        trailer?: Metadata,\n        flags?: number\n      ) => {\n        call.sendUnaryMessage(err, value, trailer, flags);\n      }\n    );\n  } catch (err) {\n    call.sendError(err as ServerErrorResponse);\n  }\n}\n\nfunction handleClientStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: ClientStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  const stream = new ServerReadableStreamImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    handler.deserialize,\n    encoding\n  );\n\n  function respond(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    trailer?: Metadata,\n    flags?: number\n  ) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nasync function handleServerStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: ServerStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): Promise<void> {\n  try {\n    const request = await call.receiveUnaryMessage(encoding);\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const stream = new ServerWritableStreamImpl<RequestType, ResponseType>(\n      call,\n      metadata,\n      handler.serialize,\n      request\n    );\n\n    handler.func(stream);\n  } catch (err) {\n    call.sendError(err as ServerErrorResponse);\n  }\n}\n\nfunction handleBidiStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: BidiStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  const stream = new ServerDuplexStreamImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    handler.serialize,\n    handler.deserialize,\n    encoding\n  );\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 10333, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10337, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/status-builder.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { StatusObject } from './call-interface';\nimport { Status } from './constants';\nimport { Metadata } from './metadata';\n\n/**\n * A builder for gRPC status objects.\n */\nexport class StatusBuilder {\n  private code: Status | null;\n  private details: string | null;\n  private metadata: Metadata | null;\n\n  constructor() {\n    this.code = null;\n    this.details = null;\n    this.metadata = null;\n  }\n\n  /**\n   * Adds a status code to the builder.\n   */\n  withCode(code: Status): this {\n    this.code = code;\n    return this;\n  }\n\n  /**\n   * Adds details to the builder.\n   */\n  withDetails(details: string): this {\n    this.details = details;\n    return this;\n  }\n\n  /**\n   * Adds metadata to the builder.\n   */\n  withMetadata(metadata: Metadata): this {\n    this.metadata = metadata;\n    return this;\n  }\n\n  /**\n   * Builds the status object.\n   */\n  build(): Partial<StatusObject> {\n    const status: Partial<StatusObject> = {};\n\n    if (this.code !== null) {\n      status.code = this.code;\n    }\n\n    if (this.details !== null) {\n      status.details = this.details;\n    }\n\n    if (this.metadata !== null) {\n      status.metadata = this.metadata;\n    }\n\n    return status;\n  }\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAqBA;;IAGA,MAAa;IAKX,aAAA;QACE,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA;;QAGA,SAAS,IAAY,EAAA;QACnB,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,IAAI;IACb;IAEA;;QAGA,YAAY,OAAe,EAAA;QACzB,IAAI,CAAC,OAAO,GAAG;QACf,OAAO,IAAI;IACb;IAEA;;QAGA,aAAa,QAAkB,EAAA;QAC7B,IAAI,CAAC,QAAQ,GAAG;QAChB,OAAO,IAAI;IACb;IAEA;;QAGA,QAAK;QACH,MAAM,SAAgC,CAAA;QAEtC,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM;YACtB,OAAO,IAAI,GAAG,IAAI,CAAC,IAAI;QACzB;QAEA,IAAI,IAAI,CAAC,OAAO,KAAK,MAAM;YACzB,OAAO,OAAO,GAAG,IAAI,CAAC,OAAO;QAC/B;QAEA,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM;YAC1B,OAAO,QAAQ,GAAG,IAAI,CAAC,QAAQ;QACjC;QAEA,OAAO;IACT;;AAtDF,QAAA,aAAA,GAAA"}},
    {"offset": {"line": 10400, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10404, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/duration.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexport interface Duration {\n  seconds: number;\n  nanos: number;\n}\n\nexport function msToDuration(millis: number): Duration {\n  return {\n    seconds: (millis / 1000) | 0,\n    nanos: ((millis % 1000) * 1_000_000) | 0,\n  };\n}\n\nexport function durationToMs(duration: Duration): number {\n  return (duration.seconds * 1000 + duration.nanos / 1_000_000) | 0;\n}\n\nexport function isDuration(value: any): value is Duration {\n  return typeof value.seconds === 'number' && typeof value.nanos === 'number';\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAsBA,SAAgB,aAAa,MAAc;IACzC,OAAO;QACL,SAAS,AAAC,SAAS,OAAQ;QAC3B,OAAO,AAAE,SAAS,OAAQ,UAAa;;AAE3C;AALA,QAAA,YAAA,GAAA;AAOA,SAAgB,aAAa,QAAkB;IAC7C,OAAO,AAAC,SAAS,OAAO,GAAG,OAAO,SAAS,KAAK,GAAG,UAAa;AAClE;AAFA,QAAA,YAAA,GAAA;AAIA,SAAgB,WAAW,KAAU;IACnC,OAAO,OAAO,MAAM,OAAO,KAAK,YAAY,OAAO,MAAM,KAAK,KAAK;AACrE;AAFA,QAAA,UAAA,GAAA"}},
    {"offset": {"line": 10439, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10443, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/load-balancer-outlier-detection.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { LogVerbosity, Status } from './constants';\nimport { durationToMs, isDuration, msToDuration } from './duration';\nimport {\n  ChannelControlHelper,\n  createChildChannelControlHelper,\n  registerLoadBalancerType,\n} from './experimental';\nimport {\n  getFirstUsableConfig,\n  LoadBalancer,\n  LoadBalancingConfig,\n  validateLoadBalancingConfig,\n} from './load-balancer';\nimport { ChildLoadBalancerHandler } from './load-balancer-child-handler';\nimport { PickArgs, Picker, PickResult, PickResultType } from './picker';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport {\n  BaseSubchannelWrapper,\n  ConnectivityStateListener,\n  SubchannelInterface,\n} from './subchannel-interface';\nimport * as logging from './logging';\n\nconst TRACER_NAME = 'outlier_detection';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'outlier_detection';\n\nconst OUTLIER_DETECTION_ENABLED =\n  (process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION ?? 'true') === 'true';\n\nexport interface SuccessRateEjectionConfig {\n  readonly stdev_factor: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nexport interface FailurePercentageEjectionConfig {\n  readonly threshold: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nconst defaultSuccessRateEjectionConfig: SuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100,\n};\n\nconst defaultFailurePercentageEjectionConfig: FailurePercentageEjectionConfig =\n  {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50,\n  };\n\ntype TypeofValues =\n  | 'object'\n  | 'boolean'\n  | 'function'\n  | 'number'\n  | 'string'\n  | 'undefined';\n\nfunction validateFieldType(\n  obj: any,\n  fieldName: string,\n  expectedType: TypeofValues,\n  objectName?: string\n) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(\n      `outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[\n        fieldName\n      ]}`\n    );\n  }\n}\n\nfunction validatePositiveDuration(\n  obj: any,\n  fieldName: string,\n  objectName?: string\n) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  if (fieldName in obj) {\n    if (!isDuration(obj[fieldName])) {\n      throw new Error(\n        `outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[\n          fieldName\n        ]}`\n      );\n    }\n    if (\n      !(\n        obj[fieldName].seconds >= 0 &&\n        obj[fieldName].seconds <= 315_576_000_000 &&\n        obj[fieldName].nanos >= 0 &&\n        obj[fieldName].nanos <= 999_999_999\n      )\n    ) {\n      throw new Error(\n        `outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`\n      );\n    }\n  }\n}\n\nfunction validatePercentage(obj: any, fieldName: string, objectName?: string) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(\n      `outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`\n    );\n  }\n}\n\nexport class OutlierDetectionLoadBalancingConfig\n  implements LoadBalancingConfig\n{\n  private readonly intervalMs: number;\n  private readonly baseEjectionTimeMs: number;\n  private readonly maxEjectionTimeMs: number;\n  private readonly maxEjectionPercent: number;\n  private readonly successRateEjection: SuccessRateEjectionConfig | null;\n  private readonly failurePercentageEjection: FailurePercentageEjectionConfig | null;\n\n  constructor(\n    intervalMs: number | null,\n    baseEjectionTimeMs: number | null,\n    maxEjectionTimeMs: number | null,\n    maxEjectionPercent: number | null,\n    successRateEjection: Partial<SuccessRateEjectionConfig> | null,\n    failurePercentageEjection: Partial<FailurePercentageEjectionConfig> | null,\n    private readonly childPolicy: LoadBalancingConfig[]\n  ) {\n    if (\n      childPolicy.length > 0 &&\n      childPolicy[0].getLoadBalancerName() === 'pick_first'\n    ) {\n      throw new Error(\n        'outlier_detection LB policy cannot have a pick_first child policy'\n      );\n    }\n    this.intervalMs = intervalMs ?? 10_000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs ?? 30_000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs ?? 300_000;\n    this.maxEjectionPercent = maxEjectionPercent ?? 10;\n    this.successRateEjection = successRateEjection\n      ? { ...defaultSuccessRateEjectionConfig, ...successRateEjection }\n      : null;\n    this.failurePercentageEjection = failurePercentageEjection\n      ? {\n          ...defaultFailurePercentageEjectionConfig,\n          ...failurePercentageEjection,\n        }\n      : null;\n  }\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n  toJsonObject(): object {\n    return {\n      interval: msToDuration(this.intervalMs),\n      base_ejection_time: msToDuration(this.baseEjectionTimeMs),\n      max_ejection_time: msToDuration(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject()),\n    };\n  }\n\n  getIntervalMs(): number {\n    return this.intervalMs;\n  }\n  getBaseEjectionTimeMs(): number {\n    return this.baseEjectionTimeMs;\n  }\n  getMaxEjectionTimeMs(): number {\n    return this.maxEjectionTimeMs;\n  }\n  getMaxEjectionPercent(): number {\n    return this.maxEjectionPercent;\n  }\n  getSuccessRateEjectionConfig(): SuccessRateEjectionConfig | null {\n    return this.successRateEjection;\n  }\n  getFailurePercentageEjectionConfig(): FailurePercentageEjectionConfig | null {\n    return this.failurePercentageEjection;\n  }\n  getChildPolicy(): LoadBalancingConfig[] {\n    return this.childPolicy;\n  }\n\n  copyWithChildPolicy(\n    childPolicy: LoadBalancingConfig[]\n  ): OutlierDetectionLoadBalancingConfig {\n    return new OutlierDetectionLoadBalancingConfig(\n      this.intervalMs,\n      this.baseEjectionTimeMs,\n      this.maxEjectionTimeMs,\n      this.maxEjectionPercent,\n      this.successRateEjection,\n      this.failurePercentageEjection,\n      childPolicy\n    );\n  }\n\n  static createFromJson(obj: any): OutlierDetectionLoadBalancingConfig {\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error(\n          'outlier detection config success_rate_ejection must be an object'\n        );\n      }\n      validateFieldType(\n        obj.success_rate_ejection,\n        'stdev_factor',\n        'number',\n        'success_rate_ejection'\n      );\n      validatePercentage(\n        obj.success_rate_ejection,\n        'enforcement_percentage',\n        'success_rate_ejection'\n      );\n      validateFieldType(\n        obj.success_rate_ejection,\n        'minimum_hosts',\n        'number',\n        'success_rate_ejection'\n      );\n      validateFieldType(\n        obj.success_rate_ejection,\n        'request_volume',\n        'number',\n        'success_rate_ejection'\n      );\n    }\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error(\n          'outlier detection config failure_percentage_ejection must be an object'\n        );\n      }\n      validatePercentage(\n        obj.failure_percentage_ejection,\n        'threshold',\n        'failure_percentage_ejection'\n      );\n      validatePercentage(\n        obj.failure_percentage_ejection,\n        'enforcement_percentage',\n        'failure_percentage_ejection'\n      );\n      validateFieldType(\n        obj.failure_percentage_ejection,\n        'minimum_hosts',\n        'number',\n        'failure_percentage_ejection'\n      );\n      validateFieldType(\n        obj.failure_percentage_ejection,\n        'request_volume',\n        'number',\n        'failure_percentage_ejection'\n      );\n    }\n\n    return new OutlierDetectionLoadBalancingConfig(\n      obj.interval ? durationToMs(obj.interval) : null,\n      obj.base_ejection_time ? durationToMs(obj.base_ejection_time) : null,\n      obj.max_ejection_time ? durationToMs(obj.max_ejection_time) : null,\n      obj.max_ejection_percent ?? null,\n      obj.success_rate_ejection,\n      obj.failure_percentage_ejection,\n      obj.child_policy.map(validateLoadBalancingConfig)\n    );\n  }\n}\n\nclass OutlierDetectionSubchannelWrapper\n  extends BaseSubchannelWrapper\n  implements SubchannelInterface\n{\n  private childSubchannelState: ConnectivityState;\n  private stateListeners: ConnectivityStateListener[] = [];\n  private ejected = false;\n  private refCount = 0;\n  constructor(\n    childSubchannel: SubchannelInterface,\n    private mapEntry?: MapEntry\n  ) {\n    super(childSubchannel);\n    this.childSubchannelState = childSubchannel.getConnectivityState();\n    childSubchannel.addConnectivityStateListener(\n      (subchannel, previousState, newState, keepaliveTime) => {\n        this.childSubchannelState = newState;\n        if (!this.ejected) {\n          for (const listener of this.stateListeners) {\n            listener(this, previousState, newState, keepaliveTime);\n          }\n        }\n      }\n    );\n  }\n\n  getConnectivityState(): ConnectivityState {\n    if (this.ejected) {\n      return ConnectivityState.TRANSIENT_FAILURE;\n    } else {\n      return this.childSubchannelState;\n    }\n  }\n\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n\n  eject() {\n    this.ejected = true;\n    for (const listener of this.stateListeners) {\n      listener(\n        this,\n        this.childSubchannelState,\n        ConnectivityState.TRANSIENT_FAILURE,\n        -1\n      );\n    }\n  }\n\n  uneject() {\n    this.ejected = false;\n    for (const listener of this.stateListeners) {\n      listener(\n        this,\n        ConnectivityState.TRANSIENT_FAILURE,\n        this.childSubchannelState,\n        -1\n      );\n    }\n  }\n\n  getMapEntry(): MapEntry | undefined {\n    return this.mapEntry;\n  }\n\n  getWrappedSubchannel(): SubchannelInterface {\n    return this.child;\n  }\n}\n\ninterface CallCountBucket {\n  success: number;\n  failure: number;\n}\n\nfunction createEmptyBucket(): CallCountBucket {\n  return {\n    success: 0,\n    failure: 0,\n  };\n}\n\nclass CallCounter {\n  private activeBucket: CallCountBucket = createEmptyBucket();\n  private inactiveBucket: CallCountBucket = createEmptyBucket();\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n}\n\ninterface MapEntry {\n  counter: CallCounter;\n  currentEjectionTimestamp: Date | null;\n  ejectionTimeMultiplier: number;\n  subchannelWrappers: OutlierDetectionSubchannelWrapper[];\n}\n\nclass OutlierDetectionPicker implements Picker {\n  constructor(private wrappedPicker: Picker, private countCalls: boolean) {}\n  pick(pickArgs: PickArgs): PickResult {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n    if (wrappedPick.pickResultType === PickResultType.COMPLETE) {\n      const subchannelWrapper =\n        wrappedPick.subchannel as OutlierDetectionSubchannelWrapper;\n      const mapEntry = subchannelWrapper.getMapEntry();\n      if (mapEntry) {\n        let onCallEnded = wrappedPick.onCallEnded;\n        if (this.countCalls) {\n          onCallEnded = statusCode => {\n            if (statusCode === Status.OK) {\n              mapEntry.counter.addSuccess();\n            } else {\n              mapEntry.counter.addFailure();\n            }\n            wrappedPick.onCallEnded?.(statusCode);\n          };\n        }\n        return {\n          ...wrappedPick,\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          onCallEnded: onCallEnded,\n        };\n      } else {\n        return {\n          ...wrappedPick,\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n        };\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n}\n\nexport class OutlierDetectionLoadBalancer implements LoadBalancer {\n  private childBalancer: ChildLoadBalancerHandler;\n  private addressMap: Map<string, MapEntry> = new Map<string, MapEntry>();\n  private latestConfig: OutlierDetectionLoadBalancingConfig | null = null;\n  private ejectionTimer: NodeJS.Timeout;\n  private timerStartTime: Date | null = null;\n\n  constructor(channelControlHelper: ChannelControlHelper) {\n    this.childBalancer = new ChildLoadBalancerHandler(\n      createChildChannelControlHelper(channelControlHelper, {\n        createSubchannel: (\n          subchannelAddress: SubchannelAddress,\n          subchannelArgs: ChannelOptions\n        ) => {\n          const originalSubchannel = channelControlHelper.createSubchannel(\n            subchannelAddress,\n            subchannelArgs\n          );\n          const mapEntry = this.addressMap.get(\n            subchannelAddressToString(subchannelAddress)\n          );\n          const subchannelWrapper = new OutlierDetectionSubchannelWrapper(\n            originalSubchannel,\n            mapEntry\n          );\n          if (mapEntry?.currentEjectionTimestamp !== null) {\n            // If the address is ejected, propagate that to the new subchannel wrapper\n            subchannelWrapper.eject();\n          }\n          mapEntry?.subchannelWrappers.push(subchannelWrapper);\n          return subchannelWrapper;\n        },\n        updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n          if (connectivityState === ConnectivityState.READY) {\n            channelControlHelper.updateState(\n              connectivityState,\n              new OutlierDetectionPicker(picker, this.isCountingEnabled())\n            );\n          } else {\n            channelControlHelper.updateState(connectivityState, picker);\n          }\n        },\n      })\n    );\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n\n  private isCountingEnabled(): boolean {\n    return (\n      this.latestConfig !== null &&\n      (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\n        this.latestConfig.getFailurePercentageEjectionConfig() !== null)\n    );\n  }\n\n  private getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n    return (ejectionCount * 100) / this.addressMap.size;\n  }\n\n  private runSuccessRateCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n    if (!successRateConfig) {\n      return;\n    }\n    trace('Running success rate check');\n    // Step 1\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates: number[] = [];\n    for (const [address, mapEntry] of this.addressMap) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      trace(\n        'Stats for ' +\n          address +\n          ': successes=' +\n          successes +\n          ' failures=' +\n          failures +\n          ' targetRequestVolume=' +\n          targetRequestVolume\n      );\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes / (successes + failures));\n      }\n    }\n    trace(\n      'Found ' +\n        addresesWithTargetVolume +\n        ' success rate candidates; currentEjectionPercent=' +\n        this.getCurrentEjectionPercent() +\n        ' successRates=[' +\n        successRates +\n        ']'\n    );\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    }\n\n    // Step 2\n    const successRateMean =\n      successRates.reduce((a, b) => a + b) / successRates.length;\n    let successRateDeviationSum = 0;\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateDeviationSum += deviation * deviation;\n    }\n    const successRateVariance = successRateDeviationSum / successRates.length;\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold =\n      successRateMean -\n      successRateStdev * (successRateConfig.stdev_factor / 1000);\n    trace(\n      'stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold\n    );\n\n    // Step 3\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 3.i\n      if (\n        this.getCurrentEjectionPercent() >=\n        this.latestConfig.getMaxEjectionPercent()\n      ) {\n        break;\n      }\n      // Step 3.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      }\n      // Step 3.iii\n      const successRate = successes / (successes + failures);\n      trace('Checking candidate ' + address + ' successRate=' + successRate);\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n        trace(\n          'Candidate ' +\n            address +\n            ' randomNumber=' +\n            randomNumber +\n            ' enforcement_percentage=' +\n            successRateConfig.enforcement_percentage\n        );\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private runFailurePercentageCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const failurePercentageConfig =\n      this.latestConfig.getFailurePercentageEjectionConfig();\n    if (!failurePercentageConfig) {\n      return;\n    }\n    trace(\n      'Running failure percentage check. threshold=' +\n        failurePercentageConfig.threshold +\n        ' request volume threshold=' +\n        failurePercentageConfig.request_volume\n    );\n    // Step 1\n    let addressesWithTargetVolume = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures >= failurePercentageConfig.request_volume) {\n        addressesWithTargetVolume += 1;\n      }\n    }\n    if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n      return;\n    }\n\n    // Step 2\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 2.i\n      if (\n        this.getCurrentEjectionPercent() >=\n        this.latestConfig.getMaxEjectionPercent()\n      ) {\n        break;\n      }\n      // Step 2.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      trace('Candidate successes=' + successes + ' failures=' + failures);\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      }\n      // Step 2.iii\n      const failurePercentage = (failures * 100) / (failures + successes);\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n        trace(\n          'Candidate ' +\n            address +\n            ' randomNumber=' +\n            randomNumber +\n            ' enforcement_percentage=' +\n            failurePercentageConfig.enforcement_percentage\n        );\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private eject(mapEntry: MapEntry, ejectionTimestamp: Date) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n\n  private uneject(mapEntry: MapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n\n  private switchAllBuckets() {\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n  }\n\n  private startTimer(delayMs: number) {\n    this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n    this.ejectionTimer.unref?.();\n  }\n\n  private runChecks() {\n    const ejectionTimestamp = new Date();\n    trace('Ejection timer running');\n\n    this.switchAllBuckets();\n\n    if (!this.latestConfig) {\n      return;\n    }\n    this.timerStartTime = ejectionTimestamp;\n    this.startTimer(this.latestConfig.getIntervalMs());\n\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(\n          mapEntry.currentEjectionTimestamp.getTime()\n        );\n        returnTime.setMilliseconds(\n          returnTime.getMilliseconds() +\n            Math.min(\n              baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier,\n              Math.max(baseEjectionTimeMs, maxEjectionTimeMs)\n            )\n        );\n        if (returnTime < new Date()) {\n          trace('Unejecting ' + address);\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig,\n    attributes: { [key: string]: unknown }\n  ): void {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n    const subchannelAddresses = new Set<string>();\n    for (const address of addressList) {\n      subchannelAddresses.add(subchannelAddressToString(address));\n    }\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        trace('Adding map entry for ' + address);\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: [],\n        });\n      }\n    }\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        trace('Removing map entry for ' + key);\n        this.addressMap.delete(key);\n      }\n    }\n    const childPolicy: LoadBalancingConfig = getFirstUsableConfig(\n      lbConfig.getChildPolicy(),\n      true\n    );\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n\n    if (\n      lbConfig.getSuccessRateEjectionConfig() ||\n      lbConfig.getFailurePercentageEjectionConfig()\n    ) {\n      if (this.timerStartTime) {\n        trace('Previous timer existed. Replacing timer');\n        clearTimeout(this.ejectionTimer);\n        const remainingDelay =\n          lbConfig.getIntervalMs() -\n          (new Date().getTime() - this.timerStartTime.getTime());\n        this.startTimer(remainingDelay);\n      } else {\n        trace('Starting new timer');\n        this.timerStartTime = new Date();\n        this.startTimer(lbConfig.getIntervalMs());\n        this.switchAllBuckets();\n      }\n    } else {\n      trace('Counting disabled. Cancelling timer.');\n      this.timerStartTime = null;\n      clearTimeout(this.ejectionTimer);\n      for (const mapEntry of this.addressMap.values()) {\n        this.uneject(mapEntry);\n        mapEntry.ejectionTimeMultiplier = 0;\n      }\n    }\n\n    this.latestConfig = lbConfig;\n  }\n  exitIdle(): void {\n    this.childBalancer.exitIdle();\n  }\n  resetBackoff(): void {\n    this.childBalancer.resetBackoff();\n  }\n  destroy(): void {\n    clearTimeout(this.ejectionTimer);\n    this.childBalancer.destroy();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    registerLoadBalancerType(\n      TYPE_NAME,\n      OutlierDetectionLoadBalancer,\n      OutlierDetectionLoadBalancingConfig\n    );\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11006, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11010, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/experimental.ts"],"sourcesContent":["export { trace, log } from './logging';\nexport {\n  Resolver,\n  ResolverListener,\n  registerResolver,\n  ConfigSelector,\n  createResolver,\n} from './resolver';\nexport { GrpcUri, uriToString } from './uri-parser';\nexport { Duration, durationToMs } from './duration';\nexport { ServiceConfig, MethodConfig, RetryPolicy } from './service-config';\nexport { BackoffTimeout } from './backoff-timeout';\nexport {\n  LoadBalancer,\n  LoadBalancingConfig,\n  ChannelControlHelper,\n  createChildChannelControlHelper,\n  registerLoadBalancerType,\n  getFirstUsableConfig,\n  validateLoadBalancingConfig,\n} from './load-balancer';\nexport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nexport { ChildLoadBalancerHandler } from './load-balancer-child-handler';\nexport {\n  Picker,\n  UnavailablePicker,\n  QueuePicker,\n  PickResult,\n  PickArgs,\n  PickResultType,\n} from './picker';\nexport { Call as CallStream } from './call-interface';\nexport { Filter, BaseFilter, FilterFactory } from './filter';\nexport { FilterStackFactory } from './filter-stack';\nexport { registerAdminService } from './admin';\nexport {\n  SubchannelInterface,\n  BaseSubchannelWrapper,\n  ConnectivityStateListener,\n} from './subchannel-interface';\nexport {\n  OutlierDetectionLoadBalancingConfig,\n  SuccessRateEjectionConfig,\n  FailurePercentageEjectionConfig,\n} from './load-balancer-outlier-detection';\n"],"names":[],"mappings":";;;;;AAAA,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,SAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,KAAK;IAAA;AAAA;AAAE,OAAA,cAAA,CAAA,SAAA,OAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,GAAG;IAAA;AAAA;AACnB,IAAA;AAGE,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,WAAA,gBAAgB;IAAA;AAAA;AAEhB,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,WAAA,cAAc;IAAA;AAAA;AAEhB,IAAA;AAAkB,OAAA,cAAA,CAAA,SAAA,eAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,aAAA,WAAW;IAAA;AAAA;AAC7B,IAAA;AAAmB,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,WAAA,YAAY;IAAA;AAAA;AAE/B,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,kBAAA,cAAc;IAAA;AAAA;AACvB,IAAA;AAIE,OAAA,cAAA,CAAA,SAAA,mCAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,+BAA+B;IAAA;AAAA;AAC/B,OAAA,cAAA,CAAA,SAAA,4BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,wBAAwB;IAAA;AAAA;AACxB,OAAA,cAAA,CAAA,SAAA,wBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,oBAAoB;IAAA;AAAA;AACpB,OAAA,cAAA,CAAA,SAAA,+BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,2BAA2B;IAAA;AAAA;AAE7B,IAAA;AAEE,OAAA,cAAA,CAAA,SAAA,6BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,qBAAA,yBAAyB;IAAA;AAAA;AAE3B,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,4BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,8BAAA,wBAAwB;IAAA;AAAA;AACjC,IAAA;AAEE,OAAA,cAAA,CAAA,SAAA,qBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,iBAAiB;IAAA;AAAA;AACjB,OAAA,cAAA,CAAA,SAAA,eAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,WAAW;IAAA;AAAA;AAGX,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,cAAc;IAAA;AAAA;AAGhB,IAAA;AAAiB,OAAA,cAAA,CAAA,SAAA,cAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,UAAU;IAAA;AAAA;AAC3B,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,sBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,eAAA,kBAAkB;IAAA;AAAA;AAC3B,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,wBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,QAAA,oBAAoB;IAAA;AAAA;AAC7B,IAAA;AAEE,OAAA,cAAA,CAAA,SAAA,yBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,uBAAA,qBAAqB;IAAA;AAAA;AAGvB,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,uCAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,kCAAA,mCAAmC;IAAA;AAAA"}},
    {"offset": {"line": 11155, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11159, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/resolver-uds.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Resolver, ResolverListener, registerResolver } from './resolver';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri } from './uri-parser';\nimport { ChannelOptions } from './channel-options';\n\nclass UdsResolver implements Resolver {\n  private addresses: SubchannelAddress[] = [];\n  private hasReturnedResult = false;\n  constructor(\n    target: GrpcUri,\n    private listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ) {\n    let path: string;\n    if (target.authority === '') {\n      path = '/' + target.path;\n    } else {\n      path = target.path;\n    }\n    this.addresses = [{ path }];\n  }\n  updateResolution(): void {\n    if (!this.hasReturnedResult) {\n      this.hasReturnedResult = true;\n      process.nextTick(\n        this.listener.onSuccessfulResolution,\n        this.addresses,\n        null,\n        null,\n        null,\n        {}\n      );\n    }\n  }\n\n  destroy() {\n    // This resolver owns no resources, so we do nothing here.\n  }\n\n  static getDefaultAuthority(target: GrpcUri): string {\n    return 'localhost';\n  }\n}\n\nexport function setup() {\n  registerResolver('unix', UdsResolver);\n}\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;AAgBA,MAAA;AAKA,MAAM;IAGJ,YACE,MAAe,EACP,QAA0B,EAClC,cAA8B,CAAA;QADtB,IAAA,CAAA,QAAQ,GAAR;QAJF,IAAA,CAAA,SAAS,GAAwB,EAAE;QACnC,IAAA,CAAA,iBAAiB,GAAG;QAM1B,IAAI;QACJ,IAAI,OAAO,SAAS,KAAK,IAAI;YAC3B,OAAO,MAAM,OAAO,IAAI;QAC1B,OAAO;YACL,OAAO,OAAO,IAAI;QACpB;QACA,IAAI,CAAC,SAAS,GAAG;YAAC;gBAAE;YAAI;SAAG;IAC7B;IACA,mBAAgB;QACd,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC3B,IAAI,CAAC,iBAAiB,GAAG;YACzB,QAAQ,QAAQ,CACd,IAAI,CAAC,QAAQ,CAAC,sBAAsB,EACpC,IAAI,CAAC,SAAS,EACd,MACA,MACA,MACA,CAAA;QAEJ;IACF;IAEA,UAAO;IACL,0DAA0D;IAC5D;IAEA,OAAO,oBAAoB,MAAe,EAAA;QACxC,OAAO;IACT;;AAGF,SAAgB;IACd,CAAA,GAAA,WAAA,gBAAgB,EAAC,QAAQ;AAC3B;AAFA,QAAA,KAAA,GAAA"}},
    {"offset": {"line": 11213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11217, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/resolver-ip.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isIPv4, isIPv6 } from 'net';\nimport { StatusObject } from './call-interface';\nimport { ChannelOptions } from './channel-options';\nimport { LogVerbosity, Status } from './constants';\nimport { Metadata } from './metadata';\nimport { registerResolver, Resolver, ResolverListener } from './resolver';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, splitHostPort, uriToString } from './uri-parser';\nimport * as logging from './logging';\n\nconst TRACER_NAME = 'ip_resolver';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst IPV4_SCHEME = 'ipv4';\nconst IPV6_SCHEME = 'ipv6';\n\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\n\nclass IpResolver implements Resolver {\n  private addresses: SubchannelAddress[] = [];\n  private error: StatusObject | null = null;\n  private hasReturnedResult = false;\n  constructor(\n    target: GrpcUri,\n    private listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ) {\n    trace('Resolver constructed for target ' + uriToString(target));\n    const addresses: SubchannelAddress[] = [];\n    if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n      this.error = {\n        code: Status.UNAVAILABLE,\n        details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n        metadata: new Metadata(),\n      };\n      return;\n    }\n    const pathList = target.path.split(',');\n    for (const path of pathList) {\n      const hostPort = splitHostPort(path);\n      if (hostPort === null) {\n        this.error = {\n          code: Status.UNAVAILABLE,\n          details: `Failed to parse ${target.scheme} address ${path}`,\n          metadata: new Metadata(),\n        };\n        return;\n      }\n      if (\n        (target.scheme === IPV4_SCHEME && !isIPv4(hostPort.host)) ||\n        (target.scheme === IPV6_SCHEME && !isIPv6(hostPort.host))\n      ) {\n        this.error = {\n          code: Status.UNAVAILABLE,\n          details: `Failed to parse ${target.scheme} address ${path}`,\n          metadata: new Metadata(),\n        };\n        return;\n      }\n      addresses.push({\n        host: hostPort.host,\n        port: hostPort.port ?? DEFAULT_PORT,\n      });\n    }\n    this.addresses = addresses;\n    trace('Parsed ' + target.scheme + ' address list ' + this.addresses);\n  }\n  updateResolution(): void {\n    if (!this.hasReturnedResult) {\n      this.hasReturnedResult = true;\n      process.nextTick(() => {\n        if (this.error) {\n          this.listener.onError(this.error);\n        } else {\n          this.listener.onSuccessfulResolution(\n            this.addresses,\n            null,\n            null,\n            null,\n            {}\n          );\n        }\n      });\n    }\n  }\n  destroy(): void {\n    this.hasReturnedResult = false;\n  }\n\n  static getDefaultAuthority(target: GrpcUri): string {\n    return target.path.split(',')[0];\n  }\n}\n\nexport function setup() {\n  registerResolver(IPV4_SCHEME, IpResolver);\n  registerResolver(IPV6_SCHEME, IpResolver);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11319, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11323, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/load-balancer-pick-first.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  registerDefaultLoadBalancerType,\n  registerLoadBalancerType,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport { SubchannelAddress } from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  SubchannelInterface,\n  ConnectivityStateListener,\n} from './subchannel-interface';\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n\nexport class PickFirstLoadBalancingConfig implements LoadBalancingConfig {\n  constructor(private readonly shuffleAddressList: boolean) {}\n\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList,\n      },\n    };\n  }\n\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    if (\n      'shuffleAddressList' in obj &&\n      !(typeof obj.shuffleAddressList === 'boolean')\n    ) {\n      throw new Error(\n        'pick_first config field shuffleAddressList must be a boolean if provided'\n      );\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\n\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker implements Picker {\n  constructor(private subchannel: SubchannelInterface) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null,\n    };\n  }\n}\n\ninterface SubchannelChild {\n  subchannel: SubchannelInterface;\n  hasReportedTransientFailure: boolean;\n}\n\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nexport function shuffled<T>(list: T[]): T[] {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\n\nexport class PickFirstLoadBalancer implements LoadBalancer {\n  /**\n   * The list of subchannels this load balancer is currently attempting to\n   * connect to.\n   */\n  private children: SubchannelChild[] = [];\n  /**\n   * The current connectivity state of the load balancer.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The index within the `subchannels` array of the subchannel with the most\n   * recently started connection attempt.\n   */\n  private currentSubchannelIndex = 0;\n  /**\n   * The currently picked subchannel used for making calls. Populated if\n   * and only if the load balancer's current state is READY. In that case,\n   * the subchannel's current state is also READY.\n   */\n  private currentPick: SubchannelInterface | null = null;\n  /**\n   * Listener callback attached to each subchannel in the `subchannels` list\n   * while establishing a connection.\n   */\n  private subchannelStateListener: ConnectivityStateListener = (\n    subchannel,\n    previousState,\n    newState,\n    keepaliveTime,\n    errorMessage\n  ) => {\n    this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n  };\n  /**\n   * Timer reference for the timer tracking when to start\n   */\n  private connectionDelayTimeout: NodeJS.Timeout;\n\n  private triedAllSubchannels = false;\n\n  /**\n   * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n   * subchannels have failed to connect at least once, and it stays in that\n   * mode until a connection attempt is successful. While in sticky TF mode,\n   * the LB policy continuously attempts to connect to all of its subchannels.\n   */\n  private stickyTransientFailureMode = false;\n\n  /**\n   * Indicates whether we called channelControlHelper.requestReresolution since\n   * the last call to updateAddressList\n   */\n  private requestedResolutionSinceLastUpdate = false;\n\n  /**\n   * The most recent error reported by any subchannel as it transitioned to\n   * TRANSIENT_FAILURE.\n   */\n  private lastError: string | null = null;\n\n  private latestAddressList: SubchannelAddress[] | null = null;\n\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  private allChildrenHaveReportedTF(): boolean {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n\n  private calculateAndReportNewState() {\n    if (this.currentPick) {\n      this.updateState(\n        ConnectivityState.READY,\n        new PickFirstPicker(this.currentPick)\n      );\n    } else if (this.children.length === 0) {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    } else {\n      if (this.stickyTransientFailureMode) {\n        this.updateState(\n          ConnectivityState.TRANSIENT_FAILURE,\n          new UnavailablePicker({details: `No connection established. Last error: ${this.lastError}`})\n        );\n      } else {\n        this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n      }\n    }\n  }\n\n  private requestReresolution() {\n    this.requestedResolutionSinceLastUpdate = true;\n    this.channelControlHelper.requestReresolution();\n  }\n\n  private maybeEnterStickyTransientFailureMode() {\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    if (!this.requestedResolutionSinceLastUpdate) {\n      /* Each time we get an update we reset each subchannel's\n       * hasReportedTransientFailure flag, so the next time we get to this\n       * point after that, each subchannel has reported TRANSIENT_FAILURE\n       * at least once since then. That is the trigger for requesting\n       * reresolution, whether or not the LB policy is already in sticky TF\n       * mode. */\n      this.requestReresolution();\n    }\n    if (this.stickyTransientFailureMode) {\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    for (const { subchannel } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n\n  private removeCurrentPick() {\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      this.currentPick = null;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(\n        currentPick.getChannelzRef()\n      );\n    }\n  }\n\n  private onSubchannelStateUpdate(\n    subchannel: SubchannelInterface,\n    previousState: ConnectivityState,\n    newState: ConnectivityState,\n    errorMessage?: string\n  ) {\n    if (this.currentPick?.realSubchannelEquals(subchannel)) {\n      if (newState !== ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n        this.requestReresolution();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          if (errorMessage) {\n            this.lastError = errorMessage;\n          }\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n\n  private startNextSubchannelConnecting(startIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    if (this.triedAllSubchannels) {\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (\n          subchannelState === ConnectivityState.IDLE ||\n          subchannelState === ConnectivityState.CONNECTING\n        ) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.triedAllSubchannels = true;\n    this.maybeEnterStickyTransientFailureMode();\n  }\n\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  private startConnecting(subchannelIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (\n      this.children[subchannelIndex].subchannel.getConnectivityState() ===\n      ConnectivityState.IDLE\n    ) {\n      trace(\n        'Start connecting to subchannel with address ' +\n          this.children[subchannelIndex].subchannel.getAddress()\n      );\n      process.nextTick(() => {\n        this.children[subchannelIndex]?.subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS).unref?.();\n  }\n\n  private pickSubchannel(subchannel: SubchannelInterface) {\n    if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {\n      return;\n    }\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.channelControlHelper.removeChannelzChild(\n        this.currentPick.getChannelzRef()\n      );\n      this.currentPick.removeConnectivityStateListener(\n        this.subchannelStateListener\n      );\n    }\n    this.currentPick = subchannel;\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const child of this.children) {\n      if (!(this.currentPick && child.subchannel.realSubchannelEquals(this.currentPick))) {\n        /* The connectivity state listener is the same whether the subchannel\n         * is in the list of children or it is the currentPick, so if it is in\n         * both, removing it here would cause problems. In particular, that\n         * always happens immediately after the subchannel is picked. */\n        child.subchannel.removeConnectivityStateListener(\n          this.subchannelStateListener\n        );\n      }\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(\n        child.subchannel.getChannelzRef()\n      );\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n    this.triedAllSubchannels = false;\n    this.requestedResolutionSinceLastUpdate = false;\n  }\n\n  private connectToAddressList(addressList: SubchannelAddress[]) {\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, {}),\n      hasReportedTransientFailure: false,\n    }));\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const { subchannel } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const { subchannel } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      if (subchannel.getConnectivityState() === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    for (const child of this.children) {\n      if (\n        child.subchannel.getConnectivityState() ===\n        ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig\n  ): void {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      addressList = shuffled(addressList);\n    }\n    this.latestAddressList = addressList;\n    this.connectToAddressList(addressList);\n  }\n\n  exitIdle() {\n    if (this.currentState === ConnectivityState.IDLE && this.latestAddressList) {\n      this.connectToAddressList(this.latestAddressList);\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup(): void {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    PickFirstLoadBalancer,\n    PickFirstLoadBalancingConfig\n  );\n  registerDefaultLoadBalancerType(TYPE_NAME);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11688, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11692, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/load-balancer-round-robin.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  registerLoadBalancerType,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  ConnectivityStateListener,\n  SubchannelInterface,\n} from './subchannel-interface';\n\nconst TRACER_NAME = 'round_robin';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'round_robin';\n\nclass RoundRobinLoadBalancingConfig implements LoadBalancingConfig {\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {},\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\n\nclass RoundRobinPicker implements Picker {\n  constructor(\n    private readonly subchannelList: SubchannelInterface[],\n    private nextIndex = 0\n  ) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null,\n    };\n  }\n\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextSubchannel(): SubchannelInterface {\n    return this.subchannelList[this.nextIndex];\n  }\n}\n\nexport class RoundRobinLoadBalancer implements LoadBalancer {\n  private subchannels: SubchannelInterface[] = [];\n\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n\n  private subchannelStateListener: ConnectivityStateListener;\n\n  private currentReadyPicker: RoundRobinPicker | null = null;\n\n  private lastError: string | null = null;\n\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {\n    this.subchannelStateListener = (\n      subchannel: SubchannelInterface,\n      previousState: ConnectivityState,\n      newState: ConnectivityState,\n      keepaliveTime: number,\n      errorMessage?: string\n    ) => {\n      this.calculateAndUpdateState();\n      if (\n        newState === ConnectivityState.TRANSIENT_FAILURE ||\n        newState === ConnectivityState.IDLE\n      ) {\n        if (errorMessage) {\n          this.lastError = errorMessage;\n        }\n        this.channelControlHelper.requestReresolution();\n        subchannel.startConnecting();\n      }\n    };\n  }\n\n  private countSubchannelsWithState(state: ConnectivityState) {\n    return this.subchannels.filter(\n      subchannel => subchannel.getConnectivityState() === state\n    ).length;\n  }\n\n  private calculateAndUpdateState() {\n    if (this.countSubchannelsWithState(ConnectivityState.READY) > 0) {\n      const readySubchannels = this.subchannels.filter(\n        subchannel =>\n          subchannel.getConnectivityState() === ConnectivityState.READY\n      );\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(\n          this.currentReadyPicker.peekNextSubchannel()\n        );\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(\n        ConnectivityState.READY,\n        new RoundRobinPicker(readySubchannels, index)\n      );\n    } else if (\n      this.countSubchannelsWithState(ConnectivityState.CONNECTING) > 0\n    ) {\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    } else if (\n      this.countSubchannelsWithState(ConnectivityState.TRANSIENT_FAILURE) > 0\n    ) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker({details: `No connection established. Last error: ${this.lastError}`})\n      );\n    } else {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    }\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (newState === ConnectivityState.READY) {\n      this.currentReadyPicker = picker as RoundRobinPicker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(\n        subchannel.getChannelzRef()\n      );\n    }\n    this.subchannels = [];\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig\n  ): void {\n    this.resetSubchannelList();\n    trace(\n      'Connect to address list ' +\n        addressList.map(address => subchannelAddressToString(address))\n    );\n    this.subchannels = addressList.map(address =>\n      this.channelControlHelper.createSubchannel(address, {})\n    );\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n      const subchannelState = subchannel.getConnectivityState();\n      if (\n        subchannelState === ConnectivityState.IDLE ||\n        subchannelState === ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        subchannel.startConnecting();\n      }\n    }\n    this.calculateAndUpdateState();\n  }\n\n  exitIdle(): void {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n  resetBackoff(): void {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy(): void {\n    this.resetSubchannelList();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    RoundRobinLoadBalancer,\n    RoundRobinLoadBalancingConfig\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 11857, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11861, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@grpc/grpc-js/src/index.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ClientDuplexStream,\n  ClientReadableStream,\n  ClientUnaryCall,\n  ClientWritableStream,\n  ServiceError,\n} from './call';\nimport { CallCredentials, OAuth2Client } from './call-credentials';\nimport { StatusObject } from './call-interface';\nimport { Channel, ChannelImplementation } from './channel';\nimport { CompressionAlgorithms } from './compression-algorithms';\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelCredentials } from './channel-credentials';\nimport {\n  CallOptions,\n  Client,\n  ClientOptions,\n  CallInvocationTransformer,\n  CallProperties,\n  UnaryCallback,\n} from './client';\nimport { LogVerbosity, Status, Propagate } from './constants';\nimport * as logging from './logging';\nimport {\n  Deserialize,\n  loadPackageDefinition,\n  makeClientConstructor,\n  MethodDefinition,\n  Serialize,\n  ServiceDefinition,\n} from './make-client';\nimport { Metadata, MetadataOptions, MetadataValue } from './metadata';\nimport {\n  Server,\n  UntypedHandleCall,\n  UntypedServiceImplementation,\n} from './server';\nimport { KeyCertPair, ServerCredentials } from './server-credentials';\nimport { StatusBuilder } from './status-builder';\nimport {\n  handleBidiStreamingCall,\n  handleServerStreamingCall,\n  handleClientStreamingCall,\n  handleUnaryCall,\n  sendUnaryData,\n  ServerUnaryCall,\n  ServerReadableStream,\n  ServerWritableStream,\n  ServerDuplexStream,\n  ServerErrorResponse,\n} from './server-call';\n\nexport { OAuth2Client };\n\n/**** Client Credentials ****/\n\n// Using assign only copies enumerable properties, which is what we want\nexport const credentials = {\n  /**\n   * Combine a ChannelCredentials with any number of CallCredentials into a\n   * single ChannelCredentials object.\n   * @param channelCredentials The ChannelCredentials object.\n   * @param callCredentials Any number of CallCredentials objects.\n   * @return The resulting ChannelCredentials object.\n   */\n  combineChannelCredentials: (\n    channelCredentials: ChannelCredentials,\n    ...callCredentials: CallCredentials[]\n  ): ChannelCredentials => {\n    return callCredentials.reduce(\n      (acc, other) => acc.compose(other),\n      channelCredentials\n    );\n  },\n\n  /**\n   * Combine any number of CallCredentials into a single CallCredentials\n   * object.\n   * @param first The first CallCredentials object.\n   * @param additional Any number of additional CallCredentials objects.\n   * @return The resulting CallCredentials object.\n   */\n  combineCallCredentials: (\n    first: CallCredentials,\n    ...additional: CallCredentials[]\n  ): CallCredentials => {\n    return additional.reduce((acc, other) => acc.compose(other), first);\n  },\n\n  // from channel-credentials.ts\n  createInsecure: ChannelCredentials.createInsecure,\n  createSsl: ChannelCredentials.createSsl,\n  createFromSecureContext: ChannelCredentials.createFromSecureContext,\n\n  // from call-credentials.ts\n  createFromMetadataGenerator: CallCredentials.createFromMetadataGenerator,\n  createFromGoogleCredential: CallCredentials.createFromGoogleCredential,\n  createEmpty: CallCredentials.createEmpty,\n};\n\n/**** Metadata ****/\n\nexport { Metadata, MetadataOptions, MetadataValue };\n\n/**** Constants ****/\n\nexport {\n  LogVerbosity as logVerbosity,\n  Status as status,\n  ConnectivityState as connectivityState,\n  Propagate as propagate,\n  CompressionAlgorithms as compressionAlgorithms,\n  // TODO: Other constants as well\n};\n\n/**** Client ****/\n\nexport {\n  Client,\n  ClientOptions,\n  loadPackageDefinition,\n  makeClientConstructor,\n  makeClientConstructor as makeGenericClientConstructor,\n  CallProperties,\n  CallInvocationTransformer,\n  ChannelImplementation as Channel,\n  Channel as ChannelInterface,\n  UnaryCallback as requestCallback,\n};\n\n/**\n * Close a Client object.\n * @param client The client to close.\n */\nexport const closeClient = (client: Client) => client.close();\n\nexport const waitForClientReady = (\n  client: Client,\n  deadline: Date | number,\n  callback: (error?: Error) => void\n) => client.waitForReady(deadline, callback);\n\n/* Interfaces */\n\nexport {\n  sendUnaryData,\n  ChannelCredentials,\n  CallCredentials,\n  Deadline,\n  Serialize as serialize,\n  Deserialize as deserialize,\n  ClientUnaryCall,\n  ClientReadableStream,\n  ClientWritableStream,\n  ClientDuplexStream,\n  CallOptions,\n  MethodDefinition,\n  StatusObject,\n  ServiceError,\n  ServerUnaryCall,\n  ServerReadableStream,\n  ServerWritableStream,\n  ServerDuplexStream,\n  ServerErrorResponse,\n  ServiceDefinition,\n  UntypedHandleCall,\n  UntypedServiceImplementation,\n};\n\n/**** Server ****/\n\nexport {\n  handleBidiStreamingCall,\n  handleServerStreamingCall,\n  handleUnaryCall,\n  handleClientStreamingCall,\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type Call =\n  | ClientUnaryCall\n  | ClientReadableStream<any>\n  | ClientWritableStream<any>\n  | ClientDuplexStream<any, any>;\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**** Unimplemented function stubs ****/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport const loadObject = (value: any, options: any): never => {\n  throw new Error(\n    'Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead'\n  );\n};\n\nexport const load = (filename: any, format: any, options: any): never => {\n  throw new Error(\n    'Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead'\n  );\n};\n\nexport const setLogger = (logger: Partial<Console>): void => {\n  logging.setLogger(logger);\n};\n\nexport const setLogVerbosity = (verbosity: LogVerbosity): void => {\n  logging.setLoggerVerbosity(verbosity);\n};\n\nexport { Server };\nexport { ServerCredentials };\nexport { KeyCertPair };\n\nexport const getClientChannel = (client: Client) => {\n  return Client.prototype.getChannel.call(client);\n};\n\nexport { StatusBuilder };\n\nexport { Listener, InterceptingListener } from './call-interface';\n\nexport {\n  Requester,\n  ListenerBuilder,\n  RequesterBuilder,\n  Interceptor,\n  InterceptorOptions,\n  InterceptorProvider,\n  InterceptingCall,\n  InterceptorConfigurationError,\n  NextCall,\n} from './client-interceptors';\n\nexport {\n  GrpcObject,\n  ServiceClientConstructor,\n  ProtobufTypeDefinition,\n} from './make-client';\n\nexport { ChannelOptions } from './channel-options';\n\nexport { getChannelzServiceDefinition, getChannelzHandlers } from './channelz';\n\nexport { addAdminServicesToServer } from './admin';\n\nimport * as experimental from './experimental';\nexport { experimental };\n\nimport * as resolver_dns from './resolver-dns';\nimport * as resolver_uds from './resolver-uds';\nimport * as resolver_ip from './resolver-ip';\nimport * as load_balancer_pick_first from './load-balancer-pick-first';\nimport * as load_balancer_round_robin from './load-balancer-round-robin';\nimport * as load_balancer_outlier_detection from './load-balancer-outlier-detection';\nimport * as channelz from './channelz';\nimport { Deadline } from './deadline';\n\n(() => {\n  resolver_dns.setup();\n  resolver_uds.setup();\n  resolver_ip.setup();\n  load_balancer_pick_first.setup();\n  load_balancer_round_robin.setup();\n  load_balancer_outlier_detection.setup();\n  channelz.setup();\n})();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 12109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}